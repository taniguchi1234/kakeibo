import { DOMRectPolyfill } from "../../utils/domrect-polyfill";
import { IgcDockManagerComponentMock } from "../../utils/test-utils";
import { Utils } from "../../utils/utils";
import { IgcDockManagerPaneType, IgcDockingIndicatorPosition, IgcPaneDragActionType, IgcResizerLocation, IgcSplitPaneOrientation, IgcUnpinnedLocation } from "./dockmanager.public-interfaces";
describe('Dock Manager Service', () => {
  let dockManager;
  let service;
  let keyboardService;
  beforeAll(() => {
    global.DOMRect = DOMRectPolyfill;
  });
  beforeEach(() => {
    dockManager = new IgcDockManagerComponentMock();
    service = dockManager.service;
    keyboardService = dockManager.keyboardService;
  });
  describe('Resizing', () => {
    let rootPane;
    beforeEach(() => {
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [
            {
              type: IgcDockManagerPaneType.contentPane,
              contentId: '1',
              header: 'Header'
            },
            {
              type: IgcDockManagerPaneType.contentPane,
              contentId: '2',
              header: 'Header'
            },
            {
              type: IgcDockManagerPaneType.contentPane,
              contentId: '3',
              header: 'Header'
            }
          ]
        }
      };
      rootPane = dockManager.layout.rootPane;
    });
    it('resizing with default sizes', () => {
      service.resizePane(rootPane.panes[1], 0.1);
      expect(rootPane.panes[0].size).toBe(130);
      expect(rootPane.panes[1].size).toBe(70);
      expect(rootPane.panes[2].size).toBeUndefined();
    });
    it('resizing with custom sizes', () => {
      rootPane.panes[0].size = 200;
      rootPane.panes[1].size = 300;
      rootPane.panes[2].size = 150;
      service.resizePane(rootPane.panes[1], -0.2);
      expect(rootPane.panes[0].size).toBe(70);
      expect(rootPane.panes[1].size).toBe(430);
      expect(rootPane.panes[2].size).toBe(150);
    });
    it('resizing when there is unpinned pane', () => {
      service.togglePin(rootPane.panes[0]);
      service.resizePane(rootPane.panes[2], -0.2);
      expect(rootPane.panes[0].size).toBeUndefined();
      expect(rootPane.panes[1].size).toBe(60);
      expect(rootPane.panes[2].size).toBe(140);
    });
    it('resizing when there is hidden pane', () => {
      rootPane.panes[0].hidden = true;
      dockManager.layout = Object.assign({}, dockManager.layout);
      service.resizePane(rootPane.panes[2], -0.2);
      expect(rootPane.panes[0].size).toBeUndefined();
      expect(rootPane.panes[1].size).toBe(60);
      expect(rootPane.panes[2].size).toBe(140);
    });
    it('flyout resizing', () => {
      const firstPane = rootPane.panes[0];
      service.togglePin(firstPane);
      service.flyoutPane(firstPane);
      service.resizeFlyoutPane(100);
      expect(firstPane.unpinnedSize).toEqual(300);
      expect(rootPane.panes[0].size).toBeUndefined();
      expect(rootPane.panes[1].size).toBeUndefined();
      expect(rootPane.panes[2].size).toBeUndefined();
    });
  });
  describe('Pinning', () => {
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    let pane5;
    let pane6;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header'
      };
      pane6 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '6',
        header: 'Header',
        unpinnedLocation: IgcUnpinnedLocation.bottom
      };
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [
            {
              type: IgcDockManagerPaneType.tabGroupPane,
              panes: [pane1, pane2]
            },
            {
              type: IgcDockManagerPaneType.documentHost,
              rootPane: {
                type: IgcDockManagerPaneType.splitPane,
                orientation: IgcSplitPaneOrientation.horizontal,
                panes: [pane3]
              }
            }
          ]
        }
      };
    });
    it('verify unpin locations', () => {
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [
            pane1,
            {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.vertical,
              panes: [
                pane2,
                {
                  type: IgcDockManagerPaneType.documentHost,
                  rootPane: {
                    type: IgcDockManagerPaneType.splitPane,
                    orientation: IgcSplitPaneOrientation.horizontal,
                    panes: [pane3]
                  }
                },
                pane4
              ]
            },
            pane5,
            pane6
          ]
        }
      };
      const eventSpy = jest.spyOn(dockManager.panePinnedToggle, 'emit');
      service.togglePin(pane1);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane1, panes: [pane1], newValue: false, location: IgcUnpinnedLocation.left });
      service.togglePin(pane2);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane2, panes: [pane2], newValue: false, location: IgcUnpinnedLocation.top });
      service.togglePin(pane4);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane4, panes: [pane4], newValue: false, location: IgcUnpinnedLocation.bottom });
      service.togglePin(pane5);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane5, panes: [pane5], newValue: false, location: IgcUnpinnedLocation.right });
      service.togglePin(pane6);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane6, panes: [pane6], newValue: false, location: IgcUnpinnedLocation.bottom });
      expect(Array.from(service.unpinnedLocationMap.keys())).toEqual([pane1, pane2, pane4, pane5, pane6]);
      expect(Array.from(service.unpinnedLocationMap.values())).toEqual([
        IgcUnpinnedLocation.left,
        IgcUnpinnedLocation.top,
        IgcUnpinnedLocation.bottom,
        IgcUnpinnedLocation.right,
        IgcUnpinnedLocation.bottom
      ]);
    });
    it('pin/unpin pane in a tab group', () => {
      const eventSpy = jest.spyOn(dockManager.panePinnedToggle, 'emit');
      service.togglePin(pane1);
      expect(pane1.isPinned).toBe(false);
      expect(pane2.isPinned).toBe(false);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane1, panes: [pane1, pane2], newValue: false, location: IgcUnpinnedLocation.left });
      service.flyoutPane(pane2);
      expect(dockManager.flyoutPane).toBe(pane2);
      service.togglePin(pane2);
      expect(pane1.isPinned).toBe(true);
      expect(pane2.isPinned).toBe(true);
      expect(dockManager.flyoutPane).toBeNull();
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane2, panes: [pane1, pane2], newValue: true, location: IgcUnpinnedLocation.left });
    });
    it('pin/unpin pane emit layoutChange', () => {
      const eventSpy = jest.spyOn(dockManager.layoutChange, 'emit');
      service.togglePin(pane1);
      expect(pane1.isPinned).toBe(false);
      expect(pane2.isPinned).toBe(false);
      expect(eventSpy).toHaveBeenCalled();
    });
    it('cancel pane pinned event', () => {
      const eventSpy = jest.spyOn(dockManager.panePinnedToggle, 'emit');
      dockManager.panePinnedToggle.addEventListener(event => {
        event.preventDefault();
      });
      service.togglePin(pane1);
      expect(pane1.isPinned).toBe(undefined);
      expect(pane2.isPinned).toBe(undefined);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane1, panes: [pane1, pane2], newValue: false, location: IgcUnpinnedLocation.left });
    });
    it('modify panes in the pane pinned event', () => {
      const eventSpy = jest.spyOn(dockManager.panePinnedToggle, 'emit');
      dockManager.panePinnedToggle.addEventListener(event => {
        event.detail.panes = [event.detail.sourcePane];
      });
      service.togglePin(pane1);
      expect(pane1.isPinned).toBe(false);
      expect(pane2.isPinned).toBe(undefined);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane1, panes: [pane1], newValue: false, location: IgcUnpinnedLocation.left });
    });
    it('toggle flyout pane', () => {
      service.togglePin(pane1);
      expect(pane1.isPinned).toBe(false);
      expect(pane1.isPinned).toBe(false);
      service.flyoutPane(pane2);
      expect(dockManager.flyoutPane).toBe(pane2);
      service.flyoutPane(pane2);
      expect(dockManager.flyoutPane).toBeNull();
    });
  });
  describe('Closing', () => {
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    let pane5;
    let pane6;
    let pane7;
    let pane8;
    let pane9;
    let rootPane;
    let floatingPanes;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header'
      };
      pane6 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '6',
        header: 'Header'
      };
      pane7 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '7',
        header: 'Header'
      };
      pane8 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '8',
        header: 'Header'
      };
      pane9 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '9',
        header: 'Header'
      };
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [
            {
              type: IgcDockManagerPaneType.tabGroupPane,
              panes: [pane1, pane2]
            },
            {
              type: IgcDockManagerPaneType.documentHost,
              rootPane: {
                type: IgcDockManagerPaneType.splitPane,
                orientation: IgcSplitPaneOrientation.horizontal,
                panes: [pane3]
              }
            },
            {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.vertical,
              panes: [pane4, pane5]
            }
          ]
        },
        floatingPanes: [
          {
            type: IgcDockManagerPaneType.splitPane,
            orientation: IgcSplitPaneOrientation.horizontal,
            panes: [
              pane6,
              {
                type: IgcDockManagerPaneType.splitPane,
                orientation: IgcSplitPaneOrientation.vertical,
                panes: [
                  pane7,
                  {
                    type: IgcDockManagerPaneType.tabGroupPane,
                    panes: [pane8, pane9]
                  }
                ]
              }
            ]
          }
        ]
      };
      rootPane = dockManager.layout.rootPane;
      floatingPanes = dockManager.layout.floatingPanes;
    });
    it('closing content panes', () => {
      const eventSpy = jest.spyOn(dockManager.paneClose, 'emit');
      service.closePane(pane4);
      expect(rootPane.panes.length).toEqual(3);
      // TODO Temporary removed
      // expect(rootPane.panes[2]).toBe(pane5);
      expect(rootPane.panes[2].type).toBe(IgcDockManagerPaneType.splitPane);
      expect(rootPane.panes[2].panes).toEqual([pane5]);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane4, panes: [pane4] });
      service.closePane(pane5);
      expect(rootPane.panes.length).toEqual(2);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane5, panes: [pane5] });
    });
    it('cancel closing content pane', () => {
      const eventSpy = jest.spyOn(dockManager.paneClose, 'emit');
      dockManager.paneClose.addEventListener(e => {
        e.preventDefault();
      });
      service.closePane(pane4);
      expect(rootPane.panes.length).toEqual(3);
      expect(rootPane.panes[2].type).toBe(IgcDockManagerPaneType.splitPane);
      expect(rootPane.panes[2].panes).toEqual([pane4, pane5]);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane4, panes: [pane4] });
    });
    it('closing content panes in tab group', () => {
      const eventSpy = jest.spyOn(dockManager.paneClose, 'emit');
      service.closePane(pane1);
      expect(rootPane.panes.length).toEqual(2);
      expect(rootPane.panes[0].type).toEqual(IgcDockManagerPaneType.documentHost);
      expect(rootPane.panes[1].type).toEqual(IgcDockManagerPaneType.splitPane);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane1, panes: [pane1, pane2] });
    });
    it('closing content panes in tab group when allowClose is false', () => {
      pane2.allowClose = false;
      service.closePane(pane1);
      expect(rootPane.panes.length).toEqual(3);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(rootPane.panes[0].panes).toEqual([pane2]);
      expect(rootPane.panes[1].type).toEqual(IgcDockManagerPaneType.documentHost);
    });
    it('closing pinned content panes in tab group', () => {
      service.togglePin(pane1);
      service.flyoutPane(pane2);
      service.closePane(pane2);
      expect(rootPane.panes.length).toEqual(3);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(rootPane.panes[0].panes).toEqual([pane1]);
      expect(pane1.isPinned).toEqual(false);
      expect(dockManager.flyoutPane).toEqual(null);
      service.flyoutPane(pane1);
      service.closePane(pane1);
      expect(rootPane.panes.length).toEqual(2);
      expect(rootPane.panes[0].type).toEqual(IgcDockManagerPaneType.documentHost);
      expect(rootPane.panes[1].type).toEqual(IgcDockManagerPaneType.splitPane);
      expect(dockManager.flyoutPane).toEqual(null);
    });
    it('closing tab headers in tab group', () => {
      const eventSpy = jest.spyOn(dockManager.paneClose, 'emit');
      const tabGroup = rootPane.panes[0];
      service.closeTabPane(pane1);
      expect(tabGroup.panes[0]).toBe(pane2);
      expect(rootPane.panes.length).toBe(3);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane1, panes: [pane1] });
      service.closeTabPane(pane2);
      expect(rootPane.panes.length).toBe(2);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.documentHost);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: pane2, panes: [pane2] });
    });
    it('closing floating pane', () => {
      const eventSpy = jest.spyOn(dockManager.paneClose, 'emit');
      const floatingPane = floatingPanes[0];
      service.closeFloatingPane(floatingPane);
      expect(floatingPanes.length).toBe(0);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: floatingPane, panes: [pane6, pane7, pane8, pane9] });
    });
    it('modify panes argument on closing floating pane', () => {
      const eventSpy = jest.spyOn(dockManager.paneClose, 'emit');
      const floatingPane = floatingPanes[0];
      dockManager.paneClose.addEventListener(e => {
        e.detail.panes = [pane6, pane7, pane9];
      });
      service.closeFloatingPane(floatingPane);
      expect(floatingPanes.length).toBe(1);
      expect(floatingPanes[0].panes.length).toBe(1);
      expect(floatingPanes[0].panes[0].type).toBe(IgcDockManagerPaneType.splitPane);
      const splitPane = floatingPanes[0].panes[0];
      expect(splitPane.panes.length).toBe(1);
      expect(splitPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(splitPane.panes[0].panes).toEqual([pane8]);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: floatingPane, panes: [pane6, pane7, pane9] });
    });
    it('closing floating pane when allowClose is false', () => {
      const eventSpy = jest.spyOn(dockManager.paneClose, 'emit');
      const floatingPane = floatingPanes[0];
      pane8.allowClose = false;
      service.closeFloatingPane(floatingPane);
      expect(floatingPanes.length).toBe(1);
      expect(floatingPanes[0].panes.length).toBe(1);
      expect(floatingPanes[0].panes[0].type).toBe(IgcDockManagerPaneType.splitPane);
      const splitPane = floatingPanes[0].panes[0];
      expect(splitPane.panes.length).toBe(1);
      expect(splitPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(splitPane.panes[0].panes).toEqual([pane8]);
      expect(eventSpy).toHaveBeenCalledWith({ sourcePane: floatingPane, panes: [pane6, pane7, pane9] });
    });
  });
  describe('Floating Panes', () => {
    let floatingPanes;
    beforeEach(() => {
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [
            {
              type: IgcDockManagerPaneType.contentPane,
              contentId: '3',
              header: 'Header'
            }
          ]
        },
        floatingPanes: [
          {
            type: IgcDockManagerPaneType.splitPane,
            orientation: IgcSplitPaneOrientation.vertical,
            panes: [
              {
                type: IgcDockManagerPaneType.contentPane,
                contentId: '1',
                header: 'Header'
              }
            ]
          },
          {
            type: IgcDockManagerPaneType.splitPane,
            orientation: IgcSplitPaneOrientation.vertical,
            floatingLocation: { x: 100, y: 200 },
            floatingWidth: 150,
            floatingHeight: 250,
            panes: [
              {
                type: IgcDockManagerPaneType.contentPane,
                contentId: '2',
                header: 'Header'
              }
            ]
          }
        ]
      };
      floatingPanes = dockManager.layout.floatingPanes;
    });
    it('move floating pane', () => {
      service.moveFloatingPane(floatingPanes[0], { x: 100, y: 150 });
      expect(floatingPanes[0].floatingLocation).toEqual({ x: 100, y: 150 });
      service.moveFloatingPane(floatingPanes[1], { x: 120, y: 170 });
      expect(floatingPanes[1].floatingLocation).toEqual({ x: 120, y: 170 });
    });
    it('resize floating pane with no initial location and size', () => {
      const pane = floatingPanes[0];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottomRight);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 20,
          offsetY: 30,
          totalOffsetX: 20,
          totalOffsetY: 30,
          clientX: 120,
          clientY: 130
        },
        resizerLocation: IgcResizerLocation.bottomRight
      });
      verifyFloatingPaneSize(pane, 0, 0, 120, 130);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.topLeft);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 10,
          offsetY: 15,
          totalOffsetX: 10,
          totalOffsetY: 15,
          clientX: 10,
          clientY: 15
        },
        resizerLocation: IgcResizerLocation.topLeft
      });
      verifyFloatingPaneSize(floatingPanes[0], 10, 15, 110, 115);
    });
    it('resize floating pane with top resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.top);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 30,
          offsetY: -20,
          totalOffsetX: 30,
          totalOffsetY: -20,
          clientX: 130,
          clientY: 180
        },
        resizerLocation: IgcResizerLocation.top
      });
      verifyFloatingPaneSize(pane, 100, 180, 150, 270);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.top);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 30,
          offsetY: 200,
          totalOffsetX: 30,
          totalOffsetY: 200,
          clientX: 130,
          clientY: 380
        },
        resizerLocation: IgcResizerLocation.top
      });
      verifyFloatingPaneSize(pane, 100, 350, 150, 100);
    });
    it('resize floating pane with bottom resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottom);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 30,
          offsetY: 20,
          totalOffsetX: 30,
          totalOffsetY: 20,
          clientX: 130,
          clientY: 470
        },
        resizerLocation: IgcResizerLocation.bottom
      });
      verifyFloatingPaneSize(pane, 100, 200, 150, 270);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottom);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 30,
          offsetY: -200,
          totalOffsetX: 20,
          totalOffsetY: -200,
          clientX: 130,
          clientY: 270
        },
        resizerLocation: IgcResizerLocation.bottom
      });
      verifyFloatingPaneSize(pane, 100, 200, 150, 100);
    });
    it('resize floating pane with left resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.left);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -20,
          offsetY: 30,
          totalOffsetX: -20,
          totalOffsetY: 30,
          clientX: 80,
          clientY: 230
        },
        resizerLocation: IgcResizerLocation.left
      });
      verifyFloatingPaneSize(pane, 80, 200, 170, 250);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.left);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 200,
          offsetY: 30,
          totalOffsetX: 200,
          totalOffsetY: 30,
          clientX: 280,
          clientY: 230
        },
        resizerLocation: IgcResizerLocation.left
      });
      verifyFloatingPaneSize(pane, 150, 200, 100, 250);
    });
    it('resize floating pane with right resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.right);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 20,
          offsetY: 30,
          totalOffsetX: 20,
          totalOffsetY: 30,
          clientX: 270,
          clientY: 230
        },
        resizerLocation: IgcResizerLocation.right
      });
      verifyFloatingPaneSize(pane, 100, 200, 170, 250);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.right);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -100,
          offsetY: 30,
          totalOffsetX: -100,
          totalOffsetY: 30,
          clientX: 170,
          clientY: 230
        },
        resizerLocation: IgcResizerLocation.right
      });
      verifyFloatingPaneSize(pane, 100, 200, 100, 250);
    });
    it('resize floating pane with topLeft resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.topLeft);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -30,
          offsetY: -20,
          totalOffsetX: -30,
          totalOffsetY: -20,
          clientX: 70,
          clientY: 180
        },
        resizerLocation: IgcResizerLocation.topLeft
      });
      verifyFloatingPaneSize(pane, 70, 180, 180, 270);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.topLeft);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 200,
          offsetY: 200,
          totalOffsetX: 200,
          totalOffsetY: 200,
          clientX: 270,
          clientY: 380
        },
        resizerLocation: IgcResizerLocation.topLeft
      });
      verifyFloatingPaneSize(pane, 150, 350, 100, 100);
    });
    it('resize floating pane with topRight resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.topRight);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 30,
          offsetY: -20,
          totalOffsetX: 30,
          totalOffsetY: -20,
          clientX: 280,
          clientY: 180
        },
        resizerLocation: IgcResizerLocation.topRight
      });
      verifyFloatingPaneSize(pane, 100, 180, 180, 270);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.topRight);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -200,
          offsetY: 200,
          totalOffsetX: -200,
          totalOffsetY: 200,
          clientX: 80,
          clientY: 550
        },
        resizerLocation: IgcResizerLocation.topRight
      });
      verifyFloatingPaneSize(pane, 100, 350, 100, 100);
    });
    it('resize floating pane with bottomRight resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottomRight);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 30,
          offsetY: 20,
          totalOffsetX: 30,
          totalOffsetY: 20,
          clientX: 280,
          clientY: 470
        },
        resizerLocation: IgcResizerLocation.bottomRight
      });
      verifyFloatingPaneSize(pane, 100, 200, 180, 270);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottomRight);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -200,
          offsetY: -200,
          totalOffsetX: -200,
          totalOffsetY: -200,
          clientX: 80,
          clientY: 270
        },
        resizerLocation: IgcResizerLocation.bottomRight
      });
      verifyFloatingPaneSize(pane, 100, 200, 100, 100);
    });
    it('resize floating pane with bottomLeft resizer', () => {
      const pane = floatingPanes[1];
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottomLeft);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -30,
          offsetY: 20,
          totalOffsetX: -30,
          totalOffsetY: 20,
          clientX: 70,
          clientY: 470
        },
        resizerLocation: IgcResizerLocation.bottomLeft
      });
      verifyFloatingPaneSize(pane, 70, 200, 180, 270);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottomLeft);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 200,
          offsetY: -200,
          totalOffsetX: 200,
          totalOffsetY: -200,
          clientX: 270,
          clientY: 270
        },
        resizerLocation: IgcResizerLocation.bottomLeft
      });
      verifyFloatingPaneSize(pane, 150, 200, 100, 100);
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottomLeft);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -20,
          offsetY: 10,
          totalOffsetX: -20,
          totalOffsetY: 10,
          clientX: 250,
          clientY: 280
        },
        resizerLocation: IgcResizerLocation.bottomLeft
      });
      verifyFloatingPaneSize(pane, 130, 200, 120, 110);
    });
    it('validate events during floating pane resizing', () => {
      const resizeStartSpy = jest.spyOn(dockManager.floatingPaneResizeStart, 'emit');
      const resizingSpy = jest.spyOn(dockManager.floatingPaneResizeMove, 'emit');
      const resizeEndSpy = jest.spyOn(dockManager.floatingPaneResizeEnd, 'emit');
      const pane = floatingPanes[1];
      const paneLocation = pane.floatingLocation;
      const width = pane.floatingWidth;
      const height = pane.floatingHeight;
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.topLeft);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: -30,
          offsetY: -20,
          totalOffsetX: -30,
          totalOffsetY: -20,
          clientX: 70,
          clientY: 180
        },
        resizerLocation: IgcResizerLocation.topLeft
      });
      service.resizeFloatingPaneEnd(pane, IgcResizerLocation.topLeft);
      expect(resizeStartSpy).toHaveBeenCalledTimes(1);
      expect(resizingSpy).toHaveBeenCalledWith({
        sourcePane: pane,
        oldWidth: width,
        newWidth: width + 30,
        oldHeight: height,
        newHeight: height + 20,
        oldLocation: { x: paneLocation.x, y: paneLocation.y },
        newLocation: { x: paneLocation.x - 30, y: paneLocation.y - 20 },
        resizerLocation: IgcResizerLocation.topLeft
      });
      expect(resizeEndSpy).toHaveBeenCalledTimes(1);
      verifyFloatingPaneSize(pane, paneLocation.x - 30, paneLocation.y - 20, width + 30, height + 20);
    });
    it('cancel floating pane resizing event with e.preventDefault()', () => {
      const resizingSpy = jest.spyOn(dockManager.floatingPaneResizeMove, 'emit');
      dockManager.floatingPaneResizeMove.addEventListener(e => e.preventDefault());
      const pane = floatingPanes[1];
      const paneLocation = pane.floatingLocation;
      const width = pane.floatingWidth;
      const height = pane.floatingHeight;
      service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottomRight);
      service.resizeFloatingPane(pane, {
        dragMoveArgs: {
          offsetX: 30,
          offsetY: 20,
          totalOffsetX: 30,
          totalOffsetY: 20,
          clientX: 280,
          clientY: 470
        },
        resizerLocation: IgcResizerLocation.bottomRight
      });
      expect(resizingSpy).toHaveBeenCalledWith({
        sourcePane: pane,
        oldWidth: width,
        newWidth: width + 30,
        oldHeight: height,
        newHeight: height + 20,
        oldLocation: { x: paneLocation.x, y: paneLocation.y },
        newLocation: { x: paneLocation.x, y: paneLocation.y },
        resizerLocation: IgcResizerLocation.bottomRight
      });
      verifyFloatingPaneSize(pane, paneLocation.x, paneLocation.y, width, height);
    });
    it('cancel floating pane resizeStart event', () => {
      const resizeStartSpy = jest.spyOn(dockManager.floatingPaneResizeStart, 'emit');
      dockManager.floatingPaneResizeStart.addEventListener(e => e.preventDefault());
      const pane = floatingPanes[1];
      const resizeStarted = service.resizeFloatingPaneStart(pane, IgcResizerLocation.bottom);
      expect(resizeStarted).toBe(false);
      expect(resizeStartSpy).toHaveBeenCalledWith({
        sourcePane: pane,
        resizerLocation: IgcResizerLocation.bottom
      });
    });
    it('floating panes zIndices', () => {
      let expectedIndices = new Map([
        [floatingPanes[0], 0],
        [floatingPanes[1], 1]
      ]);
      expect(dockManager.floatingPaneZIndicesMap).toEqual(expectedIndices);
      service.floatPane(dockManager.layout.rootPane.panes[0], 0, 0, 100, 100);
      expectedIndices = new Map([
        [floatingPanes[0], 0],
        [floatingPanes[1], 1],
        [floatingPanes[2], 2]
      ]);
      expect(dockManager.floatingPaneZIndicesMap).toEqual(expectedIndices);
      service.bringFloatingPaneOnTop(floatingPanes[1]);
      expectedIndices = new Map([
        [floatingPanes[0], 0],
        [floatingPanes[1], 2],
        [floatingPanes[2], 1]
      ]);
      expect(dockManager.floatingPaneZIndicesMap).toEqual(expectedIndices);
      service.bringFloatingPaneOnTop(floatingPanes[0]);
      expectedIndices = new Map([
        [floatingPanes[0], 2],
        [floatingPanes[1], 1],
        [floatingPanes[2], 0]
      ]);
      expect(dockManager.floatingPaneZIndicesMap).toEqual(expectedIndices);
    });
  });
  describe('Drag panes to float', () => {
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    let pane5;
    let rootPane;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header'
      };
      rootPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          {
            type: IgcDockManagerPaneType.tabGroupPane,
            panes: [pane1, pane2]
          },
          {
            type: IgcDockManagerPaneType.documentHost,
            rootPane: {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.horizontal,
              panes: [
                {
                  type: IgcDockManagerPaneType.tabGroupPane,
                  panes: [pane3, pane4]
                }
              ]
            }
          },
          pane5
        ]
      };
      dockManager.layout = {
        rootPane
      };
    });
    it('float single content pane', () => {
      service.floatPane(pane5, 100, 200, 150, 250);
      expect(rootPane.panes.length).toBe(2);
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      const floatingPane = dockManager.layout.floatingPanes[0];
      expect(floatingPane.panes).toEqual([pane5]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 150, 250);
      expect(service.forceDragPane).toBe(floatingPane);
    });
    it('float flyout content pane', () => {
      service.togglePin(pane5);
      service.flyoutPane(pane5);
      service.floatPane(pane5, 100, 200, 150, 250);
      expect(pane5.isPinned).toBe(true);
      expect(dockManager.flyoutPane).toBeNull();
      expect(rootPane.panes.length).toBe(2);
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      const floatingPane = dockManager.layout.floatingPanes[0];
      expect(floatingPane.panes).toEqual([pane5]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 150, 250);
      expect(service.forceDragPane).toBe(floatingPane);
    });
    it('float tab group content pane', () => {
      service.floatPane(pane1, 100, 200, 150, 250);
      expect(rootPane.panes.length).toBe(2);
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      const floatingPane = dockManager.layout.floatingPanes[0];
      expect(floatingPane.panes.length).toBe(1);
      expect(floatingPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(floatingPane.panes[0].panes).toEqual([pane1, pane2]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 150, 250);
      expect(service.forceDragPane).toBe(floatingPane);
    });
    it('float tab group tab header', () => {
      service.floatTab(pane1, 100, 200, 150, 250);
      expect(rootPane.panes.length).toBe(3);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(rootPane.panes[0].panes).toEqual([pane2]);
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      const floatingPane = dockManager.layout.floatingPanes[0];
      expect(floatingPane.panes).toEqual([pane1]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 150, 250);
      expect(service.forceDragPane).toBe(floatingPane);
    });
    it('float tab in document host', () => {
      service.floatTab(pane3, 100, 200, 150, 250);
      expect(rootPane.panes.length).toBe(3);
      expect(rootPane.panes[1].type).toBe(IgcDockManagerPaneType.documentHost);
      const docHost = rootPane.panes[1];
      expect(docHost.rootPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(docHost.rootPane.panes[0].panes).toEqual([pane4]);
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      const floatingPane = dockManager.layout.floatingPanes[0];
      expect(floatingPane.panes[0]).toEqual(pane3);
      verifyFloatingPaneSize(floatingPane, 100, 200, 150, 250);
      expect(service.forceDragPane).toBe(floatingPane);
    });
    it('float tab in document host when pane is document-only', () => {
      pane3.documentOnly = true;
      service.floatTab(pane3, 100, 200, 150, 250);
      expect(rootPane.panes.length).toBe(3);
      expect(rootPane.panes[1].type).toBe(IgcDockManagerPaneType.documentHost);
      const docHost = rootPane.panes[1];
      expect(docHost.rootPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(docHost.rootPane.panes[0].panes).toEqual([pane4]);
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      const floatingPane = dockManager.layout.floatingPanes[0];
      expect(floatingPane.panes[0].type).toBe(IgcDockManagerPaneType.documentHost);
      const floatingDocHost = floatingPane.panes[0];
      expect(floatingDocHost.rootPane.panes).toEqual([pane3]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 150, 250);
      expect(service.forceDragPane).toBe(floatingPane);
    });
    it('float document host when there is unpinned pane', () => {
      service.togglePin(pane5);
      service.floatTab(pane3, 100, 200, 150, 250);
      expect(dockManager.layout.rootPane.panes.length).toBe(3);
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      service.floatTab(pane4, 100, 200, 150, 250);
      expect(dockManager.layout.rootPane.panes.length).toBe(2);
      expect(dockManager.layout.floatingPanes.length).toBe(2);
    });
  });
  describe('Root Docking', () => {
    let rootPane;
    let floatingPane;
    let pane1;
    let pane2;
    let pane3;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      floatingPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.vertical,
        panes: [pane3]
      };
      rootPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [pane1, pane2]
      };
      dockManager.layout = {
        rootPane,
        floatingPanes: [floatingPane]
      };
      dockManager.draggedPane = floatingPane;
    });
    it('root dock top', () => {
      service.rootDockPane(IgcDockingIndicatorPosition.top);
      expect(dockManager.layout.rootPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(dockManager.layout.rootPane.panes).toEqual([pane3, rootPane]);
    });
    it('root dock bottom', () => {
      service.rootDockPane(IgcDockingIndicatorPosition.bottom);
      expect(dockManager.layout.rootPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(dockManager.layout.rootPane.panes).toEqual([rootPane, pane3]);
    });
    it('root dock left', () => {
      service.dockingIndicator = {
        position: IgcDockingIndicatorPosition.left,
        isRoot: true,
        direction: Utils.getDirection(dockManager)
      };
      service.rootDockPane(IgcDockingIndicatorPosition.left);
      expect(dockManager.layout.rootPane).toBe(rootPane);
      expect(dockManager.layout.rootPane.panes).toEqual([pane3, pane1, pane2]);
    });
    it('root dock left RTL', () => {
      dockManager.dir = 'rtl';
      service.dockingIndicator = {
        position: IgcDockingIndicatorPosition.left,
        isRoot: true,
        direction: Utils.getDirection(dockManager)
      };
      service.rootDockPane(IgcDockingIndicatorPosition.left);
      expect(dockManager.layout.rootPane).toBe(rootPane);
      expect(dockManager.layout.rootPane.panes).toEqual([pane1, pane2, pane3]);
    });
    it('root dock right', () => {
      service.dockingIndicator = {
        position: IgcDockingIndicatorPosition.right,
        isRoot: true,
        direction: Utils.getDirection(dockManager)
      };
      service.rootDockPane(IgcDockingIndicatorPosition.right);
      expect(dockManager.layout.rootPane).toBe(rootPane);
      expect(dockManager.layout.rootPane.panes).toEqual([pane1, pane2, pane3]);
    });
    it('root dock right RTL', () => {
      dockManager.dir = 'rtl';
      service.dockingIndicator = {
        position: IgcDockingIndicatorPosition.right,
        isRoot: true,
        direction: Utils.getDirection(dockManager)
      };
      service.rootDockPane(IgcDockingIndicatorPosition.right);
      expect(dockManager.layout.rootPane).toBe(rootPane);
      expect(dockManager.layout.rootPane.panes).toEqual([pane3, pane1, pane2]);
    });
    it('root dock when there is active pane', () => {
      service.dockManager.draggedPane = null;
      service.dockManager.activePane = pane1;
      service.rootDockPane(IgcDockingIndicatorPosition.top);
      expect(dockManager.layout.rootPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(dockManager.layout.rootPane.panes).toEqual([pane1, rootPane]);
      const splitPane = dockManager.layout.rootPane.panes[1];
      expect(splitPane.panes).toEqual([pane2]);
    });
  });
  describe('Docking', () => {
    let rootPane;
    let floatingPane;
    let tabGroup;
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      floatingPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.vertical,
        panes: [pane4]
      };
      tabGroup = {
        type: IgcDockManagerPaneType.tabGroupPane,
        panes: [pane2, pane3]
      };
      rootPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          pane1,
          tabGroup
        ]
      };
      dockManager.layout = {
        rootPane,
        floatingPanes: [floatingPane]
      };
      dockManager.draggedPane = floatingPane;
    });
    it('dock to center', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.center);
      const newTabGroup = rootPane.panes[0];
      expect(newTabGroup.type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(newTabGroup.panes).toEqual([pane1, pane4]);
    });
    it('dock to center in tab group', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: tabGroup,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.center);
      expect(tabGroup.panes).toEqual([pane2, pane3, pane4]);
    });
    it('dock to left', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.left);
      expect(rootPane.panes).toEqual([pane4, pane1, tabGroup]);
    });
    it('dock to left RTL', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockingIndicator = {
        position: IgcDockingIndicatorPosition.left,
        isRoot: false,
        direction: 'rtl'
      };
      service.dockPane(IgcDockingIndicatorPosition.left);
      expect(rootPane.panes).toEqual([pane1, pane4, tabGroup]);
    });
    it('dock to right', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.right);
      expect(rootPane.panes).toEqual([pane1, pane4, tabGroup]);
    });
    it('dock to right RTL', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockingIndicator = {
        position: IgcDockingIndicatorPosition.right,
        isRoot: false,
        direction: 'rtl'
      };
      service.dockPane(IgcDockingIndicatorPosition.right);
      expect(rootPane.panes).toEqual([pane4, pane1, tabGroup]);
    });
    it('dock to top', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.top);
      const splitPane = rootPane.panes[0];
      expect(splitPane.type).toBe(IgcDockManagerPaneType.splitPane);
      expect(splitPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(splitPane.panes).toEqual([pane4, pane1]);
      expect(rootPane.panes).toEqual([splitPane, tabGroup]);
    });
    it('dock to bottom', () => {
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.bottom);
      const splitPane = rootPane.panes[0];
      expect(splitPane.type).toBe(IgcDockManagerPaneType.splitPane);
      expect(splitPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(splitPane.panes).toEqual([pane1, pane4]);
      expect(rootPane.panes).toEqual([splitPane, tabGroup]);
    });
    it('dock when there is active pane', () => {
      service.dockManager.draggedPane = null;
      service.dockManager.activePane = pane3;
      service.dockPane(IgcDockingIndicatorPosition.top);
      const splitPane = rootPane.panes[1];
      expect(splitPane.type).toBe(IgcDockManagerPaneType.splitPane);
      expect(splitPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(splitPane.panes).toEqual([pane3, tabGroup]);
      expect(tabGroup.panes).toEqual([pane2]);
    });
    it('dock pane emit layoutChange event', () => {
      const eventSpy = jest.spyOn(dockManager.layoutChange, 'emit');
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.top);
      const splitPane = rootPane.panes[0];
      expect(splitPane.panes).toEqual([pane4, pane1]);
      expect(eventSpy).toHaveBeenCalled();
    });
  });
  describe('Docking In Doc Host', () => {
    let rootPane;
    let floatingPane;
    let docHost;
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      floatingPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.vertical,
        panes: [pane4]
      };
      docHost = {
        type: IgcDockManagerPaneType.documentHost,
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.vertical,
          panes: [pane2]
        }
      };
      rootPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          pane1,
          docHost,
          pane3
        ]
      };
      dockManager.layout = {
        rootPane,
        floatingPanes: [floatingPane]
      };
      dockManager.draggedPane = floatingPane;
    });
    it('dock to outer left', () => {
      dockManager.dropTargetPaneInfo = {
        docHost,
        pane: pane2,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.outerLeft);
      expect(rootPane.panes).toEqual([pane1, pane4, docHost, pane3]);
    });
    it('dock to outer right', () => {
      dockManager.dropTargetPaneInfo = {
        docHost,
        pane: pane2,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.outerRight);
      expect(rootPane.panes).toEqual([pane1, docHost, pane4, pane3]);
    });
    it('dock to outer top', () => {
      dockManager.dropTargetPaneInfo = {
        docHost,
        pane: pane2,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.outerTop);
      const splitPane = rootPane.panes[1];
      expect(splitPane.type).toBe(IgcDockManagerPaneType.splitPane);
      expect(splitPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(splitPane.panes).toEqual([pane4, docHost]);
      expect(rootPane.panes).toEqual([pane1, splitPane, pane3]);
    });
    it('dock to outer bottom', () => {
      dockManager.dropTargetPaneInfo = {
        docHost,
        pane: pane2,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.outerBottom);
      const splitPane = rootPane.panes[1];
      expect(splitPane.type).toBe(IgcDockManagerPaneType.splitPane);
      expect(splitPane.orientation).toBe(IgcSplitPaneOrientation.vertical);
      expect(splitPane.panes).toEqual([docHost, pane4]);
      expect(rootPane.panes).toEqual([pane1, splitPane, pane3]);
    });
    it('dock floating pane with document host', () => {
      const pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header',
        documentOnly: true
      };
      const floatingDocHost = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          {
            type: IgcDockManagerPaneType.documentHost,
            rootPane: {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.horizontal,
              panes: [
                pane5
              ]
            }
          }
        ]
      };
      dockManager.layout.floatingPanes.push(floatingDocHost);
      dockManager.layout = Object.assign({}, dockManager.layout);
      dockManager.draggedPane = floatingDocHost;
      dockManager.documentOnlyDrag = true;
      dockManager.dropTargetPaneInfo = {
        docHost,
        pane: pane2,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.top);
      expect(docHost.rootPane.panes).toEqual([pane5, pane2]);
    });
    it('dock floating pane with document host inside empty doc host', () => {
      docHost.rootPane.allowEmpty = true;
      service.closePane(pane2);
      expect(docHost.rootPane.panes.length).toBe(0);
      expect(rootPane.panes[1]).toBe(docHost);
      const pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header',
        documentOnly: true
      };
      const floatingDocHost = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          {
            type: IgcDockManagerPaneType.documentHost,
            rootPane: {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.horizontal,
              panes: [
                pane5
              ]
            }
          }
        ]
      };
      dockManager.layout.floatingPanes.push(floatingDocHost);
      dockManager.layout = Object.assign({}, dockManager.layout);
      dockManager.draggedPane = floatingDocHost;
      dockManager.documentOnlyDrag = true;
      dockManager.dropTargetPaneInfo = {
        docHost,
        pane: docHost,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.center);
      expect(docHost.rootPane.panes).toEqual([pane5]);
    });
    it('dock floating pane with document host and another pane inside empty doc host', () => {
      docHost.rootPane.allowEmpty = true;
      service.closePane(pane2);
      expect(docHost.rootPane.panes.length).toBe(0);
      expect(rootPane.panes[1]).toBe(docHost);
      const pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header',
        documentOnly: true
      };
      const pane6 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '6',
        header: 'Header',
      };
      const floatingDocHost = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          {
            type: IgcDockManagerPaneType.documentHost,
            rootPane: {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.horizontal,
              panes: [
                pane5
              ]
            }
          },
          pane6
        ]
      };
      dockManager.layout.floatingPanes.push(floatingDocHost);
      dockManager.layout = Object.assign({}, dockManager.layout);
      dockManager.draggedPane = floatingDocHost;
      dockManager.documentOnlyDrag = true;
      dockManager.dropTargetPaneInfo = {
        docHost,
        pane: docHost,
        targetRect: null
      };
      service.dockPane(IgcDockingIndicatorPosition.center);
      expect(docHost.rootPane.panes.length).toEqual(1);
      expect(docHost.rootPane.panes[0].type).toEqual(IgcDockManagerPaneType.splitPane);
      expect(docHost.rootPane.panes[0].panes).toEqual([pane5, pane6]);
    });
    it('dock document-only pane inside floating pane without document host', () => {
      pane2.documentOnly = true;
      dockManager.draggedPane = pane2;
      dockManager.documentOnlyDrag = true;
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane4,
        targetRect: null,
        floatingPaneWithoutDocHost: true
      };
      service.dockPane(IgcDockingIndicatorPosition.bottom);
      expect(floatingPane.panes.length).toEqual(2);
      expect(floatingPane.panes[0]).toEqual(pane4);
      expect(floatingPane.panes[1].type).toEqual(IgcDockManagerPaneType.documentHost);
      const documentHost = floatingPane.panes[1];
      expect(documentHost.rootPane.panes).toEqual([pane2]);
    });
  });
  describe('Maximizing/Minimizing', () => {
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    let pane5;
    let pane6;
    let pane7;
    let pane8;
    let pane9;
    let rootPane;
    let floatingPanes;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header'
      };
      pane6 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '6',
        header: 'Header',
      };
      pane7 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '7',
        header: 'Header'
      };
      pane8 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '8',
        header: 'Header'
      };
      pane9 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '9',
        header: 'Header'
      };
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [
            {
              type: IgcDockManagerPaneType.tabGroupPane,
              panes: [pane1, pane2]
            },
            pane3,
            {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.vertical,
              panes: [pane4, pane5]
            },
            {
              type: IgcDockManagerPaneType.documentHost,
              size: 300,
              rootPane: {
                type: IgcDockManagerPaneType.splitPane,
                orientation: IgcSplitPaneOrientation.horizontal,
                panes: [pane6, pane7],
              },
            },
          ]
        },
        floatingPanes: [
          {
            type: IgcDockManagerPaneType.splitPane,
            orientation: IgcSplitPaneOrientation.horizontal,
            panes: [pane8]
          },
          {
            type: IgcDockManagerPaneType.splitPane,
            orientation: IgcSplitPaneOrientation.vertical,
            floatingLocation: { x: 10, y: 20 },
            panes: [
              {
                type: IgcDockManagerPaneType.documentHost,
                rootPane: {
                  type: IgcDockManagerPaneType.splitPane,
                  orientation: IgcSplitPaneOrientation.vertical,
                  panes: [pane9]
                }
              }
            ]
          }
        ]
      };
      rootPane = dockManager.layout.rootPane;
      floatingPanes = dockManager.layout.floatingPanes;
    });
    it('maximizing tab group pane', () => {
      service.maximizePane(pane1);
      expect(dockManager.maximizedPane).toEqual(rootPane.panes[0]);
    });
    it('maximizing content pane', () => {
      service.maximizePane(rootPane.panes[1]);
      expect(dockManager.maximizedPane).toEqual(rootPane.panes[1]);
    });
    it('maximizing content pane in a split pane', () => {
      service.maximizePane(pane4);
      expect(dockManager.maximizedPane).toEqual(pane4);
    });
    it('maximizing floating pane', () => {
      service.maximizePane(floatingPanes[0]);
      expect(dockManager.maximizedPane).toEqual(floatingPanes[0]);
    });
    it('minimizing pane', () => {
      service.maximizePane(pane1);
      service.maximizePane(pane1);
      expect(dockManager.maximizedPane).toEqual(null);
    });
    it('unpin a maximized pane', () => {
      service.maximizePane(pane3);
      expect(dockManager.maximizedPane).toEqual(pane3);
      service.togglePin(pane3);
      expect(pane3.isPinned).toBe(false);
      expect(dockManager.maximizedPane).toEqual(null);
      expect(dockManager.flyoutPane).toEqual(pane3);
    });
    it('pin a maximized pane', () => {
      service.togglePin(pane3);
      service.flyoutPane(pane3);
      service.maximizePane(pane3);
      service.togglePin(pane3);
      expect(dockManager.maximizedPane).toEqual(null);
      expect(dockManager.flyoutPane).toEqual(null);
    });
    it('ALT + F6 focuses next pane and normalize maximized pane to original state', () => {
      service.maximizePane(pane4);
      dockManager.activePane = pane4;
      keyboardEventCall({ key: 'Alt' }, { key: 'F6', altKey: true });
      expect(dockManager.activePane).toBe(pane5);
      expect(dockManager.maximizedPane).toEqual(null);
    });
    it('ALT + SHIFT + F6 focuses previous pane and normalize maximized pane to original state', () => {
      service.maximizePane(pane4);
      dockManager.activePane = pane4;
      keyboardEventCall({ key: 'Alt' }, { key: 'F6', shiftKey: true, altKey: true });
      expect(dockManager.activePane).toBe(pane3);
      expect(dockManager.maximizedPane).toEqual(null);
    });
    it('CMD/CTRL + F6 focuses next document and normalize maximized pane to original state', () => {
      service.maximizePane(rootPane.panes[3]);
      dockManager.activePane = pane6;
      keyboardEventCall({ key: 'Control' }, { key: 'F6', ctrlKey: true });
      expect(dockManager.activePane).toBe(pane7);
      expect(dockManager.maximizedPane).toEqual(null);
    });
    it('CMD/CTRL + SHIFT + F6 focuses previous document and normalize maximized pane to original state', () => {
      service.maximizePane(rootPane.panes[3]);
      dockManager.activePane = pane7;
      keyboardEventCall({ key: 'Control' }, { key: 'F6', shiftKey: true, ctrlKey: true });
      expect(dockManager.activePane).toBe(pane6);
      expect(dockManager.maximizedPane).toEqual(null);
    });
    it('maximizing floating pane, CMD/CTRL + ArrowLeft activate pane in maximized window, then second press CMD/CTRL + ArrowLeft navigating away', () => {
      service.maximizePane(floatingPanes[1]);
      keyboardEventCall({ key: 'Control' }, { key: 'ArrowLeft', ctrlKey: true });
      expect(dockManager.activePane).toBe(pane9);
      expect(dockManager.maximizedPane).toEqual(floatingPanes[1]);
      keyboardEventCall({ key: 'Control' }, { key: 'ArrowLeft', ctrlKey: true });
      expect(dockManager.activePane).toBe(pane7);
      expect(dockManager.maximizedPane).toEqual(null);
    });
    it('content pane allowMaximize should take precedence over dock manager allowMaximize', () => {
      pane3.allowMaximize = false;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[1]);
      expect(allowMaximize).toEqual(false);
    });
    it('content pane allowMaximize is set to true and dock manager allowMaximize is set to false, content pane should be allowed to be maximized', () => {
      dockManager.allowMaximize = false;
      pane3.allowMaximize = true;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[1]);
      expect(allowMaximize).toEqual(true);
    });
    it('set allowMaximize to be false for a pane inside a tab group, should not allow to all of the panes in the tab group to be maximized', () => {
      pane1.allowMaximize = false;
      const tabGroup = rootPane.panes[0];
      const allowMaximize = service.resolveAllowMaximize(tabGroup);
      expect(allowMaximize).toEqual(false);
    });
    it('set allowMaximize to be false for a pane inside a split pane, should not allow to all of the panes in the split pane to be maximized', () => {
      pane4.allowMaximize = false;
      const splitPane = rootPane.panes[2];
      const allowMaximize = service.resolveAllowMaximize(splitPane);
      expect(allowMaximize).toEqual(false);
    });
    it('unpin pane with allowMaximize set to false from a tab group', () => {
      pane1.allowMaximize = false;
      pane1.isPinned = false;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[0]);
      expect(pane1.allowMaximize).toEqual(false);
      expect(pane2.allowMaximize).toBeUndefined();
      expect(allowMaximize).toEqual(true);
    });
    it('unpin pane from tab group which is allowed to be maximized, the pinned pane allowMaximize is false', () => {
      pane1.allowMaximize = false;
      pane2.isPinned = false;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[0]);
      expect(pane1.allowMaximize).toEqual(false);
      expect(pane2.allowMaximize).toBeUndefined();
      expect(allowMaximize).toEqual(false);
    });
    it('unpin pane with allowMaximize set to false from split pane', () => {
      pane4.allowMaximize = false;
      pane4.isPinned = false;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[2]);
      expect(pane4.allowMaximize).toEqual(false);
      expect(pane5.allowMaximize).toBeUndefined();
      expect(allowMaximize).toEqual(true);
    });
    it('unpin pane from split pane which is allowed to be maximized, the pinned pane allowMaximize is false', () => {
      pane5.allowMaximize = false;
      pane4.isPinned = false;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[2]);
      expect(pane5.allowMaximize).toEqual(false);
      expect(pane4.allowMaximize).toBeUndefined();
      expect(allowMaximize).toEqual(false);
    });
    it('hide pane with allowMaximize set to false from a tab group', () => {
      pane1.allowMaximize = false;
      pane1.hidden = true;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[0]);
      expect(pane2.allowMaximize).toBeUndefined();
      expect(allowMaximize).toEqual(true);
    });
    it('hide pane from tab group which is allowed to be maximized, the visible pane should not allowed to be maximized', () => {
      pane1.allowMaximize = false;
      pane2.hidden = true;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[0]);
      expect(pane1.allowMaximize).toEqual(false);
      expect(allowMaximize).toEqual(false);
    });
    it('hide pane with allowMaximize set to false from a split pane', () => {
      pane4.allowMaximize = false;
      pane4.hidden = true;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[2]);
      expect(pane5.allowMaximize).toBeUndefined();
      expect(allowMaximize).toEqual(true);
    });
    it('hide pane from split pane which is allowed to be maximized, the visible pane should not allowed to be maximized', () => {
      pane5.allowMaximize = false;
      pane4.hidden = true;
      const allowMaximize = service.resolveAllowMaximize(rootPane.panes[2]);
      expect(pane5.allowMaximize).toEqual(false);
      expect(allowMaximize).toEqual(false);
    });
    it('maximize pane that was maximized when layout was saved', () => {
      let targetPane = rootPane.panes[1];
      service.maximizePane(targetPane);
      expect(targetPane.isMaximized).toBe(true);
      const savedLayout = JSON.stringify(dockManager.layout);
      service.maximizePane(targetPane);
      expect(targetPane.isMaximized).toBe(false);
      const exp = JSON.parse(savedLayout);
      dockManager.layout = Object.assign({}, exp);
      targetPane = dockManager.layout.rootPane.panes[1];
      expect(targetPane.isMaximized).toBe(true);
    });
  });
  describe('Drop Shadow', () => {
    let parentRect;
    let floatingPane;
    let rootPane;
    let docHost;
    let pane1;
    let pane2;
    let pane3;
    beforeEach(() => {
      parentRect = new DOMRect(100, 100, 600, 600);
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      floatingPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [pane3]
      };
      rootPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: null,
        panes: null
      };
      dockManager.draggedPane = floatingPane;
      dockManager.dropTargetPaneInfo = {
        docHost: null,
        pane: pane1,
        targetRect: null
      };
      service.dropTargetParentRect = parentRect;
    });
    describe('Inner', () => {
      let leftHalfRect;
      let rightHalfRect;
      let topHalfRect;
      let bottomHalfRect;
      beforeEach(() => {
        leftHalfRect = new DOMRect(100, 100, 300, 600);
        rightHalfRect = new DOMRect(400, 100, 300, 600);
        topHalfRect = new DOMRect(100, 100, 600, 300);
        bottomHalfRect = new DOMRect(100, 400, 600, 300);
        rootPane.panes = [pane1, pane2];
        dockManager.layout = {
          rootPane,
          floatingPanes: [floatingPane]
        };
      });
      it('show drop shadow on center', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.center, isRoot: false };
        // Vertical root split pane - drop on top pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = topHalfRect;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 600, 300));
        // Horizontal root split pane - drop on right pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = rightHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(400, 100, 300, 600));
      });
      it('show drop shadow on left', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.left, isRoot: false };
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        // Horizontal root split pane - drop on left pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = leftHalfRect;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 200, 600));
        // Horizontal root split pane - drop on right pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = rightHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(300, 100, 200, 600));
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        // Vertical root split pane - drop on top pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = topHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 300, 300));
        // Vertical root split pane - drop on bottom pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = bottomHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 400, 300, 300));
      });
      it('show drop shadow on right', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.right, isRoot: false };
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        // Horizontal root split pane - drop on left pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = leftHalfRect;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(300, 100, 200, 600));
        // Horizontal root split pane - drop on right pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = rightHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(500, 100, 200, 600));
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        // Vertical root split pane - drop on top pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = topHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(400, 100, 300, 300));
        // Vertical root split pane - drop on bottom pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = bottomHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(400, 400, 300, 300));
      });
      it('show drop shadow on top', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.top, isRoot: false };
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        // Vertical root split pane - drop on top pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = topHalfRect;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 600, 200));
        // Vertical root split pane - drop on bottom pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = bottomHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 300, 600, 200));
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        // Horizontal root split pane - drop on left pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = leftHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 300, 300));
        // Horizontal root split pane - drop on right pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = rightHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(400, 100, 300, 300));
      });
      it('show drop shadow on bottom', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.bottom, isRoot: false };
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        // Vertical root split pane - drop on top pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = topHalfRect;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 300, 600, 200));
        // Vertical root split pane - drop on bottom pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = bottomHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 500, 600, 200));
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        // Horizontal root split pane - drop on left pane
        dockManager.dropTargetPaneInfo.pane = pane1;
        dockManager.dropTargetPaneInfo.targetRect = leftHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 400, 300, 300));
        // Horizontal root split pane - drop on right pane
        dockManager.dropTargetPaneInfo.pane = pane2;
        dockManager.dropTargetPaneInfo.targetRect = rightHalfRect;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(400, 400, 300, 300));
      });
    });
    describe('Outer', () => {
      beforeEach(() => {
        docHost = {
          type: IgcDockManagerPaneType.documentHost,
          rootPane: {
            type: IgcDockManagerPaneType.splitPane,
            orientation: IgcSplitPaneOrientation.horizontal,
            panes: [pane1, pane2]
          },
          size: 200
        };
        rootPane.panes = [docHost];
        dockManager.layout = {
          rootPane,
          floatingPanes: [floatingPane]
        };
        dockManager.dropTargetPaneInfo.docHost = docHost;
      });
      it('show drop shadow on outer left', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.outerLeft, isRoot: false };
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 200, 600));
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 300, 600));
      });
      it('show drop shadow on outer right', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.outerRight, isRoot: false };
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(500, 100, 200, 600));
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(400, 100, 300, 600));
      });
      it('show drop shadow on outer top', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.outerTop, isRoot: false };
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 600, 200));
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 600, 300));
      });
      it('show drop shadow on outer bottom', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.outerBottom, isRoot: false };
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        let shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 500, 600, 200));
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        shadowRect = service.getDropShadowRect();
        expect(shadowRect).toEqual(new DOMRect(100, 400, 600, 300));
      });
    });
    describe('Root', () => {
      beforeEach(() => {
        rootPane.panes = [pane1, pane2];
        dockManager.layout = {
          rootPane,
          floatingPanes: [floatingPane]
        };
      });
      it('show drop shadow on root left', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.left, isRoot: true };
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        let shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 300, 600));
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 200, 600));
      });
      it('show drop shadow on root right', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.right, isRoot: true };
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        let shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(400, 100, 300, 600));
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(500, 100, 200, 600));
      });
      it('show drop shadow on root top', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.top, isRoot: true };
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        let shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 600, 200));
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(100, 100, 600, 300));
      });
      it('show drop shadow on root bottom', () => {
        service.dockingIndicator = { position: IgcDockingIndicatorPosition.bottom, isRoot: true };
        // Vertical root split pane
        rootPane.orientation = IgcSplitPaneOrientation.vertical;
        let shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(100, 500, 600, 200));
        // Horizontal root split pane
        rootPane.orientation = IgcSplitPaneOrientation.horizontal;
        shadowRect = service.getDropShadowRectRoot();
        expect(shadowRect).toEqual(new DOMRect(100, 400, 600, 300));
      });
    });
  });
  describe('Drag Events', () => {
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    let pane5;
    let floatingPane1;
    let floatingPane2;
    let tabGroupPane;
    let rootPane;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header'
      };
      tabGroupPane = {
        type: IgcDockManagerPaneType.tabGroupPane,
        panes: [pane1, pane2]
      };
      floatingPane1 = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [pane4]
      };
      floatingPane2 = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.vertical,
        floatingLocation: { x: 10, y: 20 },
        panes: [
          {
            type: IgcDockManagerPaneType.documentHost,
            rootPane: {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.vertical,
              panes: [pane5]
            }
          }
        ]
      };
      rootPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          tabGroupPane,
          pane3
        ]
      };
      dockManager.layout = {
        rootPane,
        floatingPanes: [floatingPane1]
      };
    });
    it('dragging content pane', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      const rect = new DOMRect(100, 200, 300, 400);
      const dragStarted = service.dragPaneStart(pane1, rect, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 100, y: 200 },
          width: 300,
          height: 400
        },
        isValid: true
      });
      expect(dockManager.layout.floatingPanes.length).toBe(2);
      const floatingPane = dockManager.layout.floatingPanes[1];
      expect(floatingPane.panes.length).toBe(1);
      expect(floatingPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(floatingPane.panes[0].panes).toEqual([pane1, pane2]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 300, 400);
      dockManager.dropTargetPaneInfo = {
        pane: pane3,
        docHost: null,
        targetRect: new DOMRect(50, 150, 250, 350)
      };
      service.dropTargetParentRect = new DOMRect(0, 0, 400, 400);
      const dockingIndicator = {
        position: IgcDockingIndicatorPosition.bottom,
        isRoot: false
      };
      service.dockingIndicator = dockingIndicator;
      dragOverSpy.mockClear();
      const dragMoved = service.dragPaneMove(155, 305);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledTimes(2);
      expect(dragOverSpy).toHaveBeenNthCalledWith(1, {
        sourcePane: floatingPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 100, y: 200 },
          newLocation: { x: 150, y: 300 },
        },
        isValid: true
      });
      expect(dragOverSpy).toHaveBeenNthCalledWith(2, {
        sourcePane: floatingPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.dockPane,
          dockingIndicator,
          targetPane: pane3
        },
        isValid: true
      });
      verifyFloatingPaneSize(floatingPane, 150, 300, 300, 400);
      const docked = service.dragPaneEnd();
      expect(docked).toBe(true);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane,
        panes: [pane1, pane2]
      });
      expect(rootPane.panes.length).toBe(1);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.splitPane);
      const splitPane = rootPane.panes[0];
      expect(splitPane.panes.length).toBe(2);
      expect(splitPane.panes[0]).toBe(pane3);
      expect(splitPane.panes[1]).toBe(tabGroupPane);
    });
    it('dragging floating pane', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      const dragStarted = service.dragPaneStart(floatingPane1, null, 105, 205);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4]
      });
      const dragMoved = service.dragPaneMove(155, 305);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 0, y: 0 },
          newLocation: { x: 50, y: 100 }
        },
        isValid: true
      });
      verifyFloatingPaneSize(floatingPane1, 50, 100, undefined, undefined);
      const docked = service.dragPaneEnd();
      expect(docked).toBe(false);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4]
      });
    });
    it('dragging floating pane when containedInBoundaries is true', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      service.dockManagerRect = new DOMRect(0, 0, 400, 400);
      dockManager.containedInBoundaries = true;
      const dragStarted = service.dragPaneStart(floatingPane1, null, 105, 205);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4]
      });
      const dragMoved = service.dragPaneMove(-155, -305);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 0, y: 0 },
          newLocation: { x: 0, y: 0 }
        },
        isValid: true
      });
      verifyFloatingPaneSize(floatingPane1, 0, 0, undefined, undefined);
      const docked = service.dragPaneEnd();
      expect(docked).toBe(false);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4]
      });
    });
    it('dragging floating pane when proximityDock is true', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      service.dockManagerRect = new DOMRect(0, 0, 400, 400);
      dockManager.proximityDock = true;
      const dragStarted = service.dragPaneStart(floatingPane1, null, 0, 0);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4]
      });
      const dragMoved = service.dragPaneMove(100, 100);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 0, y: 0 },
          newLocation: { x: 100, y: 100 }
        },
        isValid: true
      });
      verifyFloatingPaneSize(floatingPane1, 100, 100, undefined, undefined);
      const docked = service.dragPaneEnd();
      expect(docked).toBe(false);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4]
      });
    });
    it('dragging floating pane with single document host tab', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      const layout = dockManager.layout;
      layout.floatingPanes.push(floatingPane2);
      dockManager.layout = Object.assign({}, layout);
      const dragStarted = service.dragPaneStart(floatingPane2, null, 105, 205);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane2,
        panes: [pane5]
      });
      const dragMoved = service.dragPaneMove(155, 305);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane2,
        panes: [pane5],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 10, y: 20 },
          newLocation: { x: 60, y: 120 }
        },
        isValid: true
      });
      verifyFloatingPaneSize(floatingPane2, 60, 120, undefined, undefined);
      const docked = service.dragPaneEnd();
      expect(docked).toBe(false);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane2,
        panes: [pane5]
      });
    });
    it('dragging flyout pane when floating is not allowed', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      const rect = new DOMRect(100, 200, 300, 400);
      pane3.allowFloating = false;
      service.togglePin(pane3);
      service.flyoutPane(pane3);
      const dragStarted = service.dragPaneStart(pane3, rect, 105, 205);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane3,
        panes: [pane3]
      });
      expect(dockManager.layout.floatingPanes.length).toBe(1);
      dockManager.dropTargetPaneInfo = {
        pane: tabGroupPane,
        docHost: null,
        targetRect: new DOMRect(50, 150, 250, 350)
      };
      service.dropTargetParentRect = new DOMRect(0, 0, 400, 400);
      const dockingIndicator = {
        position: IgcDockingIndicatorPosition.bottom,
        isRoot: false
      };
      service.dockingIndicator = dockingIndicator;
      const dragMoved = service.dragPaneMove(50, 100);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane3,
        panes: [pane3],
        action: {
          type: IgcPaneDragActionType.dockPane,
          dockingIndicator,
          targetPane: tabGroupPane
        },
        isValid: true
      });
      const docked = service.dragPaneEnd();
      expect(docked).toBe(true);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: pane3,
        panes: [pane3]
      });
      expect(rootPane.panes.length).toBe(1);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.splitPane);
      const splitPane = rootPane.panes[0];
      expect(splitPane.panes.length).toBe(2);
      expect(splitPane.panes[0]).toBe(tabGroupPane);
      expect(splitPane.panes[1]).toBe(pane3);
      expect(pane3.isPinned).toBe(true);
      expect(dockManager.flyoutPane).toBeNull();
    });
    it('dragging when there is a maximized pane', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      dockManager.maximizedPane = pane3;
      const dragStarted = service.dragPaneStart(pane3, null, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).not.toHaveBeenCalled();
    });
    it('dragging when floating is not allowed', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      pane2.allowFloating = false;
      const dragStarted = service.dragPaneStart(pane1, null, 105, 205);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).not.toHaveBeenCalled();
      dockManager.dropTargetPaneInfo = {
        pane: pane3,
        docHost: null,
        targetRect: new DOMRect(50, 150, 250, 350)
      };
      service.dropTargetParentRect = new DOMRect(0, 0, 400, 400);
      const dockingIndicator = {
        position: IgcDockingIndicatorPosition.bottom,
        isRoot: false
      };
      service.dockingIndicator = dockingIndicator;
      const dragMoved = service.dragPaneMove(100, 150);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: tabGroupPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.dockPane,
          dockingIndicator,
          targetPane: pane3
        },
        isValid: true
      });
      const docked = service.dragPaneEnd();
      expect(docked).toBe(true);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: tabGroupPane,
        panes: [pane1, pane2]
      });
      expect(rootPane.panes.length).toBe(1);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.splitPane);
      const splitPane = rootPane.panes[0];
      expect(splitPane.panes.length).toBe(2);
      expect(splitPane.panes[0]).toBe(pane3);
      expect(splitPane.panes[1]).toBe(tabGroupPane);
    });
    it('dragging when docking and floating are not allowed', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      pane1.allowDocking = false;
      pane2.allowFloating = false;
      const dragStarted = service.dragPaneStart(pane1, null, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).not.toHaveBeenCalled();
    });
    it('cancel drag start', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      dockManager.paneDragStart.addEventListener(e => e.preventDefault());
      const dragStarted = service.dragPaneStart(pane1, null, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).not.toHaveBeenCalled();
    });
    it('cancel float pane action on drag over', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const rect = new DOMRect(100, 200, 300, 400);
      dockManager.paneDragOver.addEventListener(e => e.preventDefault());
      const dragStarted = service.dragPaneStart(pane1, rect, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 100, y: 200 },
          width: 300,
          height: 400
        },
        isValid: true
      });
      expect(dockManager.layout.floatingPanes.length).toBe(1);
    });
    it('cancel move floating pane action on drag over', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      dockManager.paneDragOver.addEventListener(e => {
        if (e.detail.action.type === IgcPaneDragActionType.moveFloatingPane) {
          e.preventDefault();
        }
      });
      const dragStarted = service.dragPaneStart(floatingPane1, null, 105, 205);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4]
      });
      const dragMoved = service.dragPaneMove(155, 305);
      expect(dragMoved).toBe(false);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane1,
        panes: [pane4],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 0, y: 0 },
          newLocation: { x: 50, y: 100 }
        },
        isValid: true
      });
      verifyFloatingPaneSize(floatingPane1, undefined, undefined, undefined, undefined);
    });
    it('cancel dock pane action on drag over', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      dockManager.paneDragOver.addEventListener(e => {
        if (e.detail.action.type === IgcPaneDragActionType.dockPane) {
          e.preventDefault();
        }
      });
      const rect = new DOMRect(100, 200, 300, 400);
      const dragStarted = service.dragPaneStart(pane1, rect, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 100, y: 200 },
          width: 300,
          height: 400
        },
        isValid: true
      });
      expect(dockManager.layout.floatingPanes.length).toBe(2);
      const floatingPane = dockManager.layout.floatingPanes[1];
      expect(floatingPane.panes.length).toBe(1);
      expect(floatingPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(floatingPane.panes[0].panes).toEqual([pane1, pane2]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 300, 400);
      dockManager.dropTargetPaneInfo = {
        pane: pane3,
        docHost: null,
        targetRect: new DOMRect(50, 150, 250, 350)
      };
      service.dropTargetParentRect = new DOMRect(0, 0, 400, 400);
      const dockingIndicator = {
        position: IgcDockingIndicatorPosition.bottom,
        isRoot: false
      };
      service.dockingIndicator = dockingIndicator;
      dragOverSpy.mockClear();
      const dragMoved = service.dragPaneMove(155, 305);
      expect(dragMoved).toBe(false);
      expect(dragOverSpy).toHaveBeenCalledTimes(2);
      expect(dragOverSpy).toHaveBeenNthCalledWith(1, {
        sourcePane: floatingPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 100, y: 200 },
          newLocation: { x: 150, y: 300 },
        },
        isValid: true
      });
      expect(dragOverSpy).toHaveBeenNthCalledWith(2, {
        sourcePane: floatingPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.dockPane,
          dockingIndicator,
          targetPane: pane3
        },
        isValid: true
      });
      verifyFloatingPaneSize(floatingPane, 150, 300, 300, 400);
    });
    it('invalid float pane action on drag over', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      const dragEndSpy = jest.spyOn(dockManager.paneDragEnd, 'emit');
      dockManager.paneDragOver.addEventListener(e => {
        if (e.detail.action.type === IgcPaneDragActionType.floatPane) {
          e.detail.isValid = false;
        }
      });
      const dragStarted = service.dragPaneStart(pane1, new DOMRect(100, 200, 300, 400), 105, 205);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 100, y: 200 },
          width: 300,
          height: 400
        },
        isValid: false
      });
      dragOverSpy.mockClear();
      let dragMoved = service.dragPaneMove(100, 150);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).not.toHaveBeenCalled();
      expect(dockManager.isValidDrop).toBe(false);
      dockManager.dropTargetPaneInfo = {
        pane: pane3,
        docHost: null,
        targetRect: new DOMRect(50, 150, 250, 350)
      };
      service.dropTargetParentRect = new DOMRect(0, 0, 400, 400);
      const dockingIndicator = {
        position: IgcDockingIndicatorPosition.bottom,
        isRoot: false
      };
      service.dockingIndicator = dockingIndicator;
      dragMoved = service.dragPaneMove(100, 150);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: tabGroupPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.dockPane,
          dockingIndicator,
          targetPane: pane3
        },
        isValid: true
      });
      expect(dockManager.isValidDrop).toBe(true);
      const docked = service.dragPaneEnd();
      expect(docked).toBe(true);
      expect(dragEndSpy).toHaveBeenCalledWith({
        sourcePane: tabGroupPane,
        panes: [pane1, pane2]
      });
      expect(rootPane.panes.length).toBe(1);
      expect(rootPane.panes[0].type).toBe(IgcDockManagerPaneType.splitPane);
      const splitPane = rootPane.panes[0];
      expect(splitPane.panes.length).toBe(2);
      expect(splitPane.panes[0]).toBe(pane3);
      expect(splitPane.panes[1]).toBe(tabGroupPane);
    });
    it('invalid move floating pane action on drag over', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      dockManager.paneDragOver.addEventListener(e => {
        if (e.detail.action.type === IgcPaneDragActionType.moveFloatingPane) {
          e.detail.isValid = false;
        }
      });
      const rect = new DOMRect(100, 200, 300, 400);
      const dragStarted = service.dragPaneStart(pane1, rect, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 100, y: 200 },
          width: 300,
          height: 400
        },
        isValid: true
      });
      expect(dockManager.layout.floatingPanes.length).toBe(2);
      const floatingPane = dockManager.layout.floatingPanes[1];
      expect(floatingPane.panes.length).toBe(1);
      expect(floatingPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(floatingPane.panes[0].panes).toEqual([pane1, pane2]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 300, 400);
      dragOverSpy.mockClear();
      const dragMoved = service.dragPaneMove(155, 305);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: floatingPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 100, y: 200 },
          newLocation: { x: 150, y: 300 },
        },
        isValid: false
      });
      expect(dockManager.isValidDrop).toBe(false);
      verifyFloatingPaneSize(floatingPane, 100, 200, 300, 400);
      service.dragPaneEnd();
      verifyFloatingPaneSize(floatingPane, 100, 200, 300, 400);
    });
    it('invalid dock pane action on drag over', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      dockManager.paneDragOver.addEventListener(e => {
        if (e.detail.action.type === IgcPaneDragActionType.dockPane) {
          e.detail.isValid = false;
        }
      });
      const rect = new DOMRect(100, 200, 300, 400);
      const dragStarted = service.dragPaneStart(pane1, rect, 105, 205);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2]
      });
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 100, y: 200 },
          width: 300,
          height: 400
        },
        isValid: true
      });
      expect(dockManager.layout.floatingPanes.length).toBe(2);
      const floatingPane = dockManager.layout.floatingPanes[1];
      expect(floatingPane.panes.length).toBe(1);
      expect(floatingPane.panes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
      expect(floatingPane.panes[0].panes).toEqual([pane1, pane2]);
      verifyFloatingPaneSize(floatingPane, 100, 200, 300, 400);
      dockManager.dropTargetPaneInfo = {
        pane: pane3,
        docHost: null,
        targetRect: new DOMRect(50, 150, 250, 350)
      };
      service.dropTargetParentRect = new DOMRect(0, 0, 400, 400);
      const dockingIndicator = {
        position: IgcDockingIndicatorPosition.bottom,
        isRoot: false
      };
      service.dockingIndicator = dockingIndicator;
      dragOverSpy.mockClear();
      const dragMoved = service.dragPaneMove(155, 305);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledTimes(2);
      expect(dragOverSpy).toHaveBeenNthCalledWith(1, {
        sourcePane: floatingPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.moveFloatingPane,
          oldLocation: { x: 100, y: 200 },
          newLocation: { x: 150, y: 300 },
        },
        isValid: true
      });
      expect(dragOverSpy).toHaveBeenNthCalledWith(2, {
        sourcePane: floatingPane,
        panes: [pane1, pane2],
        action: {
          type: IgcPaneDragActionType.dockPane,
          dockingIndicator,
          targetPane: pane3
        },
        isValid: false
      });
      expect(dockManager.isValidDrop).toBe(false);
      verifyFloatingPaneSize(floatingPane, 150, 300, 300, 400);
      service.dragPaneEnd();
      expect(dockManager.layout.floatingPanes.length).toBe(2);
    });
  });
  describe('Focusing', () => {
    let rootPane;
    let docHost;
    let tabGroup;
    let docHostTabGroup;
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    let pane5;
    let pane6;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header'
      };
      pane6 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '6',
        header: 'Header'
      };
      tabGroup = {
        type: IgcDockManagerPaneType.tabGroupPane,
        panes: [pane1, pane2]
      };
      docHostTabGroup = {
        type: IgcDockManagerPaneType.tabGroupPane,
        panes: [pane4, pane5]
      };
      docHost = {
        type: IgcDockManagerPaneType.documentHost,
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.vertical,
          panes: [
            docHostTabGroup,
            pane6
          ]
        }
      };
      rootPane = {
        type: IgcDockManagerPaneType.splitPane,
        orientation: IgcSplitPaneOrientation.horizontal,
        panes: [
          tabGroup,
          pane3,
          docHost,
        ]
      };
      dockManager.layout = {
        rootPane
      };
    });
    it('focus next content pane', () => {
      dockManager.activePane = null;
      dockManager.service.cacheContentPanesOrder();
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane1);
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane2);
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane3);
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane1);
      dockManager.activePane = null;
      tabGroup.panes = [pane2, pane1];
      dockManager.layout = Object.assign({}, dockManager.layout);
      dockManager.service.cacheContentPanesOrder();
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane2);
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane1);
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane3);
      service.focusNextContentPane(false);
      expect(dockManager.activePane).toBe(pane2);
    });
    it('focus next document', () => {
      dockManager.activePane = null;
      dockManager.service.cacheDocumentsOrder();
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane4);
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane5);
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane6);
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane4);
      dockManager.activePane = null;
      docHostTabGroup.panes = [pane5, pane4];
      dockManager.layout = Object.assign({}, dockManager.layout);
      dockManager.service.cacheDocumentsOrder();
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane5);
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane4);
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane6);
      service.focusNextContentPane(true);
      expect(dockManager.activePane).toBe(pane5);
    });
    it('focus previous content pane', () => {
      dockManager.activePane = null;
      dockManager.service.cacheContentPanesOrder();
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane3);
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane2);
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane1);
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane3);
      dockManager.activePane = null;
      tabGroup.panes = [pane2, pane1];
      dockManager.layout = Object.assign({}, dockManager.layout);
      dockManager.service.cacheContentPanesOrder();
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane3);
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane1);
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane2);
      service.focusPrevContentPane(false);
      expect(dockManager.activePane).toBe(pane3);
    });
    it('focus previous document', () => {
      dockManager.activePane = null;
      dockManager.service.cacheDocumentsOrder();
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane6);
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane5);
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane4);
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane6);
      dockManager.activePane = null;
      docHostTabGroup.panes = [pane5, pane4];
      dockManager.layout = Object.assign({}, dockManager.layout);
      dockManager.service.cacheDocumentsOrder();
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane6);
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane4);
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane5);
      service.focusPrevContentPane(true);
      expect(dockManager.activePane).toBe(pane6);
    });
  });
  describe('Tabs', () => {
    let pane1;
    let pane2;
    let pane3;
    let tabGroup;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      tabGroup = {
        type: IgcDockManagerPaneType.tabGroupPane,
        panes: [pane1, pane2, pane3]
      };
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [tabGroup]
        }
      };
    });
    it('select hidden tab', () => {
      tabGroup.selectedIndex = 1;
      service.selectHiddenTab(tabGroup, tabGroup.panes[2]);
      expect(tabGroup.panes).toEqual([pane3, pane1, pane2]);
      expect(tabGroup.selectedIndex).toBe(0);
      service.selectHiddenTab(tabGroup, tabGroup.panes[1]);
      expect(tabGroup.panes).toEqual([pane1, pane3, pane2]);
      expect(tabGroup.selectedIndex).toBe(0);
    });
    it('shift tab left', () => {
      tabGroup.selectedIndex = 1;
      service.shiftTabLeft(pane2);
      expect(tabGroup.panes).toEqual([pane2, pane1, pane3]);
      expect(tabGroup.selectedIndex).toBe(0);
      expect(service.forceDragTabHeader).toBe(pane2);
      service.shiftTabLeft(pane3);
      expect(tabGroup.panes).toEqual([pane2, pane3, pane1]);
      expect(tabGroup.selectedIndex).toBe(1);
      expect(service.forceDragTabHeader).toBe(pane3);
    });
    it('shift tab right', () => {
      tabGroup.selectedIndex = 1;
      service.shiftTabRight(pane2);
      expect(tabGroup.panes).toEqual([pane1, pane3, pane2]);
      expect(tabGroup.selectedIndex).toBe(2);
      expect(service.forceDragTabHeader).toBe(pane2);
      service.shiftTabRight(pane1);
      expect(tabGroup.panes).toEqual([pane3, pane1, pane2]);
      expect(tabGroup.selectedIndex).toBe(1);
    });
    it('drag tab start', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      const dragStarted = service.dragTabStart(pane1);
      expect(dragStarted).toBe(true);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1]
      });
    });
    it('cancel drag tab start', () => {
      const dragStartSpy = jest.spyOn(dockManager.paneDragStart, 'emit');
      dockManager.paneDragStart.addEventListener(e => e.preventDefault());
      const dragStarted = service.dragTabStart(pane1);
      expect(dragStarted).toBe(false);
      expect(dragStartSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1]
      });
    });
    it('drag tab move', () => {
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      service.dragTabStart(pane1);
      const args = {
        clientX: 105,
        clientY: 510,
        offsetX: 5,
        offsetY: 0,
        totalOffsetX: 0,
        totalOffsetY: 0
      };
      let rects = {
        headerRect: new DOMRect(0, 500, 100, 20),
        prevHeaderRect: null,
        nextHeaderRect: new DOMRect(100, 500, 100, 20),
        lastVisibleHeaderRect: new DOMRect(100, 500, 100, 20),
        tabsRect: new DOMRect(0, 0, 300, 550)
      };
      let dragMoved = service.dragTabMove(pane1, args, rects);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1],
        action: {
          type: IgcPaneDragActionType.moveTab,
          oldIndex: 0,
          newIndex: 1
        },
        isValid: true
      });
      expect(tabGroup.panes).toEqual([pane2, pane1, pane3]);
      expect(tabGroup.selectedIndex).toEqual(1);
      args.clientX = 95;
      args.offsetX = -5;
      rects = {
        headerRect: new DOMRect(100, 500, 100, 20),
        prevHeaderRect: new DOMRect(0, 500, 100, 20),
        nextHeaderRect: null,
        lastVisibleHeaderRect: new DOMRect(100, 500, 100, 20),
        tabsRect: new DOMRect(0, 0, 250, 550)
      };
      dragMoved = service.dragTabMove(pane1, args, rects);
      expect(dragMoved).toBe(true);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1],
        action: {
          type: IgcPaneDragActionType.moveTab,
          oldIndex: 1,
          newIndex: 0
        },
        isValid: true
      });
      expect(tabGroup.panes).toEqual([pane1, pane2, pane3]);
      expect(tabGroup.selectedIndex).toEqual(0);
    });
    it('cancel drag tab move', () => {
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      dockManager.paneDragOver.addEventListener(e => e.preventDefault());
      service.dragTabStart(pane1);
      const args = {
        clientX: 105,
        clientY: 510,
        offsetX: 5,
        offsetY: 0,
        totalOffsetX: 0,
        totalOffsetY: 0
      };
      const rects = {
        headerRect: new DOMRect(0, 500, 100, 20),
        prevHeaderRect: null,
        nextHeaderRect: new DOMRect(100, 500, 100, 20),
        lastVisibleHeaderRect: new DOMRect(100, 500, 100, 20),
        tabsRect: new DOMRect(0, 0, 300, 550)
      };
      const dragMoved = service.dragTabMove(pane1, args, rects);
      expect(dragMoved).toBe(false);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane1],
        action: {
          type: IgcPaneDragActionType.moveTab,
          oldIndex: 0,
          newIndex: 1
        },
        isValid: true
      });
      expect(tabGroup.panes).toEqual([pane1, pane2, pane3]);
    });
    it('drag tab move - float tab X', () => {
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      service.dragTabStart(pane1);
      const args = {
        clientX: 75,
        clientY: 510,
        offsetX: -5,
        offsetY: 0,
        totalOffsetX: -50,
        totalOffsetY: 0
      };
      const rects = {
        headerRect: new DOMRect(100, 500, 100, 20),
        prevHeaderRect: null,
        nextHeaderRect: new DOMRect(200, 500, 100, 20),
        lastVisibleHeaderRect: new DOMRect(200, 500, 100, 20),
        tabsRect: new DOMRect(100, 100, 300, 550)
      };
      let dragTabMoved = service.dragTabMove(pane1, args, rects);
      expect(dragTabMoved).toBe(true);
      expect(dragOverSpy).not.toHaveBeenCalled();
      expect(tabGroup.panes).toEqual([pane1, pane2, pane3]);
      args.clientX = 45;
      args.totalOffsetX = -70;
      dragTabMoved = service.dragTabMove(pane1, args, rects);
      expect(dragTabMoved).toBe(false);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane2, pane3],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 20, y: 500 },
          width: 300,
          height: 550
        },
        isValid: true
      });
      expect(tabGroup.panes).toEqual([pane2, pane3]);
    });
    it('drag tab move - float tab Y', () => {
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      service.dragTabStart(pane1);
      const args = {
        clientX: 150,
        clientY: 475,
        offsetX: 0,
        offsetY: -5,
        totalOffsetX: 0,
        totalOffsetY: -35
      };
      const rects = {
        headerRect: new DOMRect(100, 500, 100, 20),
        prevHeaderRect: null,
        nextHeaderRect: new DOMRect(200, 500, 100, 20),
        lastVisibleHeaderRect: new DOMRect(200, 500, 100, 20),
        tabsRect: new DOMRect(100, 100, 300, 550)
      };
      let dragTabMoved = service.dragTabMove(pane1, args, rects);
      expect(dragTabMoved).toBe(true);
      expect(dragOverSpy).not.toHaveBeenCalled();
      expect(tabGroup.panes).toEqual([pane1, pane2, pane3]);
      args.clientY = 445;
      args.totalOffsetY = -65;
      dragTabMoved = service.dragTabMove(pane1, args, rects);
      expect(dragTabMoved).toBe(false);
      expect(dragOverSpy).toHaveBeenCalledWith({
        sourcePane: pane1,
        panes: [pane2, pane3],
        action: {
          type: IgcPaneDragActionType.floatPane,
          location: { x: 100, y: 435 },
          width: 300,
          height: 550
        },
        isValid: true
      });
      expect(tabGroup.panes).toEqual([pane2, pane3]);
    });
    it('moving tab when floating is not allowed', () => {
      const dragOverSpy = jest.spyOn(dockManager.paneDragOver, 'emit');
      pane1.allowFloating = false;
      service.dragTabStart(pane1);
      const args = {
        clientX: 150,
        clientY: 445,
        offsetX: 0,
        offsetY: -5,
        totalOffsetX: 0,
        totalOffsetY: -65
      };
      const rects = {
        headerRect: new DOMRect(100, 500, 100, 20),
        prevHeaderRect: null,
        nextHeaderRect: new DOMRect(200, 500, 100, 20),
        lastVisibleHeaderRect: new DOMRect(200, 500, 100, 20),
        tabsRect: new DOMRect(100, 100, 300, 550)
      };
      const dragTabMoved = service.dragTabMove(pane1, args, rects);
      expect(dragTabMoved).toBe(true);
      expect(dragOverSpy).not.toHaveBeenCalled();
      expect(tabGroup.panes).toEqual([pane1, pane2, pane3]);
    });
  });
  describe('Allow empty', () => {
    let pane1;
    let pane2;
    let pane3;
    let pane4;
    let pane5;
    let pane6;
    let pane7;
    let rootPane;
    let rootPanes;
    beforeEach(() => {
      pane1 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '1',
        header: 'Header'
      };
      pane2 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '2',
        header: 'Header'
      };
      pane3 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '3',
        header: 'Header'
      };
      pane4 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '4',
        header: 'Header'
      };
      pane5 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '5',
        header: 'Header'
      };
      pane6 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '6',
        header: 'Header',
        unpinnedLocation: IgcUnpinnedLocation.bottom
      };
      pane7 = {
        type: IgcDockManagerPaneType.contentPane,
        contentId: '7',
        header: 'Header'
      };
      dockManager.layout = {
        rootPane: {
          type: IgcDockManagerPaneType.splitPane,
          orientation: IgcSplitPaneOrientation.horizontal,
          panes: [
            {
              type: IgcDockManagerPaneType.tabGroupPane,
              allowEmpty: true,
              panes: [pane1, pane2]
            },
            {
              type: IgcDockManagerPaneType.documentHost,
              rootPane: {
                type: IgcDockManagerPaneType.splitPane,
                orientation: IgcSplitPaneOrientation.horizontal,
                allowEmpty: true,
                panes: [pane3]
              }
            },
            {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.horizontal,
              allowEmpty: true,
              panes: [pane7]
            },
            {
              type: IgcDockManagerPaneType.splitPane,
              orientation: IgcSplitPaneOrientation.horizontal,
              panes: [
                {
                  type: IgcDockManagerPaneType.tabGroupPane,
                  panes: [pane4, pane5]
                },
                pane6
              ]
            }
          ]
        },
        floatingPanes: [
          {
            type: IgcDockManagerPaneType.splitPane,
            orientation: IgcSplitPaneOrientation.horizontal,
            allowEmpty: true,
            panes: [
              {
                type: IgcDockManagerPaneType.splitPane,
                orientation: IgcSplitPaneOrientation.vertical,
                panes: [
                  {
                    type: IgcDockManagerPaneType.contentPane,
                    contentId: '1',
                    header: 'Floating Header'
                  },
                  {
                    type: IgcDockManagerPaneType.tabGroupPane,
                    allowEmpty: true,
                    panes: [
                      {
                        type: IgcDockManagerPaneType.contentPane,
                        contentId: 'Tab 1',
                        header: 'Floating Tab'
                      },
                      {
                        type: IgcDockManagerPaneType.contentPane,
                        contentId: 'Tab 2',
                        header: 'Floating Tab'
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      };
      rootPane = dockManager.layout.rootPane;
      rootPanes = rootPane.panes;
    });
    it('property can be set on split and tab group panes.', () => {
      const splitPanes = rootPanes.filter(p => p.type === IgcDockManagerPaneType.splitPane);
      expect(splitPanes.length).toBe(2);
      expect(splitPanes[0].allowEmpty).toBe(true);
      expect(splitPanes[1].allowEmpty).toBeUndefined();
      expect(rootPanes[0].allowEmpty).toBe(true);
      expect(rootPanes[1].rootPane.allowEmpty).toBe(true);
    });
    it('tab group is preserved after closing its panes.', () => {
      service.closePane(pane1);
      expect(rootPanes[0].type).toBe(IgcDockManagerPaneType.tabGroupPane);
    });
    it('tab group is not preserved after closing its panes when allowEmpty is not true.', () => {
      service.closePane(pane5);
      const panes = rootPanes[3].panes;
      expect(panes.length).toBe(1);
      expect(panes[0].type).toBe(IgcDockManagerPaneType.contentPane);
    });
    it('split pane is preserved after closing its panes.', () => {
      service.closePane(pane7);
      expect(rootPanes[2].type).toBe(IgcDockManagerPaneType.splitPane);
      expect(rootPanes[2].panes.length).toBe(0);
    });
    it('split pane is not preserved after closing its panes when allowEmpty is not true.', () => {
      expect(rootPanes.length).toBe(4);
      service.closePane(pane4);
      service.closePane(pane6);
      expect(rootPanes.length).toBe(3);
    });
    it('document host is preserved after closing all its panes.', () => {
      service.closePane(pane3);
      expect(rootPanes.length).toBe(4);
      expect(rootPanes[1].type).toBe(IgcDockManagerPaneType.documentHost);
      expect(rootPanes[1].rootPane.panes.length).toBe(0);
    });
    it('document host is not preserved after closing its panes when allowEmpty is false.', () => {
      rootPanes[1].rootPane.allowEmpty = false;
      expect(rootPanes.length).toBe(4);
      service.closePane(pane3);
      expect(rootPanes.length).toBe(3);
      expect(rootPanes[1].type).not.toBe(IgcDockManagerPaneType.documentHost);
    });
    it('floating tab group is preserved after closing its panes.', () => {
      const floatingPanes = dockManager.layout.floatingPanes[0].panes;
      const sp = floatingPanes[0];
      const tab1 = sp.panes[1].panes[0];
      service.closePane(tab1);
      expect(sp.panes.length).toBe(2);
    });
    it('floating split pane is not preserved after closing all its panes even when allowEmpty is true.', () => {
      const floatingPanes = dockManager.layout.floatingPanes[0].panes;
      const sp = floatingPanes[0];
      const tab1 = sp.panes[1].panes[0];
      service.closePane(tab1);
      service.closePane(sp.panes[0]);
      expect(floatingPanes.length).toBe(0);
    });
  });
  function verifyFloatingPaneSize(pane, x, y, width, height) {
    var _a, _b;
    expect({
      x: (_a = pane.floatingLocation) === null || _a === void 0 ? void 0 : _a.x,
      y: (_b = pane.floatingLocation) === null || _b === void 0 ? void 0 : _b.y,
      width: pane.floatingWidth,
      height: pane.floatingHeight
    }).toEqual({ x, y, width, height });
  }
  function keyboardEventCall(altOrCtrKeyboardEvent, keyboardEventInit) {
    let keyboardEvent = new KeyboardEvent('keydown', altOrCtrKeyboardEvent);
    keyboardEvent.getModifierState = () => false;
    keyboardService.handleKeydown(keyboardEvent);
    keyboardEvent = new KeyboardEvent('keydown', keyboardEventInit);
    keyboardEvent.getModifierState = () => false;
    keyboardService.handleKeydown(keyboardEvent);
  }
});
//# sourceMappingURL=dockmanager.service.spec.js.map
