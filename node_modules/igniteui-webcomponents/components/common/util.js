export const partNameMap = (partNameInfo) => {
    return Object.keys(partNameInfo)
        .filter((key) => partNameInfo[key])
        .join(' ');
};
export function noop() { }
export const asPercent = (part, whole) => (part / whole) * 100;
export const clamp = (number, min, max) => Math.max(min, Math.min(number, max));
export function numberInRangeInclusive(value, min, max) {
    return value >= min && value <= max;
}
export function sameObject(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}
export function getOffset(element, parent) {
    const { top, left, bottom, right } = element.getBoundingClientRect();
    const { top: pTop, left: pLeft, bottom: pBottom, right: pRight, } = parent.getBoundingClientRect();
    return {
        top: Math.round(top - pTop),
        left: Math.round(left - pLeft),
        right: Math.round(right - pRight),
        bottom: Math.round(bottom - pBottom),
    };
}
export function createCounter() {
    let i = 0;
    return () => {
        i++;
        return i;
    };
}
export function isLTR(element) {
    return element.matches(':dir(ltr)');
}
export function formatString(template, ...params) {
    const length = params.length;
    return template.replace(/{(\d+)}/g, (match, index) => index >= length ? match : `${params[index]}`);
}
export function asNumber(value, fallback = 0) {
    const parsed = Number.parseFloat(value);
    return Number.isNaN(parsed) ? fallback : parsed;
}
export function wrap(min, max, value) {
    if (value < min) {
        return max;
    }
    if (value > max) {
        return min;
    }
    return value;
}
export function isDefined(value) {
    return value !== undefined;
}
export function* iterNodes(root, whatToShow, filter) {
    if (!isDefined(globalThis.document)) {
        return;
    }
    const iter = globalThis.document.createTreeWalker(root, NodeFilter[whatToShow ?? 'SHOW_ALL']);
    let node = iter.nextNode();
    while (node) {
        if (filter) {
            if (filter(node)) {
                yield node;
            }
        }
        else {
            yield node;
        }
        node = iter.nextNode();
    }
}
export function getElementByIdFromRoot(root, id) {
    return root.getRootNode().getElementById(id);
}
export function isElement(node) {
    return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
export function getElementsFromEventPath(event) {
    return event.composedPath().filter((item) => isElement(item));
}
export function findElementFromEventPath(predicate, event) {
    const func = typeof predicate === 'string'
        ? (e) => e.matches(predicate)
        : (e) => predicate(e);
    return getElementsFromEventPath(event).find(func);
}
export function groupBy(array, key) {
    const result = {};
    const _get = typeof key === 'function' ? key : (item) => item[key];
    for (const item of array) {
        const category = _get(item);
        const group = result[category];
        if (Array.isArray(group)) {
            group.push(item);
        }
        else {
            result[category] = [item];
        }
    }
    return result;
}
export function first(arr) {
    return arr.at(0);
}
export function last(arr) {
    return arr.at(-1);
}
export function modulo(n, d) {
    return ((n % d) + d) % d;
}
export function take(iterable, n) {
    const result = [];
    let i = 0;
    let current = iterable.next();
    while (i < n && !current.done) {
        result.push(current.value);
        current = iterable.next();
        i++;
    }
    return result;
}
export function* chunk(arr, size) {
    if (size < 1) {
        throw new Error('size must be an integer >= 1');
    }
    for (let i = 0; i < arr.length; i += size) {
        yield arr.slice(i, i + size);
    }
}
//# sourceMappingURL=util.js.map