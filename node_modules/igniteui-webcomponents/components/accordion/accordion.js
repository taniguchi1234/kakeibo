var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { LitElement, html } from 'lit';
import { property, queryAssignedElements } from 'lit/decorators.js';
import { addKeybindings, altKey, arrowDown, arrowUp, endKey, homeKey, shiftKey, } from '../common/controllers/key-bindings.js';
import { registerComponent } from '../common/definitions/register.js';
import { first, last } from '../common/util.js';
import IgcExpansionPanelComponent from '../expansion-panel/expansion-panel.js';
import { styles } from './themes/accordion.base.css.js';
class IgcAccordionComponent extends LitElement {
    static register() {
        registerComponent(IgcAccordionComponent, IgcExpansionPanelComponent);
    }
    constructor() {
        super();
        this.singleExpand = false;
        this.addEventListener('igcOpening', this.handlePanelOpening);
        addKeybindings(this, {
            skip: this.skipKeybinding,
            bindingDefaults: { preventDefault: true },
        })
            .set(homeKey, () => this.getPanelHeader(first(this.enabledPanels)).focus())
            .set(endKey, () => this.getPanelHeader(last(this.enabledPanels)).focus())
            .set(arrowUp, this.navigatePrev)
            .set(arrowDown, this.navigateNext)
            .set([shiftKey, altKey, arrowDown], this.expandAll)
            .set([shiftKey, altKey, arrowUp], this.collapseAll);
    }
    skipKeybinding(target) {
        return !(target.matches(IgcExpansionPanelComponent.tagName) &&
            this.enabledPanels.includes(target));
    }
    navigatePrev(event) {
        const current = event.target;
        const next = this.getNextPanel(current, -1);
        if (next !== current) {
            this.getPanelHeader(next).focus();
        }
    }
    navigateNext(event) {
        const current = event.target;
        const next = this.getNextPanel(current, 1);
        if (next !== current) {
            this.getPanelHeader(next).focus();
        }
    }
    collapseAll() {
        for (const panel of this.enabledPanels) {
            this.closePanel(panel);
        }
    }
    expandAll(event) {
        const current = event.target;
        for (const panel of this.enabledPanels) {
            if (this.singleExpand) {
                current === panel ? this.openPanel(panel) : this.closePanel(panel);
            }
            else {
                this.openPanel(panel);
            }
        }
    }
    handlePanelOpening(event) {
        const current = event.target;
        if (!(this.singleExpand && this.panels.includes(current))) {
            return;
        }
        for (const panel of this.enabledPanels) {
            if (panel.open && panel !== current) {
                this.closePanel(panel);
            }
        }
    }
    getNextPanel(panel, dir = 1) {
        const idx = this.enabledPanels.indexOf(panel);
        return this.enabledPanels[idx + dir] || panel;
    }
    getPanelHeader(panel) {
        return panel.renderRoot.querySelector('div[part="header"]');
    }
    async closePanel(panel) {
        if (!(panel.open &&
            panel.emitEvent('igcClosing', { cancelable: true, detail: panel }))) {
            return;
        }
        await panel.hide();
        panel.emitEvent('igcClosed', { detail: panel });
    }
    async openPanel(panel) {
        if (panel.open ||
            !panel.emitEvent('igcOpening', { cancelable: true, detail: panel })) {
            return;
        }
        await panel.show();
        panel.emitEvent('igcOpened', { detail: panel });
    }
    async hideAll() {
        await Promise.all(this.panels.map((panel) => panel.hide()));
    }
    async showAll() {
        await Promise.all(this.panels.map((panel) => panel.show()));
    }
    render() {
        return html `<slot></slot>`;
    }
}
IgcAccordionComponent.tagName = 'igc-accordion';
IgcAccordionComponent.styles = styles;
export default IgcAccordionComponent;
__decorate([
    queryAssignedElements({
        selector: `${IgcExpansionPanelComponent.tagName}:not([disabled])`,
    })
], IgcAccordionComponent.prototype, "enabledPanels", void 0);
__decorate([
    property({ attribute: 'single-expand', reflect: true, type: Boolean })
], IgcAccordionComponent.prototype, "singleExpand", void 0);
__decorate([
    queryAssignedElements({ selector: IgcExpansionPanelComponent.tagName })
], IgcAccordionComponent.prototype, "panels", void 0);
//# sourceMappingURL=accordion.js.map