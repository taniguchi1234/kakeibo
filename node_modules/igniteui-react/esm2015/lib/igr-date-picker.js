import * as React from 'react';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { DatePickerMode_$type } from "./DatePickerMode";
import { DatePickerHeaderOrientation_$type } from "./DatePickerHeaderOrientation";
import { DatePickerOrientation_$type } from "./DatePickerOrientation";
import { IgrCalendarResourceStrings } from "./igr-calendar-resource-strings";
import { WeekDays_$type } from "./WeekDays";
import { IgrVoidEventArgs } from "./igr-void-event-args";
import { IgrComponentDateValueChangedEventArgs } from "./igr-component-date-value-changed-event-args";
import { IgrBaseComboBoxLike } from "./igr-base-combo-box-like";
import { DatePicker } from "./DatePicker";
import { IgcDatePickerComponent, defineComponents } from "igniteui-webcomponents";
import { isValidProp, ensureEnum, ensureBool } from "igniteui-react-core";
/**
 * igc-date-picker is a feature rich component used for entering a date through manual text input or
 * choosing date values from a calendar dialog that pops up.
*/
export class IgrDatePicker extends IgrBaseComboBoxLike {
    createImplementation() {
        return new DatePicker();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._opening = null;
        this._opening_wrapped = null;
        this._opened = null;
        this._opened_wrapped = null;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        this._change = null;
        this._change_wrapped = null;
        this._input = null;
        this._input_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDatePickerComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        React.Children.forEach(propChildren, (ch) => {
            children.push(React.cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = React.createElement("igc-date-picker", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The label of the datepicker.
    */
    get label() {
        return this.i.ap;
    }
    set label(v) {
        this.i.ap = v;
    }
    /**
     * Determines whether the calendar is opened in a dropdown or a modal dialog
    */
    get mode() {
        return this.i.s;
    }
    set mode(v) {
        this.i.s = ensureEnum(DatePickerMode_$type, v);
    }
    /**
     * Whether to allow typing in the input.
    */
    get nonEditable() {
        return this.i.ad;
    }
    set nonEditable(v) {
        this.i.ad = ensureBool(v);
    }
    /**
     * Makes the control a readonly field.
    */
    get readOnly() {
        return this.i.af;
    }
    set readOnly(v) {
        this.i.af = ensureBool(v);
    }
    /**
     * The value of the picker
    */
    get value() {
        return this.i.al;
    }
    set value(v) {
        this.i.al = v;
    }
    /**
     * Gets/Sets the date which is shown in the calendar picker and is highlighted.
     * By default it is the current date.
    */
    get activeDate() {
        return this.i.ai;
    }
    set activeDate(v) {
        this.i.ai = v;
    }
    /**
     * The minimum value required for the date picker to remain valid.
    */
    get min() {
        return this.i.ak;
    }
    set min(v) {
        this.i.ak = v;
    }
    /**
     * The maximum value required for the date picker to remain valid.
    */
    get max() {
        return this.i.aj;
    }
    set max(v) {
        this.i.aj = v;
    }
    /**
     * The orientation of the calendar header.
    */
    get headerOrientation() {
        return this.i.r;
    }
    set headerOrientation(v) {
        this.i.r = ensureEnum(DatePickerHeaderOrientation_$type, v);
    }
    /**
     * The orientation of the multiple months displayed in the calendar's days view.
    */
    get orientation() {
        return this.i.t;
    }
    set orientation(v) {
        this.i.t = ensureEnum(DatePickerOrientation_$type, v);
    }
    /**
     * Determines whether the calendar hides its header.
    */
    get hideHeader() {
        return this.i.aa;
    }
    set hideHeader(v) {
        this.i.aa = ensureBool(v);
    }
    /**
     * Controls the visibility of the dates that do not belong to the current month.
    */
    get hideOutsideDays() {
        return this.i.ab;
    }
    set hideOutsideDays(v) {
        this.i.ab = ensureBool(v);
    }
    /**
     * Gets/sets disabled dates.
    */
    get disabledDates() {
        return this.i.m;
    }
    set disabledDates(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.m = v;
    }
    /**
     * Gets/sets special dates.
    */
    get specialDates() {
        return this.i.n;
    }
    set specialDates(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.n = v;
    }
    /**
     * Whether the control will have outlined appearance.
    */
    get outlined() {
        return this.i.ae;
    }
    set outlined(v) {
        this.i.ae = ensureBool(v);
    }
    /**
     * The placeholder attribute of the control.
    */
    get placeholder() {
        return this.i.as;
    }
    set placeholder(v) {
        this.i.as = v;
    }
    /**
     * The number of months displayed in the calendar.
    */
    get visibleMonths() {
        return this.i.am;
    }
    set visibleMonths(v) {
        this.i.am = +v;
    }
    /**
     * Whether to show the number of the week in the calendar.
    */
    get showWeekNumbers() {
        return this.i.ah;
    }
    set showWeekNumbers(v) {
        this.i.ah = ensureBool(v);
    }
    /**
     * Format to display the value in when not editing.
     * Defaults to the input format if not set.
    */
    get displayFormat() {
        return this.i.an;
    }
    set displayFormat(v) {
        this.i.an = v;
    }
    /**
     * The date format to apply on the input.
     * Defaults to the current locale Intl.DateTimeFormat
    */
    get inputFormat() {
        return this.i.ao;
    }
    set inputFormat(v) {
        this.i.ao = v;
    }
    /**
     * The locale settings used to display the value.
    */
    get locale() {
        return this.i.aq;
    }
    set locale(v) {
        this.i.aq = v;
    }
    /**
     * The prompt symbol to use for unfilled parts of the mask.
    */
    get prompt() {
        return this.i.at;
    }
    set prompt(v) {
        this.i.at = v;
    }
    /**
     * The resource strings of the calendar.
    */
    get resourceStrings() {
        const r = this.i.o;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrCalendarResourceStrings();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set resourceStrings(v) {
        v == null ? this.i.o = null : this.i.o = v.i;
    }
    /**
     * Sets the start day of the week for the calendar.
    */
    get weekStart() {
        return this.i.y;
    }
    set weekStart(v) {
        this.i.y = ensureEnum(WeekDays_$type, v);
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.z;
    }
    set disabled(v) {
        this.i.z = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.ag;
    }
    set required(v) {
        this.i.ag = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.ar;
    }
    set name(v) {
        this.i.ar = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.ac;
    }
    set invalid(v) {
        this.i.ac = ensureBool(v);
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.resourceStrings && this.resourceStrings.name && this.resourceStrings.name == name) {
            return this.resourceStrings;
        }
        return null;
    }
    connectedCallback() {
        this.i.az();
    }
    /**
     * Clears the input part of the component of any user input
    
    */
    clear() {
        this.i.aw();
    }
    stepUp(datePart, delta) {
        this.i.a9((datePart == null ? null : datePart), delta);
    }
    stepDown(datePart, delta) {
        this.i.a8((datePart == null ? null : datePart), delta);
    }
    /**
     * Selects the text in the input of the component
    
    */
    select() {
        this.i.a4();
    }
    setSelectionRange(start, end, direction) {
        this.i.a7(start, end, (direction == null ? null : direction));
    }
    setRangeText(replacement, start, end, mode) {
        this.i.a6(replacement, start, end, (mode == null ? null : mode));
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.a3();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.av();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.a5(message);
    }
    get opening() {
        return this._opening;
    }
    set opening(ev) {
        if (this._opening_wrapped !== null) {
            this.i.opening = delegateRemove(this.i.opening, this._opening_wrapped);
            this._opening_wrapped = null;
            this._opening = null;
        }
        this._opening = ev;
        this._opening_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpening) {
                this.beforeOpening(this, outerArgs);
            }
            if (this._opening) {
                this._opening(this, outerArgs);
            }
        };
        this.i.opening = delegateCombine(this.i.opening, this._opening_wrapped);
        if (this.i.openingChanged) {
            this.i.openingChanged();
        }
        ;
    }
    get opened() {
        return this._opened;
    }
    set opened(ev) {
        if (this._opened_wrapped !== null) {
            this.i.opened = delegateRemove(this.i.opened, this._opened_wrapped);
            this._opened_wrapped = null;
            this._opened = null;
        }
        this._opened = ev;
        this._opened_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpened) {
                this.beforeOpened(this, outerArgs);
            }
            if (this._opened) {
                this._opened(this, outerArgs);
            }
        };
        this.i.opened = delegateCombine(this.i.opened, this._opened_wrapped);
        if (this.i.openedChanged) {
            this.i.openedChanged();
        }
        ;
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDateValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get input() {
        return this._input;
    }
    set input(ev) {
        if (this._input_wrapped !== null) {
            this.i.input = delegateRemove(this.i.input, this._input_wrapped);
            this._input_wrapped = null;
            this._input = null;
        }
        this._input = ev;
        this._input_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDateValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeInput) {
                this.beforeInput(this, outerArgs);
            }
            if (this._input) {
                this._input(this, outerArgs);
            }
        };
        this.i.input = delegateCombine(this.i.input, this._input_wrapped);
        if (this.i.inputChanged) {
            this.i.inputChanged();
        }
        ;
    }
}
