import * as React from 'react';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { InputType_$type } from "./InputType";
import { IgrComponentDataValueChangedEventArgs } from "./igr-component-data-value-changed-event-args";
import { IgrInputBase } from "./igr-input-base";
import { Input } from "./Input";
import { IgcInputComponent, defineComponents } from "igniteui-webcomponents";
import { isValidProp, ensureEnum, ensureBool } from "igniteui-react-core";
/**

*/
export class IgrInput extends IgrInputBase {
    createImplementation() {
        return new Input();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcInputComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        React.Children.forEach(propChildren, (ch) => {
            children.push(React.cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = React.createElement("igc-input", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The value of the control.
    */
    get value() {
        return this.i.am;
    }
    set value(v) {
        this.i.am = v;
    }
    /**
     * The type attribute of the control.
    */
    get type() {
        return this.i.ab;
    }
    set type(v) {
        this.i.ab = ensureEnum(InputType_$type, v);
    }
    /**
     * The input mode attribute of the control.
     * See [relevant MDN article](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/inputmode)
    */
    get inputMode() {
        return this.i.ai;
    }
    set inputMode(v) {
        this.i.ai = v;
    }
    /**
     * The pattern attribute of the control.
    */
    get pattern() {
        return this.i.al;
    }
    set pattern(v) {
        this.i.al = v;
    }
    /**
     * The minimum string length required by the control.
    */
    get minLength() {
        return this.i.af;
    }
    set minLength(v) {
        this.i.af = +v;
    }
    /**
     * The maximum string length of the control.
    */
    get maxLength() {
        return this.i.ae;
    }
    set maxLength(v) {
        this.i.ae = +v;
    }
    /**
     * The min attribute of the control.
    */
    get min() {
        return this.i.ak;
    }
    set min(v) {
        this.i.ak = v;
    }
    /**
     * The max attribute of the control.
    */
    get max() {
        return this.i.aj;
    }
    set max(v) {
        this.i.aj = v;
    }
    /**
     * The step attribute of the control.
    */
    get step() {
        return this.i.ag;
    }
    set step(v) {
        this.i.ag = +v;
    }
    /**
     * The autofocus attribute of the control.
    */
    get autofocus() {
        return this.i.ac;
    }
    set autofocus(v) {
        this.i.ac = ensureBool(v);
    }
    /**
     * The autocomplete attribute of the control.
    */
    get autocomplete() {
        return this.i.ah;
    }
    set autocomplete(v) {
        this.i.ah = v;
    }
    /**
     * Enables validation rules to be evaluated without restricting user input. This applies to the `maxLength` property for
     * string-type inputs or allows spin buttons to exceed the predefined `min/max` limits for number-type inputs.
    */
    get validateOnly() {
        return this.i.ad;
    }
    set validateOnly(v) {
        this.i.ad = ensureBool(v);
    }
    /**
     * Selects all text within the input.
    
    */
    select() {
        this.i.ao();
    }
    /**
     * Increments the numeric value of the input by one or more steps.
    
    */
    stepUp(n) {
        this.i.aq(n);
    }
    /**
     * Decrements the numeric value of the input by one or more steps.
    
    */
    stepDown(n) {
        this.i.ap(n);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDataValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}
