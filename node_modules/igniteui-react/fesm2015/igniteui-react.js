/*!
    THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
    https://www.infragistics.com/legal/license/igultimate-la
    https://www.infragistics.com/legal/license/igultimate-eula
    GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
  */
  
import { Component, Children, cloneElement, createElement } from 'react';
import { markEnum, Base, markType, Dictionary$2, String_$type, Delegate_$type, typeCast, IList_$type, List$1, toSpinal, EnumBox, Boolean_$type, Type, EnumUtil, getBoxIfEnum, Tuple$2, Number_$type, INotifyCollectionChanged_$type, delegateCombine, runOn, fromEn, enumGetBox, TypeRegistrar, NamePatcher, PortalManager, ReactRenderer, isValidProp, getModifiedProps, ensureEnum, ensureBool, initializePropertiesFromCss, delegateRemove, EventArgs, interfaceToInternal, ObservableCollection$1, IgCollection, SyncableObservableCollection$2, SyncableObservableCollection$1, ReactTemplateAdapter } from 'igniteui-react-core';
import { defineComponents, IgcCalendarComponent, IgcDateTimeInputComponent, IgcButtonComponent, IgcDialogComponent, IgcIconComponent, IgcDatePickerComponent, IgcBannerComponent, IgcDividerComponent, IgcToggleButtonComponent, IgcButtonGroupComponent, IgcTextareaComponent, IgcAvatarComponent, IgcBadgeComponent, IgcRadioGroupComponent, IgcRadioComponent, IgcCardComponent, IgcCheckboxComponent, IgcInputComponent, IgcListHeaderComponent, IgcListItemComponent, IgcListComponent, IgcNavbarComponent, IgcRippleComponent, IgcSwitchComponent, IgcIconButtonComponent, IgcNavDrawerHeaderItemComponent, IgcNavDrawerItemComponent, IgcNavDrawerComponent, IgcCardActionsComponent, IgcCardContentComponent, IgcCardHeaderComponent, IgcCardMediaComponent, IgcRangeSliderComponent, IgcSliderComponent, IgcSliderLabelComponent, IgcChipComponent, IgcCircularGradientComponent, IgcCircularProgressComponent, IgcLinearProgressComponent, IgcRatingComponent, IgcRatingSymbolComponent, IgcSnackbarComponent, IgcToastComponent, IgcDropdownGroupComponent, IgcDropdownHeaderComponent, IgcDropdownItemComponent, IgcDropdownComponent, IgcExpansionPanelComponent, IgcMaskInputComponent, IgcTreeItemComponent, IgcTreeComponent, IgcTabComponent, IgcTabPanelComponent, IgcTabsComponent, IgcAccordionComponent, IgcComboComponent, IgcSelectItemComponent, IgcSelectGroupComponent, IgcSelectHeaderComponent, IgcSelectComponent, IgcStepComponent, IgcStepperComponent } from 'igniteui-webcomponents';
export { registerIcon, registerIconFromText, setIconRef } from 'igniteui-webcomponents';
import { defineCustomElements } from 'igniteui-dockmanager/loader';
import { html } from 'lit-html';

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBaseComboBoxLikeModule {
    static register() {
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var CalendarBaseSelection = /*@__PURE__*/ (function (CalendarBaseSelection) {
    CalendarBaseSelection[CalendarBaseSelection["Single"] = 0] = "Single";
    CalendarBaseSelection[CalendarBaseSelection["Multiple"] = 1] = "Multiple";
    CalendarBaseSelection[CalendarBaseSelection["Range"] = 2] = "Range";
    return CalendarBaseSelection;
})({});
/**
 * @hidden
 */
let CalendarBaseSelection_$type = /*@__PURE__*/ markEnum('CalendarBaseSelection', 'Single,0|Multiple,1|Range,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var WeekDays = /*@__PURE__*/ (function (WeekDays) {
    WeekDays[WeekDays["Sunday"] = 0] = "Sunday";
    WeekDays[WeekDays["Monday"] = 1] = "Monday";
    WeekDays[WeekDays["Tuesday"] = 2] = "Tuesday";
    WeekDays[WeekDays["Wednesday"] = 3] = "Wednesday";
    WeekDays[WeekDays["Thursday"] = 4] = "Thursday";
    WeekDays[WeekDays["Friday"] = 5] = "Friday";
    WeekDays[WeekDays["Saturday"] = 6] = "Saturday";
    return WeekDays;
})({});
/**
 * @hidden
 */
let WeekDays_$type = /*@__PURE__*/ markEnum('WeekDays', 'Sunday,0|Monday,1|Tuesday,2|Wednesday,3|Thursday,4|Friday,5|Saturday,6');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BaseElement = /*@__PURE__*/ (() => {
    class BaseElement extends Base {
    }
    BaseElement.$t = /*@__PURE__*/ markType(BaseElement, 'BaseElement');
    return BaseElement;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let WCNativeHelper = /*@__PURE__*/ (() => {
    class WCNativeHelper extends Base {
        constructor() {
            super(...arguments);
            this.e = null;
            this.a = new Dictionary$2(String_$type, Delegate_$type, 0);
            this.b = new Dictionary$2(String_$type, Delegate_$type, 0);
            this.d = new Dictionary$2(String_$type, Base.$, 0);
            this.c = new Dictionary$2(String_$type, Base.$, 0);
        }
        get o() {
            return this.e;
        }
        set o(a) {
            let val_ = a;
            if ((val_.___wcElement)) {
                val_ = val_.___wcElement;
            }
            this.e = val_;
        }
        n(propertyName_) {
            let target_ = this.o;
            let a = target_[propertyName_];
            return a;
        }
        m(propertyName_, a) {
            let target_ = this.o;
            let b = target_[propertyName_];
            b = this.g(b, a);
            return b;
        }
        k(propertyName_, a, b) {
            let target_ = this.o;
            let c = target_[propertyName_];
            if (c == null || c == undefined) {
                return null;
            }
            c = this.g(c, b);
            if (!(typeCast(IList_$type, c) !== null)) {
                let d = a(c);
                let e = c;
                for (let f = 0; f < e.length; f++) {
                    d.add(e[f]);
                }
                c = d;
            }
            return c;
        }
        l(propertyName_, a, b, c) {
            let target_ = this.o;
            let d = target_[propertyName_];
            if (d == null || d == undefined || !(typeCast(IList_$type, d) !== null)) {
                d = a(null);
            }
            let e = new List$1(String_$type, 0);
            for (let g = 0; g < c.length; g++) {
                let f = c[g];
                let h = "igc-" + toSpinal(f);
                e.add(h);
            }
            let i = new HtmlMarkupHelperCollection(target_, "igc", (j) => e.contains((j.tagName).toLowerCase()), d);
            return d;
        }
        g(obj_, a) {
            return WCNativeHelper.h(obj_, a);
        }
        static h(obj_, a) {
            if (obj_ == null || obj_ == undefined) {
                return null;
            }
            if (obj_ != null) {
                if ((obj_.___wcElement)) {
                    obj_ = obj_.___wcElement;
                }
            }
            if (obj_ != null) {
                if ((obj_._implementation) || ((obj_.nativeElement) && (obj_.setNativeElement))) {
                    return obj_;
                }
            }
            if (obj_ != null) {
                let arr_ = (Array.isArray(obj_) ? obj_ : null);
                if (arr_ != null) {
                    let b = new Array(arr_.length);
                    for (let c = 0; c < arr_.length; c++) {
                        b[c] = WCNativeHelper.h(arr_[c], a);
                    }
                    return b;
                }
            }
            let d = (obj_.externalObject);
            let ext_ = null;
            if (!d) {
                ext_ = a(obj_);
                if (ext_ != obj_) {
                    obj_.externalObject = ext_;
                    if ((ext_.setNativeElement)) {
                        ext_.setNativeElement(obj_);
                    }
                    else {
                        return obj_;
                    }
                }
            }
            else {
                ext_ = obj_.externalObject;
            }
            return ext_;
        }
        i(obj_) {
            return WCNativeHelper.j(obj_);
        }
        static j(obj_) {
            if (obj_ == null) {
                return obj_;
            }
            let arr_ = (Array.isArray(obj_) ? obj_ : null);
            if (arr_ != null) {
                let a = new Array(arr_.length);
                for (let b = 0; b < arr_.length; b++) {
                    a[b] = WCNativeHelper.j(arr_[b]);
                }
                return a;
            }
            if (obj_ != null && (obj_._implementation)) {
                obj_ = obj_._implementation;
            }
            if (obj_ != null && (obj_.$type) && (obj_.setNativeElement)) {
                obj_ = obj_.nativeElement;
            }
            if ((obj_ && obj_ instanceof EnumBox)) {
                obj_ = WCNativeHelper.camel(obj_.toString());
            }
            if (obj_ != null && (obj_._ngElementStrategy) && (obj_._ngElementStrategy.componentRef) && (obj_._ngElementStrategy.componentRef.instance)) {
                obj_ = obj_._ngElementStrategy.componentRef.instance;
            }
            return obj_;
        }
        w(propertyName_, value_) {
            let target_ = this.o;
            if (typeCast(Boolean_$type, value_) !== null && (target_ instanceof HTMLElement)) {
                let a = (toSpinal(propertyName_));
                let b = value_;
                if (b) {
                    target_.setAttribute(propertyName_, "");
                }
                else {
                    target_.removeAttribute(propertyName_);
                }
            }
            value_ = this.i(value_);
            if ((value_ && value_ instanceof EnumBox)) {
                value_ = value_.value;
            }
            target_[propertyName_] = value_;
        }
        static r(a) {
            if (a == null) {
                return a;
            }
            return a.substr(0, 1).toUpperCase() + a.substr(1);
        }
        static camel(a) {
            if (a == null) {
                return a;
            }
            return a.substr(0, 1).toLowerCase() + a.substr(1);
        }
        static getActualName(a) {
            return (a.getActualName());
        }
        s(a, b, c = true) {
            let wcName_ = "igc" + WCNativeHelper.r(a);
            if (!c) {
                wcName_ = a;
            }
            let d = null;
            let e = null;
            if (this.a.containsKey(a)) {
                d = this.a.item(a);
                e = this.b.item(a);
            }
            let f = b;
            let target_ = this.o;
            if (d != null) {
                let old_ = e;
                target_.removeEventListener(wcName_, old_);
                this.a.removeItem(a);
                this.b.removeItem(a);
            }
            if (f != null) {
                let nativeHandler_ = (ev_) => {
                    let g = null;
                    if (ev_ != null) {
                        g = ev_.detail;
                    }
                    f(g);
                };
                this.a.addItem(a, f);
                this.b.addItem(a, nativeHandler_);
                target_.addEventListener(wcName_, nativeHandler_);
            }
        }
        t(a, b, c) {
            let d = null;
            let e = null;
            if (this.d.containsKey(a)) {
                d = this.d.item(a);
                e = this.c.item(a);
            }
            let f = c;
            let target_ = this.o;
            let g = null;
            if (d != null) {
                let old_ = d;
                this.d.removeItem(a);
                this.c.removeItem(a);
                g = null;
            }
            if (f != null) {
                let nativeTemplate_ = (args_) => {
                    let h = (args_.externalObject);
                    let ext_ = null;
                    if (!h) {
                        ext_ = b(args_);
                        if (ext_ != args_) {
                            args_.externalObject = ext_;
                            ext_.setNativeElement(args_);
                        }
                    }
                    else {
                        ext_ = args_.externalObject;
                    }
                    return f(ext_);
                };
                this.u(nativeTemplate_, f);
                this.d.addItem(a, f);
                this.c.addItem(a, nativeTemplate_);
                g = nativeTemplate_;
            }
            this.w(a, g);
        }
        f($t, a) {
            if (typeof a === 'string') {
                let b = Type.createInstance($t);
                let c = EnumUtil.tryParse$1($t, a, true, b);
                b = c.p2;
                return getBoxIfEnum($t, b);
            }
            return a;
        }
        u(nativeTemplate_, newTemplate_) {
            if ((newTemplate_.___isBridged)) {
                nativeTemplate_.___isBridged = newTemplate_.___isBridged;
                nativeTemplate_.___templateId = newTemplate_.___templateId;
                nativeTemplate_.___containerId = newTemplate_.___containerId;
                nativeTemplate_.___container = newTemplate_.___container;
                nativeTemplate_.___onTemplateInit = newTemplate_.___onTemplateInit;
                nativeTemplate_.___onTemplateTeardown = newTemplate_.___onTemplateTeardown;
                nativeTemplate_.___checkHost = newTemplate_.___checkHost;
                nativeTemplate_.___onTemplateContextChanged = newTemplate_.___onTemplateContextChanged;
            }
        }
        v(a) {
            let wcName_ = "igc" + WCNativeHelper.r(a);
            let target_ = this.o;
            let b = null;
            let c = null;
            if (this.a.containsKey(a)) {
                b = this.a.item(a);
                c = this.b.item(a);
            }
            if (b != null) {
                let old_ = c;
                target_.removeEventListener(wcName_, old_);
                this.a.removeItem(a);
                this.b.removeItem(a);
            }
        }
    }
    WCNativeHelper.$t = /*@__PURE__*/ markType(WCNativeHelper, 'WCNativeHelper');
    return WCNativeHelper;
})();
/**
 * @hidden
 */
let HtmlMarkupHelperCollection = /*@__PURE__*/ (() => {
    class HtmlMarkupHelperCollection extends Base {
        get b() {
            let a = Array.from(this._target.children);
            return a;
        }
        a() {
            return this.c(this._target, 1);
        }
        c(a, b = 0) {
            let c = new List$1(Tuple$2.$.specialize(Number_$type, Base.$), 0);
            let d = (Array.from((a === null || a === void 0 ? void 0 : a.children) || []));
            for (let e = 0; e < d.length; e++) {
                let f = d[e];
                if (this.e(f)) {
                    c.add(new Tuple$2(Number_$type, Base.$, e, f));
                }
                else if (b >= 1) {
                    let g = getComputedStyle(f).getPropertyValue("display");
                    if (f.tagName.toLowerCase() == "div" && g != null && g.toLowerCase() == "none") {
                        let h = this.c(f, b - 1);
                        c.o(h);
                    }
                }
            }
            return c.toArray();
        }
        k() {
            let a = this.a();
            for (let b = 0; b < a.length; b++) {
                a[b].d.remove();
            }
        }
        n(a, b) {
            let c = this.a();
            if (a > c.length - 1 || a < 0) {
                return;
            }
            c[a].d.replaceWith(b);
            return;
        }
        m(a) {
            let b = this.a();
            if (a > b.length - 1 || a < 0) {
                return;
            }
            let c = b[a];
            c.d.remove();
        }
        l(a, b) {
            let c = this.a();
            if (c.length == 0) {
                this._target.append(b);
            }
            else {
                if (c.length - 1 < a) {
                    let d = c[c.length - 1].d;
                    d.after(b);
                    return;
                }
                let e = c[a].d;
                e.after(b);
            }
        }
        j(a) {
            let b = this.a();
            if (b.length == 0) {
                this._target.append(a);
            }
            else {
                let c = b[b.length - 1].d;
                c.after(a);
            }
        }
        constructor(a, b, c, d) {
            super();
            this._target = null;
            this.e = null;
            this.d = null;
            this._target = a;
            this.e = c;
            this.d = d;
            this.h();
            if (typeCast(INotifyCollectionChanged_$type, this.d) !== null) {
                let e = this.d;
                e.collectionChanged = delegateCombine(e.collectionChanged, runOn(this, this.i));
            }
        }
        h() {
            let a = this.a();
            for (let c = 0; c < a.length; c++) {
                let b = a[c];
                this.d.add(b.d);
            }
        }
        g(a) {
            return WCNativeHelper.j(a);
        }
        i(a, b) {
            switch (b.action) {
                case 0:
                    if (b.newItems != null) {
                        for (let c = 0; c < b.newItems.count; c++) {
                            let d = b.newItems.item(c);
                            this.l(c + b.newStartingIndex, this.g(d));
                        }
                    }
                    break;
                case 1:
                    if (b.oldItems != null) {
                        for (let e = 0; e < b.oldItems.count; e++) {
                            this.m(b.oldStartingIndex);
                        }
                    }
                    break;
                case 2:
                    if (b.oldItems != null) {
                        for (let f = 0; f < b.oldItems.count; f++) {
                            this.m(b.oldStartingIndex);
                        }
                    }
                    if (b.newItems != null) {
                        for (let g = 0; g < b.newItems.count; g++) {
                            let h = b.newItems.item(g);
                            this.l(g + b.newStartingIndex, this.g(b.newItems.item(g)));
                        }
                    }
                    break;
                case 4:
                    this.k();
                    for (let i of fromEn(this.d)) {
                        let j = i;
                        this.j(this.g(j));
                    }
                    break;
            }
        }
    }
    HtmlMarkupHelperCollection.$t = /*@__PURE__*/ markType(HtmlMarkupHelperCollection, 'HtmlMarkupHelperCollection');
    return HtmlMarkupHelperCollection;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let IDateRangeDescriptor_$type = /*@__PURE__*/ new Type(null, 'IDateRangeDescriptor');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DateRangeDescriptor = /*@__PURE__*/ (() => {
    class DateRangeDescriptor extends Base {
        constructor() {
            super(...arguments);
            this._rangeType = 0;
            this._dateRange = null;
        }
        get rangeType() {
            return this._rangeType;
        }
        set rangeType(a) {
            this._rangeType = a;
        }
        get dateRange() {
            return this._dateRange;
        }
        set dateRange(a) {
            this._dateRange = a;
        }
    }
    DateRangeDescriptor.$t = /*@__PURE__*/ markType(DateRangeDescriptor, 'DateRangeDescriptor', Base.$, [IDateRangeDescriptor_$type]);
    return DateRangeDescriptor;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CalendarBase = /*@__PURE__*/ (() => {
    class CalendarBase extends BaseElement {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.h = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.h;
        }
        set nativeElement(a) {
            this.h = a;
            this.d.o = this.h;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.e.n("selection");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(CalendarBaseSelection_$type, EnumUtil.getEnumValue(CalendarBaseSelection_$type, this.e.f(CalendarBaseSelection_$type, ret_)));
            return EnumUtil.getEnumValue(CalendarBaseSelection_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(CalendarBaseSelection_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("selection", value_);
        }
        get g() {
            let ret_ = this.e.n("showWeekNumbers");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.e.w("showWeekNumbers", value_);
        }
        get f() {
            let ret_ = this.e.n("weekStart");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(WeekDays_$type, EnumUtil.getEnumValue(WeekDays_$type, this.e.f(WeekDays_$type, ret_)));
            return EnumUtil.getEnumValue(WeekDays_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(WeekDays_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("weekStart", value_);
        }
        get j() {
            let ret_ = this.e.n("locale");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.e.w("locale", value_);
        }
        get b() {
            let ret_ = this.e.m("specialDates", (a) => new DateRangeDescriptor());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.e.w("specialDates", value_);
        }
        get a() {
            let ret_ = this.e.m("disabledDates", (a) => new DateRangeDescriptor());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.e.w("disabledDates", value_);
        }
    }
    CalendarBase.$t = /*@__PURE__*/ markType(CalendarBase, 'CalendarBase', BaseElement.$);
    return CalendarBase;
})();

class IgrCalendarBase extends Component {
    createImplementation() {
        return new CalendarBase();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-calendar-base", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Sets the type of selection in the component.
    */
    get selection() {
        return this.i.c;
    }
    set selection(v) {
        this.i.c = ensureEnum(CalendarBaseSelection_$type, v);
    }
    /**
     * Whether to show the week numbers.
    */
    get showWeekNumbers() {
        return this.i.g;
    }
    set showWeekNumbers(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * Gets/Sets the first day of the week.
    */
    get weekStart() {
        return this.i.f;
    }
    set weekStart(v) {
        this.i.f = ensureEnum(WeekDays_$type, v);
    }
    /**
     * Gets/Sets the locale used for formatting and displaying the dates in the component.
    */
    get locale() {
        return this.i.j;
    }
    set locale(v) {
        this.i.j = v;
    }
    /**
     * Gets/Sets the special dates for the component.
    */
    get specialDates() {
        return this.i.b;
    }
    set specialDates(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.b = v;
    }
    /**
     * Gets/Sets the disabled dates for the component.
    */
    get disabledDates() {
        return this.i.a;
    }
    set disabledDates(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.a = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("CalendarBase");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCalendarBaseModule {
    static register() {
        TypeRegistrar.registerCons('IgrCalendarBase', IgrCalendarBase);
        TypeRegistrar.registerCons('IgrCalendarBase', IgrCalendarBase);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ComponentDataValueChangedEventArgs = /*@__PURE__*/ (() => {
    class ComponentDataValueChangedEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new ComponentDataValueChangedEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    ComponentDataValueChangedEventArgs.$t = /*@__PURE__*/ markType(ComponentDataValueChangedEventArgs, 'ComponentDataValueChangedEventArgs');
    return ComponentDataValueChangedEventArgs;
})();

class IgrComponentDataValueChangedEventArgs {
    createImplementation() {
        return new ComponentDataValueChangedEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        return this.i.b;
    }
    set detail(v) {
        this.i.b = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var CalendarHeaderOrientation = /*@__PURE__*/ (function (CalendarHeaderOrientation) {
    CalendarHeaderOrientation[CalendarHeaderOrientation["Horizontal"] = 0] = "Horizontal";
    CalendarHeaderOrientation[CalendarHeaderOrientation["Vertical"] = 1] = "Vertical";
    return CalendarHeaderOrientation;
})({});
/**
 * @hidden
 */
let CalendarHeaderOrientation_$type = /*@__PURE__*/ markEnum('CalendarHeaderOrientation', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var CalendarOrientation = /*@__PURE__*/ (function (CalendarOrientation) {
    CalendarOrientation[CalendarOrientation["Horizontal"] = 0] = "Horizontal";
    CalendarOrientation[CalendarOrientation["Vertical"] = 1] = "Vertical";
    return CalendarOrientation;
})({});
/**
 * @hidden
 */
let CalendarOrientation_$type = /*@__PURE__*/ markEnum('CalendarOrientation', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var CalendarActiveView = /*@__PURE__*/ (function (CalendarActiveView) {
    CalendarActiveView[CalendarActiveView["Days"] = 0] = "Days";
    CalendarActiveView[CalendarActiveView["Months"] = 1] = "Months";
    CalendarActiveView[CalendarActiveView["Years"] = 2] = "Years";
    return CalendarActiveView;
})({});
/**
 * @hidden
 */
let CalendarActiveView_$type = /*@__PURE__*/ markEnum('CalendarActiveView', 'Days,0|Months,1|Years,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CalendarFormatOptions = /*@__PURE__*/ (() => {
    class CalendarFormatOptions extends Base {
        constructor() {
            super(...arguments);
            this._weekday = null;
            this._month = null;
        }
        get weekday() {
            return this._weekday;
        }
        set weekday(a) {
            this._weekday = a;
        }
        get month() {
            return this._month;
        }
        set month(a) {
            this._month = a;
        }
    }
    CalendarFormatOptions.$t = /*@__PURE__*/ markType(CalendarFormatOptions, 'CalendarFormatOptions');
    return CalendarFormatOptions;
})();

class IgrCalendarFormatOptions {
    createImplementation() {
        return new CalendarFormatOptions();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get weekday() {
        return this.i.weekday;
    }
    set weekday(v) {
        this.i.weekday = v;
    }
    get month() {
        return this.i.month;
    }
    set month(v) {
        this.i.month = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CalendarResourceStrings = /*@__PURE__*/ (() => {
    class CalendarResourceStrings extends Base {
        constructor() {
            super(...arguments);
            this.j = null;
            this.l = null;
            this.h = null;
            this.k = null;
            this.i = null;
            this.m = null;
            this.a = null;
            this.e = null;
            this.b = null;
            this.f = null;
            this.c = null;
            this.g = null;
            this.d = null;
            this.n = null;
        }
    }
    CalendarResourceStrings.$t = /*@__PURE__*/ markType(CalendarResourceStrings, 'CalendarResourceStrings');
    return CalendarResourceStrings;
})();

class IgrCalendarResourceStrings {
    createImplementation() {
        return new CalendarResourceStrings();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get selectMonth() {
        return this.i.j;
    }
    set selectMonth(v) {
        this.i.j = v;
    }
    get selectYear() {
        return this.i.l;
    }
    set selectYear(v) {
        this.i.l = v;
    }
    get selectDate() {
        return this.i.h;
    }
    set selectDate(v) {
        this.i.h = v;
    }
    get selectRange() {
        return this.i.k;
    }
    set selectRange(v) {
        this.i.k = v;
    }
    get selectedDate() {
        return this.i.i;
    }
    set selectedDate(v) {
        this.i.i = v;
    }
    get startDate() {
        return this.i.m;
    }
    set startDate(v) {
        this.i.m = v;
    }
    get endDate() {
        return this.i.a;
    }
    set endDate(v) {
        this.i.a = v;
    }
    get previousMonth() {
        return this.i.e;
    }
    set previousMonth(v) {
        this.i.e = v;
    }
    get nextMonth() {
        return this.i.b;
    }
    set nextMonth(v) {
        this.i.b = v;
    }
    get previousYear() {
        return this.i.f;
    }
    set previousYear(v) {
        this.i.f = v;
    }
    get nextYear() {
        return this.i.c;
    }
    set nextYear(v) {
        this.i.c = v;
    }
    get previousYears() {
        return this.i.g;
    }
    set previousYears(v) {
        this.i.g = v;
    }
    get nextYears() {
        return this.i.d;
    }
    set nextYears(v) {
        this.i.d = v;
    }
    get weekLabel() {
        return this.i.n;
    }
    set weekLabel(v) {
        this.i.n = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Calendar = /*@__PURE__*/ (() => {
    class Calendar extends CalendarBase {
        constructor() {
            super(...arguments);
            this.change = null;
        }
        get v() {
            let ret_ = this.e.n("value");
            return ret_;
        }
        set v(a) {
            let value_ = a;
            this.e.w("value", value_);
        }
        get l() {
            let ret_ = this.e.n("values");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.e.w("values", value_);
        }
        get u() {
            let ret_ = this.e.n("activeDate");
            return ret_;
        }
        set u(a) {
            let value_ = a;
            this.e.w("activeDate", value_);
        }
        get t() {
            let ret_ = this.e.n("hideOutsideDays");
            return ret_;
        }
        set t(a) {
            let value_ = a;
            this.e.w("hideOutsideDays", value_);
        }
        get s() {
            let ret_ = this.e.n("hideHeader");
            return ret_;
        }
        set s(a) {
            let value_ = a;
            this.e.w("hideHeader", value_);
        }
        get o() {
            let ret_ = this.e.n("headerOrientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(CalendarHeaderOrientation_$type, EnumUtil.getEnumValue(CalendarHeaderOrientation_$type, this.e.f(CalendarHeaderOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(CalendarHeaderOrientation_$type, ret_);
        }
        set o(a) {
            let value_ = enumGetBox(CalendarHeaderOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("headerOrientation", value_);
        }
        get p() {
            let ret_ = this.e.n("orientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(CalendarOrientation_$type, EnumUtil.getEnumValue(CalendarOrientation_$type, this.e.f(CalendarOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(CalendarOrientation_$type, ret_);
        }
        set p(a) {
            let value_ = enumGetBox(CalendarOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("orientation", value_);
        }
        get w() {
            let ret_ = this.e.n("visibleMonths");
            return ret_;
        }
        set w(a) {
            let value_ = a;
            this.e.w("visibleMonths", value_);
        }
        get m() {
            let ret_ = this.e.n("activeView");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(CalendarActiveView_$type, EnumUtil.getEnumValue(CalendarActiveView_$type, this.e.f(CalendarActiveView_$type, ret_)));
            return EnumUtil.getEnumValue(CalendarActiveView_$type, ret_);
        }
        set m(a) {
            let value_ = enumGetBox(CalendarActiveView_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("activeView", value_);
        }
        get n() {
            let ret_ = this.e.m("formatOptions", (a) => new CalendarFormatOptions());
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.e.w("formatOptions", value_);
        }
        get q() {
            let ret_ = this.e.m("resourceStrings", (a) => new CalendarResourceStrings());
            return ret_;
        }
        set q(a) {
            let value_ = a;
            this.e.w("resourceStrings", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.e.s("change", (a) => this.change(this, ComponentDataValueChangedEventArgs.a(a)));
            }
            else {
                this.e.v("change");
            }
        }
    }
    Calendar.$t = /*@__PURE__*/ markType(Calendar, 'Calendar', CalendarBase.$);
    return Calendar;
})();

/**
 * Represents a calendar that lets users
 * to select a date value in a variety of different ways.
*/
class IgrCalendar extends IgrCalendarBase {
    createImplementation() {
        return new Calendar();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCalendarComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-calendar", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    get value() {
        return this.i.v;
    }
    set value(v) {
        this.i.v = v;
    }
    get values() {
        return this.i.l;
    }
    set values(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.l = v;
    }
    /**
     * Sets the date which is shown in view and is highlighted. By default it is the current date.
    */
    get activeDate() {
        return this.i.u;
    }
    set activeDate(v) {
        this.i.u = v;
    }
    /**
     * Whether to show the dates that do not belong to the current active month.
    */
    get hideOutsideDays() {
        return this.i.t;
    }
    set hideOutsideDays(v) {
        this.i.t = ensureBool(v);
    }
    /**
     * Whether to render the calendar header part.
     * When the calendar selection is set to `multiple` the header is always hidden.
    */
    get hideHeader() {
        return this.i.s;
    }
    set hideHeader(v) {
        this.i.s = ensureBool(v);
    }
    /**
     * The orientation of the calendar header.
    */
    get headerOrientation() {
        return this.i.o;
    }
    set headerOrientation(v) {
        this.i.o = ensureEnum(CalendarHeaderOrientation_$type, v);
    }
    /**
     * The orientation of the calendar months when more than one month
     * is being shown.
    */
    get orientation() {
        return this.i.p;
    }
    set orientation(v) {
        this.i.p = ensureEnum(CalendarOrientation_$type, v);
    }
    /**
     * The number of months displayed in the days view.
    */
    get visibleMonths() {
        return this.i.w;
    }
    set visibleMonths(v) {
        this.i.w = +v;
    }
    /**
     * The current active view of the component.
    */
    get activeView() {
        return this.i.m;
    }
    set activeView(v) {
        this.i.m = ensureEnum(CalendarActiveView_$type, v);
    }
    /**
     * The options used to format the months and the weekdays in the calendar views.
    */
    get formatOptions() {
        const r = this.i.n;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrCalendarFormatOptions();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set formatOptions(v) {
        v == null ? this.i.n = null : this.i.n = v.i;
    }
    /**
     * The resource strings for localization.
    */
    get resourceStrings() {
        const r = this.i.q;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrCalendarResourceStrings();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set resourceStrings(v) {
        v == null ? this.i.q = null : this.i.q = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.formatOptions && this.formatOptions.name && this.formatOptions.name == name) {
            return this.formatOptions;
        }
        if (this.resourceStrings && this.resourceStrings.name && this.resourceStrings.name == name) {
            return this.resourceStrings;
        }
        return null;
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDataValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCalendarModule {
    static register() {
        IgrCalendarBaseModule.register();
        TypeRegistrar.registerCons('IgrComponentDataValueChangedEventArgs', IgrComponentDataValueChangedEventArgs);
        TypeRegistrar.registerCons('IgrCalendar', IgrCalendar);
        TypeRegistrar.registerCons('IgrCalendar', IgrCalendar);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrInputBaseModule {
    static register() {
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrMaskInputBaseModule {
    static register() {
        IgrInputBaseModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DatePartDeltas = /*@__PURE__*/ (() => {
    class DatePartDeltas extends Base {
        constructor() {
            super(...arguments);
            this.a = 0;
            this.d = 0;
            this.f = 0;
            this.b = 0;
            this.c = 0;
            this.e = 0;
        }
    }
    DatePartDeltas.$t = /*@__PURE__*/ markType(DatePartDeltas, 'DatePartDeltas');
    return DatePartDeltas;
})();

class IgrDatePartDeltas {
    createImplementation() {
        return new DatePartDeltas();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get date() {
        return this.i.a;
    }
    set date(v) {
        this.i.a = +v;
    }
    get month() {
        return this.i.d;
    }
    set month(v) {
        this.i.d = +v;
    }
    get year() {
        return this.i.f;
    }
    set year(v) {
        this.i.f = +v;
    }
    get hours() {
        return this.i.b;
    }
    set hours(v) {
        this.i.b = +v;
    }
    get minutes() {
        return this.i.c;
    }
    set minutes(v) {
        this.i.c = +v;
    }
    get seconds() {
        return this.i.e;
    }
    set seconds(v) {
        this.i.e = +v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ComponentDateValueChangedEventArgs = /*@__PURE__*/ (() => {
    class ComponentDateValueChangedEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = new Date();
        }
        static a(a) {
            return ((() => {
                let $ret = new ComponentDateValueChangedEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    ComponentDateValueChangedEventArgs.$t = /*@__PURE__*/ markType(ComponentDateValueChangedEventArgs, 'ComponentDateValueChangedEventArgs');
    return ComponentDateValueChangedEventArgs;
})();

class IgrComponentDateValueChangedEventArgs {
    createImplementation() {
        return new ComponentDateValueChangedEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        return this.i.b;
    }
    set detail(v) {
        this.i.b = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ComponentValueChangedEventArgs = /*@__PURE__*/ (() => {
    class ComponentValueChangedEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new ComponentValueChangedEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    ComponentValueChangedEventArgs.$t = /*@__PURE__*/ markType(ComponentValueChangedEventArgs, 'ComponentValueChangedEventArgs');
    return ComponentValueChangedEventArgs;
})();

class IgrComponentValueChangedEventArgs {
    createImplementation() {
        return new ComponentValueChangedEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        return this.i.b;
    }
    set detail(v) {
        this.i.b = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let VoidEventArgs = /*@__PURE__*/ (() => {
    class VoidEventArgs extends EventArgs {
        static b(a) {
            return new VoidEventArgs();
        }
    }
    VoidEventArgs.$t = /*@__PURE__*/ markType(VoidEventArgs, 'VoidEventArgs', EventArgs.$);
    return VoidEventArgs;
})();

class IgrVoidEventArgs {
    createImplementation() {
        return new VoidEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
}

class IgrInputBase extends Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._inputOcurred = null;
        this._inputOcurred_wrapped = null;
        this._focus = null;
        this._focus_wrapped = null;
        this._blur = null;
        this._blur_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
     * Whether the control will have outlined appearance.
    */
    get outlined() {
        return this.i.h;
    }
    set outlined(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Makes the control a readonly field.
    */
    get readOnly() {
        return this.i.i;
    }
    set readOnly(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * The placeholder attribute of the control.
    */
    get placeholder() {
        return this.i.o;
    }
    set placeholder(v) {
        this.i.o = v;
    }
    /**
     * The label for the control.
    */
    get label() {
        return this.i.m;
    }
    set label(v) {
        this.i.m = v;
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.f;
    }
    set disabled(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.j;
    }
    set required(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.n;
    }
    set name(v) {
        this.i.n = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.g;
    }
    set invalid(v) {
        this.i.g = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("InputBase");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Sets focus on the control.
    
    */
    focusComponent(options) {
        this.i.t((options == null ? null : options.i));
    }
    /**
     * Removes focus from the control.
    
    */
    blurComponent() {
        this.i.q();
    }
    setSelectionRange(start, end, direction) {
        this.i.z(start, end, (direction == null ? null : direction));
    }
    setRangeText(replacement, start, end, selectMode) {
        this.i.y(replacement, start, end, (selectMode == null ? null : selectMode));
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.v();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.r();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.w(message);
    }
    get inputOcurred() {
        return this._inputOcurred;
    }
    set inputOcurred(ev) {
        if (this._inputOcurred_wrapped !== null) {
            this.i.inputOcurred = delegateRemove(this.i.inputOcurred, this._inputOcurred_wrapped);
            this._inputOcurred_wrapped = null;
            this._inputOcurred = null;
        }
        this._inputOcurred = ev;
        this._inputOcurred_wrapped = (o, e) => {
            let outerArgs = new IgrComponentValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeInputOcurred) {
                this.beforeInputOcurred(this, outerArgs);
            }
            if (this._inputOcurred) {
                this._inputOcurred(this, outerArgs);
            }
        };
        this.i.inputOcurred = delegateCombine(this.i.inputOcurred, this._inputOcurred_wrapped);
        if (this.i.inputOcurredChanged) {
            this.i.inputOcurredChanged();
        }
        ;
    }
    get focus() {
        return this._focus;
    }
    set focus(ev) {
        if (this._focus_wrapped !== null) {
            this.i.focus = delegateRemove(this.i.focus, this._focus_wrapped);
            this._focus_wrapped = null;
            this._focus = null;
        }
        this._focus = ev;
        this._focus_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFocus) {
                this.beforeFocus(this, outerArgs);
            }
            if (this._focus) {
                this._focus(this, outerArgs);
            }
        };
        this.i.focus = delegateCombine(this.i.focus, this._focus_wrapped);
        if (this.i.focusChanged) {
            this.i.focusChanged();
        }
        ;
    }
    get blur() {
        return this._blur;
    }
    set blur(ev) {
        if (this._blur_wrapped !== null) {
            this.i.blur = delegateRemove(this.i.blur, this._blur_wrapped);
            this._blur_wrapped = null;
            this._blur = null;
        }
        this._blur = ev;
        this._blur_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeBlur) {
                this.beforeBlur(this, outerArgs);
            }
            if (this._blur) {
                this._blur(this, outerArgs);
            }
        };
        this.i.blur = delegateCombine(this.i.blur, this._blur_wrapped);
        if (this.i.blurChanged) {
            this.i.blurChanged();
        }
        ;
    }
}

class IgrMaskInputBase extends IgrInputBase {
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    /**
     * The prompt symbol to use for unfilled parts of the mask.
    */
    get prompt() {
        return this.i.aa;
    }
    set prompt(v) {
        this.i.aa = v;
    }
    connectedCallback() {
        this.i.ab();
    }
    /**
     * Selects all text within the input.
    
    */
    select() {
        this.i.ac();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var SelectionRangeDirection = /*@__PURE__*/ (function (SelectionRangeDirection) {
    SelectionRangeDirection[SelectionRangeDirection["None"] = 0] = "None";
    SelectionRangeDirection[SelectionRangeDirection["Backward"] = 1] = "Backward";
    SelectionRangeDirection[SelectionRangeDirection["Forward"] = 2] = "Forward";
    return SelectionRangeDirection;
})({});
/**
 * @hidden
 */
let SelectionRangeDirection_$type = /*@__PURE__*/ markEnum('SelectionRangeDirection', 'None,0|Backward,1|Forward,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var RangeTextSelectMode = /*@__PURE__*/ (function (RangeTextSelectMode) {
    RangeTextSelectMode[RangeTextSelectMode["Preserve"] = 0] = "Preserve";
    RangeTextSelectMode[RangeTextSelectMode["Select"] = 1] = "Select";
    RangeTextSelectMode[RangeTextSelectMode["Start"] = 2] = "Start";
    RangeTextSelectMode[RangeTextSelectMode["End"] = 3] = "End";
    return RangeTextSelectMode;
})({});
/**
 * @hidden
 */
let RangeTextSelectMode_$type = /*@__PURE__*/ markEnum('RangeTextSelectMode', 'Preserve,0|Select,1|Start,2|End,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let InputBase = /*@__PURE__*/ (() => {
    class InputBase extends BaseElement {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.k = null;
            this.inputOcurred = null;
            this.focus = null;
            this.blur = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.k;
        }
        set nativeElement(a) {
            this.k = a;
            this.d.o = this.k;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get h() {
            let ret_ = this.e.n("outlined");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.e.w("outlined", value_);
        }
        get i() {
            let ret_ = this.e.n("readOnly");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.e.w("readOnly", value_);
        }
        get o() {
            let ret_ = this.e.n("placeholder");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.e.w("placeholder", value_);
        }
        get m() {
            let ret_ = this.e.n("label");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.e.w("label", value_);
        }
        get f() {
            let ret_ = this.e.n("disabled");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.e.w("disabled", value_);
        }
        get j() {
            let ret_ = this.e.n("required");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.e.w("required", value_);
        }
        get n() {
            let ret_ = this.e.n("name");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.e.w("name", value_);
        }
        get g() {
            let ret_ = this.e.n("invalid");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.e.w("invalid", value_);
        }
        inputOcurredChanged() {
            if (this.inputOcurred != null) {
                this.e.s("input", (a) => this.inputOcurred(this, ComponentValueChangedEventArgs.a(a)));
            }
            else {
                this.e.v("input");
            }
        }
        focusChanged() {
            if (this.focus != null) {
                this.e.s("focus", (a) => this.focus(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.e.v("focus");
            }
        }
        blurChanged() {
            if (this.blur != null) {
                this.e.s("blur", (a) => this.blur(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.e.v("blur");
            }
        }
        t(a) {
            this.nativeElement.focus(this.e.i(a));
        }
        q() {
            this.nativeElement.blur();
        }
        z(a, b, c) {
            this.nativeElement.setSelectionRange(this.e.i(a), this.e.i(b), this.e.i(enumGetBox(SelectionRangeDirection_$type, c)));
        }
        y(a, b, c, d) {
            this.nativeElement.setRangeText(this.e.i(a), this.e.i(b), this.e.i(c), this.e.i(enumGetBox(RangeTextSelectMode_$type, d)));
        }
        v() {
            this.nativeElement.reportValidity();
        }
        r() {
            this.nativeElement.checkValidity();
        }
        w(a) {
            this.nativeElement.setCustomValidity(this.e.i(a));
        }
    }
    InputBase.$t = /*@__PURE__*/ markType(InputBase, 'InputBase', BaseElement.$);
    return InputBase;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let MaskInputBase = /*@__PURE__*/ (() => {
    class MaskInputBase extends InputBase {
        get aa() {
            let ret_ = this.e.n("prompt");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.e.w("prompt", value_);
        }
        ab() {
            this.nativeElement.connectedCallback();
        }
        ac() {
            this.nativeElement.select();
        }
    }
    MaskInputBase.$t = /*@__PURE__*/ markType(MaskInputBase, 'MaskInputBase', InputBase.$);
    return MaskInputBase;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DatePart = /*@__PURE__*/ (function (DatePart) {
    DatePart[DatePart["Month"] = 0] = "Month";
    DatePart[DatePart["Year"] = 1] = "Year";
    DatePart[DatePart["Date"] = 2] = "Date";
    DatePart[DatePart["Hours"] = 3] = "Hours";
    DatePart[DatePart["Minutes"] = 4] = "Minutes";
    DatePart[DatePart["Seconds"] = 5] = "Seconds";
    DatePart[DatePart["AmPm"] = 6] = "AmPm";
    return DatePart;
})({});
/**
 * @hidden
 */
let DatePart_$type = /*@__PURE__*/ markEnum('DatePart', 'Month:month,0|Year:year,1|Date:date,2|Hours:hours,3|Minutes:minutes,4|Seconds:seconds,5|AmPm:amPm,6');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DateTimeInput = /*@__PURE__*/ (() => {
    class DateTimeInput extends MaskInputBase {
        constructor() {
            super(...arguments);
            this.change = null;
        }
        get ak() {
            let ret_ = this.e.n("inputFormat");
            return ret_;
        }
        set ak(a) {
            let value_ = a;
            this.e.w("inputFormat", value_);
        }
        get ai() {
            let ret_ = this.e.n("value");
            return ret_;
        }
        set ai(a) {
            let value_ = a;
            this.e.w("value", value_);
        }
        get ah() {
            let ret_ = this.e.n("min");
            return ret_;
        }
        set ah(a) {
            let value_ = a;
            this.e.w("min", value_);
        }
        get ag() {
            let ret_ = this.e.n("max");
            return ret_;
        }
        set ag(a) {
            let value_ = a;
            this.e.w("max", value_);
        }
        get aj() {
            let ret_ = this.e.n("displayFormat");
            return ret_;
        }
        set aj(a) {
            let value_ = a;
            this.e.w("displayFormat", value_);
        }
        get ae() {
            let ret_ = this.e.m("spinDelta", (a) => new DatePartDeltas());
            return ret_;
        }
        set ae(a) {
            let value_ = a;
            this.e.w("spinDelta", value_);
        }
        get af() {
            let ret_ = this.e.n("spinLoop");
            return ret_;
        }
        set af(a) {
            let value_ = a;
            this.e.w("spinLoop", value_);
        }
        get al() {
            let ret_ = this.e.n("locale");
            return ret_;
        }
        set al(a) {
            let value_ = a;
            this.e.w("locale", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.e.s("change", (a) => this.change(this, ComponentDateValueChangedEventArgs.a(a)));
            }
            else {
                this.e.v("change");
            }
        }
        ao() {
            this.nativeElement.connectedCallback();
        }
        aq(a, b = -1) {
            this.nativeElement.stepUp(this.e.i(enumGetBox(DatePart_$type, a)), this.e.i(b));
        }
        ap(a, b = -1) {
            this.nativeElement.stepDown(this.e.i(enumGetBox(DatePart_$type, a)), this.e.i(b));
        }
        an() {
            this.nativeElement.clear();
        }
    }
    DateTimeInput.$t = /*@__PURE__*/ markType(DateTimeInput, 'DateTimeInput', MaskInputBase.$);
    return DateTimeInput;
})();

/**
 * A date time input is an input field that lets you set and edit the date and time in a chosen input element
 * using customizable display and input formats.
*/
class IgrDateTimeInput extends IgrMaskInputBase {
    createImplementation() {
        return new DateTimeInput();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDateTimeInputComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-date-time-input", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    get inputFormat() {
        return this.i.ak;
    }
    set inputFormat(v) {
        this.i.ak = v;
    }
    /**
     * The value of the input.
    */
    get value() {
        return this.i.ai;
    }
    set value(v) {
        this.i.ai = v;
    }
    /**
     * The minimum value required for the input to remain valid.
    */
    get min() {
        return this.i.ah;
    }
    set min(v) {
        this.i.ah = v;
    }
    /**
     * The maximum value required for the input to remain valid.
    */
    get max() {
        return this.i.ag;
    }
    set max(v) {
        this.i.ag = v;
    }
    /**
     * Format to display the value in when not editing.
     * Defaults to the input format if not set.
    */
    get displayFormat() {
        return this.i.aj;
    }
    set displayFormat(v) {
        this.i.aj = v;
    }
    /**
     * Delta values used to increment or decrement each date part on step actions.
     * All values default to `1`.
    */
    get spinDelta() {
        const r = this.i.ae;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDatePartDeltas();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set spinDelta(v) {
        v == null ? this.i.ae = null : this.i.ae = v.i;
    }
    /**
     * Sets whether to loop over the currently spun segment.
    */
    get spinLoop() {
        return this.i.af;
    }
    set spinLoop(v) {
        this.i.af = ensureBool(v);
    }
    /**
     * The locale settings used to display the value.
    */
    get locale() {
        return this.i.al;
    }
    set locale(v) {
        this.i.al = v;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.spinDelta && this.spinDelta.name && this.spinDelta.name == name) {
            return this.spinDelta;
        }
        return null;
    }
    connectedCallback() {
        this.i.ao();
    }
    stepUp(datePart, delta) {
        this.i.aq((datePart == null ? null : datePart), delta);
    }
    stepDown(datePart, delta) {
        this.i.ap((datePart == null ? null : datePart), delta);
    }
    /**
     * Clears the input element of user input.
    
    */
    clear() {
        this.i.an();
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDateValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDateTimeInputModule {
    static register() {
        IgrMaskInputBaseModule.register();
        TypeRegistrar.registerCons('IgrDateTimeInput', IgrDateTimeInput);
        TypeRegistrar.registerCons('IgrDateTimeInput', IgrDateTimeInput);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrButtonBaseModule {
    static register() {
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ButtonVariant = /*@__PURE__*/ (function (ButtonVariant) {
    ButtonVariant[ButtonVariant["Flat"] = 0] = "Flat";
    ButtonVariant[ButtonVariant["Contained"] = 1] = "Contained";
    ButtonVariant[ButtonVariant["Outlined"] = 2] = "Outlined";
    ButtonVariant[ButtonVariant["Fab"] = 3] = "Fab";
    return ButtonVariant;
})({});
/**
 * @hidden
 */
let ButtonVariant_$type = /*@__PURE__*/ markEnum('ButtonVariant', 'Flat,0|Contained,1|Outlined,2|Fab,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ButtonBaseType = /*@__PURE__*/ (function (ButtonBaseType) {
    ButtonBaseType[ButtonBaseType["Button"] = 0] = "Button";
    ButtonBaseType[ButtonBaseType["Reset"] = 1] = "Reset";
    ButtonBaseType[ButtonBaseType["Submit"] = 2] = "Submit";
    return ButtonBaseType;
})({});
/**
 * @hidden
 */
let ButtonBaseType_$type = /*@__PURE__*/ markEnum('ButtonBaseType', 'Button,0|Reset,1|Submit,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ButtonBaseTarget = /*@__PURE__*/ (function (ButtonBaseTarget) {
    ButtonBaseTarget[ButtonBaseTarget["_blank"] = 0] = "_blank";
    ButtonBaseTarget[ButtonBaseTarget["_parent"] = 1] = "_parent";
    ButtonBaseTarget[ButtonBaseTarget["_self"] = 2] = "_self";
    ButtonBaseTarget[ButtonBaseTarget["_top"] = 3] = "_top";
    return ButtonBaseTarget;
})({});
/**
 * @hidden
 */
let ButtonBaseTarget_$type = /*@__PURE__*/ markEnum('ButtonBaseTarget', '_blank,0|_parent,1|_self,2|_top,3');

class IgrButtonBase extends Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._clicked = null;
        this._clicked_wrapped = null;
        this._focus = null;
        this._focus_wrapped = null;
        this._blur = null;
        this._blur_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
     * The type of the button. Defaults to `button`.
    */
    get type() {
        return this.i.b;
    }
    set type(v) {
        this.i.b = ensureEnum(ButtonBaseType_$type, v);
    }
    /**
     * The URL the button points to.
    */
    get href() {
        return this.i.m;
    }
    set href(v) {
        this.i.m = v;
    }
    /**
     * Prompts to save the linked URL instead of navigating to it.
    */
    get download() {
        return this.i.l;
    }
    set download(v) {
        this.i.l = v;
    }
    /**
     * Where to display the linked URL, as the name for a browsing context.
    */
    get target() {
        return this.i.a;
    }
    set target(v) {
        this.i.a = ensureEnum(ButtonBaseTarget_$type, v);
    }
    /**
     * The relationship of the linked URL.
     * See https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types
    */
    get rel() {
        return this.i.n;
    }
    set rel(v) {
        this.i.n = v;
    }
    get disabled() {
        return this.i.h;
    }
    set disabled(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Returns the HTMLFormElement associated with this element.
    */
    get form() {
        return this.i.j;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("ButtonBase");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Sets focus in the button.
    
    */
    focusComponent(options) {
        this.i.t((options == null ? null : options.i));
    }
    /**
     * Simulates a mouse click on the element
    
    */
    click() {
        this.i.q();
    }
    /**
     * Removes focus from the button.
    
    */
    blurComponent() {
        this.i.p();
    }
    get clicked() {
        return this._clicked;
    }
    set clicked(ev) {
        if (this._clicked_wrapped !== null) {
            this.i.clicked = delegateRemove(this.i.clicked, this._clicked_wrapped);
            this._clicked_wrapped = null;
            this._clicked = null;
        }
        this._clicked = ev;
        this._clicked_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClicked) {
                this.beforeClicked(this, outerArgs);
            }
            if (this._clicked) {
                this._clicked(this, outerArgs);
            }
        };
        this.i.clicked = delegateCombine(this.i.clicked, this._clicked_wrapped);
        if (this.i.clickedChanged) {
            this.i.clickedChanged();
        }
        ;
    }
    get focus() {
        return this._focus;
    }
    set focus(ev) {
        if (this._focus_wrapped !== null) {
            this.i.focus = delegateRemove(this.i.focus, this._focus_wrapped);
            this._focus_wrapped = null;
            this._focus = null;
        }
        this._focus = ev;
        this._focus_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFocus) {
                this.beforeFocus(this, outerArgs);
            }
            if (this._focus) {
                this._focus(this, outerArgs);
            }
        };
        this.i.focus = delegateCombine(this.i.focus, this._focus_wrapped);
        if (this.i.focusChanged) {
            this.i.focusChanged();
        }
        ;
    }
    get blur() {
        return this._blur;
    }
    set blur(ev) {
        if (this._blur_wrapped !== null) {
            this.i.blur = delegateRemove(this.i.blur, this._blur_wrapped);
            this._blur_wrapped = null;
            this._blur = null;
        }
        this._blur = ev;
        this._blur_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeBlur) {
                this.beforeBlur(this, outerArgs);
            }
            if (this._blur) {
                this._blur(this, outerArgs);
            }
        };
        this.i.blur = delegateCombine(this.i.blur, this._blur_wrapped);
        if (this.i.blurChanged) {
            this.i.blurChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ButtonBase = /*@__PURE__*/ (() => {
    class ButtonBase extends BaseElement {
        constructor() {
            super(...arguments);
            this.clicked = null;
            this.f = new WCNativeHelper();
            this.i = null;
            this.focus = null;
            this.blur = null;
        }
        clickedChanged() {
            if (this.clicked != null) {
                this.g.s("click", (a) => this.clicked(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.g.v("click");
            }
        }
        get g() {
            return this.f;
        }
        get nativeElement() {
            return this.i;
        }
        set nativeElement(a) {
            this.i = a;
            this.f.o = this.i;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.g.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ButtonBaseType_$type, EnumUtil.getEnumValue(ButtonBaseType_$type, this.g.f(ButtonBaseType_$type, ret_)));
            return EnumUtil.getEnumValue(ButtonBaseType_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(ButtonBaseType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.g.w("type", value_);
        }
        get m() {
            let ret_ = this.g.n("href");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.g.w("href", value_);
        }
        get l() {
            let ret_ = this.g.n("download");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.g.w("download", value_);
        }
        get a() {
            let ret_ = this.g.n("target");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ButtonBaseTarget_$type, EnumUtil.getEnumValue(ButtonBaseTarget_$type, this.g.f(ButtonBaseTarget_$type, ret_)));
            return EnumUtil.getEnumValue(ButtonBaseTarget_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(ButtonBaseTarget_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.g.w("target", value_);
        }
        get n() {
            let ret_ = this.g.n("rel");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.g.w("rel", value_);
        }
        get h() {
            let ret_ = this.g.n("disabled");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.g.w("disabled", value_);
        }
        get j() {
            let ret_ = this.g.n("form");
            return ret_;
        }
        focusChanged() {
            if (this.focus != null) {
                this.g.s("focus", (a) => this.focus(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.g.v("focus");
            }
        }
        blurChanged() {
            if (this.blur != null) {
                this.g.s("blur", (a) => this.blur(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.g.v("blur");
            }
        }
        t(a) {
            this.nativeElement.focus(this.g.i(a));
        }
        q() {
            this.nativeElement.click();
        }
        p() {
            this.nativeElement.blur();
        }
    }
    ButtonBase.$t = /*@__PURE__*/ markType(ButtonBase, 'ButtonBase', BaseElement.$);
    return ButtonBase;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Button = /*@__PURE__*/ (() => {
    class Button extends ButtonBase {
        get v() {
            let ret_ = this.g.n("variant");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ButtonVariant_$type, EnumUtil.getEnumValue(ButtonVariant_$type, this.g.f(ButtonVariant_$type, ret_)));
            return EnumUtil.getEnumValue(ButtonVariant_$type, ret_);
        }
        set v(a) {
            let value_ = enumGetBox(ButtonVariant_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.g.w("variant", value_);
        }
    }
    Button.$t = /*@__PURE__*/ markType(Button, 'Button', ButtonBase.$);
    return Button;
})();

/**
 * Represents a clickable button, used to submit forms or anywhere in a
 * document for accessible, standard button functionality.
*/
class IgrButton extends IgrButtonBase {
    createImplementation() {
        return new Button();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcButtonComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-button", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Sets the variant of the button.
    */
    get variant() {
        return this.i.v;
    }
    set variant(v) {
        this.i.v = ensureEnum(ButtonVariant_$type, v);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrButtonModule {
    static register() {
        IgrButtonBaseModule.register();
        TypeRegistrar.registerCons('IgrButton', IgrButton);
        TypeRegistrar.registerCons('IgrButton', IgrButton);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Dialog = /*@__PURE__*/ (() => {
    class Dialog extends BaseElement {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.l = null;
            this.closing = null;
            this.closed = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.l;
        }
        set nativeElement(a) {
            this.l = a;
            this.c.o = this.l;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get h() {
            let ret_ = this.d.n("keepOpenOnEscape");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.d.w("keepOpenOnEscape", value_);
        }
        get e() {
            let ret_ = this.d.n("closeOnOutsideClick");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.d.w("closeOnOutsideClick", value_);
        }
        get g() {
            let ret_ = this.d.n("hideDefaultAction");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.d.w("hideDefaultAction", value_);
        }
        get i() {
            let ret_ = this.d.n("open");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.d.w("open", value_);
        }
        get o() {
            let ret_ = this.d.n("title");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.d.w("title", value_);
        }
        get n() {
            let ret_ = this.d.n("returnValue");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.d.w("returnValue", value_);
        }
        closingChanged() {
            if (this.closing != null) {
                this.d.s("closing", (a) => this.closing(this, VoidEventArgs.b(a)));
            }
            else {
                this.d.v("closing");
            }
        }
        closedChanged() {
            if (this.closed != null) {
                this.d.s("closed", (a) => this.closed(this, VoidEventArgs.b(a)));
            }
            else {
                this.d.v("closed");
            }
        }
        j() {
            return (this.nativeElement.show());
        }
        f() {
            return (this.nativeElement.hide());
        }
        k() {
            return (this.nativeElement.toggle());
        }
    }
    Dialog.$t = /*@__PURE__*/ markType(Dialog, 'Dialog', BaseElement.$);
    return Dialog;
})();

/**
 * Represents a Dialog component.
*/
class IgrDialog extends Component {
    createImplementation() {
        return new Dialog();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDialogComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-dialog", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Whether the dialog should be kept open when pressing the 'ESCAPE' button.
    */
    get keepOpenOnEscape() {
        return this.i.h;
    }
    set keepOpenOnEscape(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Whether the dialog should be closed when clicking outside of it.
    */
    get closeOnOutsideClick() {
        return this.i.e;
    }
    set closeOnOutsideClick(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * Whether to hide the default action button for the dialog.
     * When there is projected content in the `footer` slot this property
     * has no effect.
    */
    get hideDefaultAction() {
        return this.i.g;
    }
    set hideDefaultAction(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * Whether the dialog is opened.
    */
    get open() {
        return this.i.i;
    }
    set open(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * Sets the title of the dialog.
    */
    get title() {
        return this.i.o;
    }
    set title(v) {
        this.i.o = v;
    }
    /**
     * Sets the return value for the dialog.
    */
    get returnValue() {
        return this.i.n;
    }
    set returnValue(v) {
        this.i.n = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Dialog");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Opens the dialog.
    
    */
    show() {
        let iv = this.i.j();
        return (iv);
    }
    /**
     * Closes the dialog.
    
    */
    hide() {
        let iv = this.i.f();
        return (iv);
    }
    /**
     * Toggles the open state of the dialog.
    
    */
    toggle() {
        let iv = this.i.k();
        return (iv);
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDialogModule {
    static register() {
        IgrButtonModule.register();
        TypeRegistrar.registerCons('IgrDialog', IgrDialog);
        TypeRegistrar.registerCons('IgrDialog', IgrDialog);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Icon = /*@__PURE__*/ (() => {
    class Icon extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.d = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.a.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get g() {
            let ret_ = this.b.n("name");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.b.w("name", value_);
        }
        get f() {
            let ret_ = this.b.n("collection");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.b.w("collection", value_);
        }
        get c() {
            let ret_ = this.b.n("mirrored");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("mirrored", value_);
        }
        h() {
            this.nativeElement.connectedCallback();
        }
        i() {
            this.nativeElement.disconnectedCallback();
        }
        j(a, b, c) {
            this.nativeElement.registerIcon(this.b.i(a), this.b.i(b), this.b.i(c));
        }
        k(a, b, c) {
            this.nativeElement.registerIconFromText(this.b.i(a), this.b.i(b), this.b.i(c));
        }
        l(a, b, c) {
            this.nativeElement.setIconRef(this.b.i(a), this.b.i(b), this.b.i(c));
        }
    }
    Icon.$t = /*@__PURE__*/ markType(Icon, 'Icon', BaseElement.$);
    return Icon;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let IconMeta = /*@__PURE__*/ (() => {
    class IconMeta extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
            this.a = null;
        }
    }
    IconMeta.$t = /*@__PURE__*/ markType(IconMeta, 'IconMeta');
    return IconMeta;
})();

/**
 * The icon component allows visualizing collections of pre-registered SVG icons.
*/
class IgrIcon extends Component {
    createImplementation() {
        return new Icon();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcIconComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-icon", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The name of the icon glyph to draw.
    */
    get name() {
        return this.i.g;
    }
    set name(v) {
        this.i.g = v;
    }
    /**
     * The name of the registered collection for look up of icons.
     * Defaults to `default`.
    */
    get collection() {
        return this.i.f;
    }
    set collection(v) {
        this.i.f = v;
    }
    /**
     * Whether to flip the icon. Useful for RTL layouts.
    */
    get mirrored() {
        return this.i.c;
    }
    set mirrored(v) {
        this.i.c = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Icon");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.h();
    }
    disconnectedCallback() {
        this.i.i();
    }
    registerIcon(name, url, collection) {
        this.i.j(name, url, collection);
    }
    registerIconFromText(name, iconText, collection) {
        this.i.k(name, iconText, collection);
    }
    setIconRef(name, collection, icon) {
        this.i.l(name, collection, (icon == null ? null : interfaceToInternal(icon, () => new IconMeta())));
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrIconModule {
    static register() {
        TypeRegistrar.registerCons('IgrIcon', IgrIcon);
        TypeRegistrar.registerCons('IgrIcon', IgrIcon);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DatePickerMode = /*@__PURE__*/ (function (DatePickerMode) {
    DatePickerMode[DatePickerMode["Dropdown"] = 0] = "Dropdown";
    DatePickerMode[DatePickerMode["Dialog"] = 1] = "Dialog";
    return DatePickerMode;
})({});
/**
 * @hidden
 */
let DatePickerMode_$type = /*@__PURE__*/ markEnum('DatePickerMode', 'Dropdown,0|Dialog,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DatePickerHeaderOrientation = /*@__PURE__*/ (function (DatePickerHeaderOrientation) {
    DatePickerHeaderOrientation[DatePickerHeaderOrientation["Horizontal"] = 0] = "Horizontal";
    DatePickerHeaderOrientation[DatePickerHeaderOrientation["Vertical"] = 1] = "Vertical";
    return DatePickerHeaderOrientation;
})({});
/**
 * @hidden
 */
let DatePickerHeaderOrientation_$type = /*@__PURE__*/ markEnum('DatePickerHeaderOrientation', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DatePickerOrientation = /*@__PURE__*/ (function (DatePickerOrientation) {
    DatePickerOrientation[DatePickerOrientation["Horizontal"] = 0] = "Horizontal";
    DatePickerOrientation[DatePickerOrientation["Vertical"] = 1] = "Vertical";
    return DatePickerOrientation;
})({});
/**
 * @hidden
 */
let DatePickerOrientation_$type = /*@__PURE__*/ markEnum('DatePickerOrientation', 'Horizontal,0|Vertical,1');

class IgrBaseComboBoxLike extends Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    get emitEvent() {
        return this.i.j;
    }
    set emitEvent(v) {
        this.i.j = v;
    }
    /**
     * Whether the component dropdown should be kept open on selection.
    */
    get keepOpenOnSelect() {
        return this.i.e;
    }
    set keepOpenOnSelect(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * Whether the component dropdown should be kept open on clicking outside of it.
    */
    get keepOpenOnOutsideClick() {
        return this.i.d;
    }
    set keepOpenOnOutsideClick(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Sets the open state of the component.
    */
    get open() {
        return this.i.f;
    }
    set open(v) {
        this.i.f = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("BaseComboBoxLike");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Shows the component.
    
    */
    show() {
        let iv = this.i.g();
        return (iv);
    }
    /**
     * Hides the component.
    
    */
    hide() {
        let iv = this.i.c();
        return (iv);
    }
    /**
     * Toggles the open state of the component.
    
    */
    toggle() {
        let iv = this.i.h();
        return (iv);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BaseComboBoxLike = /*@__PURE__*/ (() => {
    class BaseComboBoxLike extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.i = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.i;
        }
        set nativeElement(a) {
            this.i = a;
            this.a.o = this.i;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get j() {
            let ret_ = this.b.n("emitEvent");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.b.w("emitEvent", value_);
        }
        get e() {
            let ret_ = this.b.n("keepOpenOnSelect");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.b.w("keepOpenOnSelect", value_);
        }
        get d() {
            let ret_ = this.b.n("keepOpenOnOutsideClick");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("keepOpenOnOutsideClick", value_);
        }
        get f() {
            let ret_ = this.b.n("open");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.b.w("open", value_);
        }
        g() {
            return (this.nativeElement.show());
        }
        c() {
            return (this.nativeElement.hide());
        }
        h() {
            return (this.nativeElement.toggle());
        }
    }
    BaseComboBoxLike.$t = /*@__PURE__*/ markType(BaseComboBoxLike, 'BaseComboBoxLike', BaseElement.$);
    return BaseComboBoxLike;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DatePicker = /*@__PURE__*/ (() => {
    class DatePicker extends BaseComboBoxLike {
        constructor() {
            super(...arguments);
            this.opening = null;
            this.opened = null;
            this.closing = null;
            this.closed = null;
            this.change = null;
            this.input = null;
        }
        get ap() {
            let ret_ = this.b.n("label");
            return ret_;
        }
        set ap(a) {
            let value_ = a;
            this.b.w("label", value_);
        }
        get s() {
            let ret_ = this.b.n("mode");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DatePickerMode_$type, EnumUtil.getEnumValue(DatePickerMode_$type, this.b.f(DatePickerMode_$type, ret_)));
            return EnumUtil.getEnumValue(DatePickerMode_$type, ret_);
        }
        set s(a) {
            let value_ = enumGetBox(DatePickerMode_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("mode", value_);
        }
        get ad() {
            let ret_ = this.b.n("nonEditable");
            return ret_;
        }
        set ad(a) {
            let value_ = a;
            this.b.w("nonEditable", value_);
        }
        get af() {
            let ret_ = this.b.n("readOnly");
            return ret_;
        }
        set af(a) {
            let value_ = a;
            this.b.w("readOnly", value_);
        }
        get al() {
            let ret_ = this.b.n("value");
            return ret_;
        }
        set al(a) {
            let value_ = a;
            this.b.w("value", value_);
        }
        get ai() {
            let ret_ = this.b.n("activeDate");
            return ret_;
        }
        set ai(a) {
            let value_ = a;
            this.b.w("activeDate", value_);
        }
        get ak() {
            let ret_ = this.b.n("min");
            return ret_;
        }
        set ak(a) {
            let value_ = a;
            this.b.w("min", value_);
        }
        get aj() {
            let ret_ = this.b.n("max");
            return ret_;
        }
        set aj(a) {
            let value_ = a;
            this.b.w("max", value_);
        }
        get r() {
            let ret_ = this.b.n("headerOrientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DatePickerHeaderOrientation_$type, EnumUtil.getEnumValue(DatePickerHeaderOrientation_$type, this.b.f(DatePickerHeaderOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(DatePickerHeaderOrientation_$type, ret_);
        }
        set r(a) {
            let value_ = enumGetBox(DatePickerHeaderOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("headerOrientation", value_);
        }
        get t() {
            let ret_ = this.b.n("orientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DatePickerOrientation_$type, EnumUtil.getEnumValue(DatePickerOrientation_$type, this.b.f(DatePickerOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(DatePickerOrientation_$type, ret_);
        }
        set t(a) {
            let value_ = enumGetBox(DatePickerOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("orientation", value_);
        }
        get aa() {
            let ret_ = this.b.n("hideHeader");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.b.w("hideHeader", value_);
        }
        get ab() {
            let ret_ = this.b.n("hideOutsideDays");
            return ret_;
        }
        set ab(a) {
            let value_ = a;
            this.b.w("hideOutsideDays", value_);
        }
        get m() {
            let ret_ = this.b.m("disabledDates", (a) => new DateRangeDescriptor());
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.b.w("disabledDates", value_);
        }
        get n() {
            let ret_ = this.b.m("specialDates", (a) => new DateRangeDescriptor());
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.b.w("specialDates", value_);
        }
        get ae() {
            let ret_ = this.b.n("outlined");
            return ret_;
        }
        set ae(a) {
            let value_ = a;
            this.b.w("outlined", value_);
        }
        get as() {
            let ret_ = this.b.n("placeholder");
            return ret_;
        }
        set as(a) {
            let value_ = a;
            this.b.w("placeholder", value_);
        }
        get am() {
            let ret_ = this.b.n("visibleMonths");
            return ret_;
        }
        set am(a) {
            let value_ = a;
            this.b.w("visibleMonths", value_);
        }
        get ah() {
            let ret_ = this.b.n("showWeekNumbers");
            return ret_;
        }
        set ah(a) {
            let value_ = a;
            this.b.w("showWeekNumbers", value_);
        }
        get an() {
            let ret_ = this.b.n("displayFormat");
            return ret_;
        }
        set an(a) {
            let value_ = a;
            this.b.w("displayFormat", value_);
        }
        get ao() {
            let ret_ = this.b.n("inputFormat");
            return ret_;
        }
        set ao(a) {
            let value_ = a;
            this.b.w("inputFormat", value_);
        }
        get aq() {
            let ret_ = this.b.n("locale");
            return ret_;
        }
        set aq(a) {
            let value_ = a;
            this.b.w("locale", value_);
        }
        get at() {
            let ret_ = this.b.n("prompt");
            return ret_;
        }
        set at(a) {
            let value_ = a;
            this.b.w("prompt", value_);
        }
        get o() {
            let ret_ = this.b.m("resourceStrings", (a) => new CalendarResourceStrings());
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.b.w("resourceStrings", value_);
        }
        get y() {
            let ret_ = this.b.n("weekStart");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(WeekDays_$type, EnumUtil.getEnumValue(WeekDays_$type, this.b.f(WeekDays_$type, ret_)));
            return EnumUtil.getEnumValue(WeekDays_$type, ret_);
        }
        set y(a) {
            let value_ = enumGetBox(WeekDays_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("weekStart", value_);
        }
        get z() {
            let ret_ = this.b.n("disabled");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.b.w("disabled", value_);
        }
        get ag() {
            let ret_ = this.b.n("required");
            return ret_;
        }
        set ag(a) {
            let value_ = a;
            this.b.w("required", value_);
        }
        get ar() {
            let ret_ = this.b.n("name");
            return ret_;
        }
        set ar(a) {
            let value_ = a;
            this.b.w("name", value_);
        }
        get ac() {
            let ret_ = this.b.n("invalid");
            return ret_;
        }
        set ac(a) {
            let value_ = a;
            this.b.w("invalid", value_);
        }
        openingChanged() {
            if (this.opening != null) {
                this.b.s("opening", (a) => this.opening(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("opening");
            }
        }
        openedChanged() {
            if (this.opened != null) {
                this.b.s("opened", (a) => this.opened(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("opened");
            }
        }
        closingChanged() {
            if (this.closing != null) {
                this.b.s("closing", (a) => this.closing(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("closing");
            }
        }
        closedChanged() {
            if (this.closed != null) {
                this.b.s("closed", (a) => this.closed(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("closed");
            }
        }
        changeChanged() {
            if (this.change != null) {
                this.b.s("change", (a) => this.change(this, ComponentDateValueChangedEventArgs.a(a)));
            }
            else {
                this.b.v("change");
            }
        }
        inputChanged() {
            if (this.input != null) {
                this.b.s("input", (a) => this.input(this, ComponentDateValueChangedEventArgs.a(a)));
            }
            else {
                this.b.v("input");
            }
        }
        az() {
            this.nativeElement.connectedCallback();
        }
        aw() {
            this.nativeElement.clear();
        }
        a9(a, b = -1) {
            this.nativeElement.stepUp(this.b.i(enumGetBox(DatePart_$type, a)), this.b.i(b));
        }
        a8(a, b = -1) {
            this.nativeElement.stepDown(this.b.i(enumGetBox(DatePart_$type, a)), this.b.i(b));
        }
        a4() {
            this.nativeElement.select();
        }
        a7(a, b, c) {
            this.nativeElement.setSelectionRange(this.b.i(a), this.b.i(b), this.b.i(enumGetBox(SelectionRangeDirection_$type, c)));
        }
        a6(a, b, c, d) {
            this.nativeElement.setRangeText(this.b.i(a), this.b.i(b), this.b.i(c), this.b.i(enumGetBox(RangeTextSelectMode_$type, d)));
        }
        a3() {
            this.nativeElement.reportValidity();
        }
        av() {
            this.nativeElement.checkValidity();
        }
        a5(a) {
            this.nativeElement.setCustomValidity(this.b.i(a));
        }
    }
    DatePicker.$t = /*@__PURE__*/ markType(DatePicker, 'DatePicker', BaseComboBoxLike.$);
    return DatePicker;
})();

/**
 * igc-date-picker is a feature rich component used for entering a date through manual text input or
 * choosing date values from a calendar dialog that pops up.
*/
class IgrDatePicker extends IgrBaseComboBoxLike {
    createImplementation() {
        return new DatePicker();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._opening = null;
        this._opening_wrapped = null;
        this._opened = null;
        this._opened_wrapped = null;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        this._change = null;
        this._change_wrapped = null;
        this._input = null;
        this._input_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDatePickerComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-date-picker", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The label of the datepicker.
    */
    get label() {
        return this.i.ap;
    }
    set label(v) {
        this.i.ap = v;
    }
    /**
     * Determines whether the calendar is opened in a dropdown or a modal dialog
    */
    get mode() {
        return this.i.s;
    }
    set mode(v) {
        this.i.s = ensureEnum(DatePickerMode_$type, v);
    }
    /**
     * Whether to allow typing in the input.
    */
    get nonEditable() {
        return this.i.ad;
    }
    set nonEditable(v) {
        this.i.ad = ensureBool(v);
    }
    /**
     * Makes the control a readonly field.
    */
    get readOnly() {
        return this.i.af;
    }
    set readOnly(v) {
        this.i.af = ensureBool(v);
    }
    /**
     * The value of the picker
    */
    get value() {
        return this.i.al;
    }
    set value(v) {
        this.i.al = v;
    }
    /**
     * Gets/Sets the date which is shown in the calendar picker and is highlighted.
     * By default it is the current date.
    */
    get activeDate() {
        return this.i.ai;
    }
    set activeDate(v) {
        this.i.ai = v;
    }
    /**
     * The minimum value required for the date picker to remain valid.
    */
    get min() {
        return this.i.ak;
    }
    set min(v) {
        this.i.ak = v;
    }
    /**
     * The maximum value required for the date picker to remain valid.
    */
    get max() {
        return this.i.aj;
    }
    set max(v) {
        this.i.aj = v;
    }
    /**
     * The orientation of the calendar header.
    */
    get headerOrientation() {
        return this.i.r;
    }
    set headerOrientation(v) {
        this.i.r = ensureEnum(DatePickerHeaderOrientation_$type, v);
    }
    /**
     * The orientation of the multiple months displayed in the calendar's days view.
    */
    get orientation() {
        return this.i.t;
    }
    set orientation(v) {
        this.i.t = ensureEnum(DatePickerOrientation_$type, v);
    }
    /**
     * Determines whether the calendar hides its header.
    */
    get hideHeader() {
        return this.i.aa;
    }
    set hideHeader(v) {
        this.i.aa = ensureBool(v);
    }
    /**
     * Controls the visibility of the dates that do not belong to the current month.
    */
    get hideOutsideDays() {
        return this.i.ab;
    }
    set hideOutsideDays(v) {
        this.i.ab = ensureBool(v);
    }
    /**
     * Gets/sets disabled dates.
    */
    get disabledDates() {
        return this.i.m;
    }
    set disabledDates(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.m = v;
    }
    /**
     * Gets/sets special dates.
    */
    get specialDates() {
        return this.i.n;
    }
    set specialDates(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.n = v;
    }
    /**
     * Whether the control will have outlined appearance.
    */
    get outlined() {
        return this.i.ae;
    }
    set outlined(v) {
        this.i.ae = ensureBool(v);
    }
    /**
     * The placeholder attribute of the control.
    */
    get placeholder() {
        return this.i.as;
    }
    set placeholder(v) {
        this.i.as = v;
    }
    /**
     * The number of months displayed in the calendar.
    */
    get visibleMonths() {
        return this.i.am;
    }
    set visibleMonths(v) {
        this.i.am = +v;
    }
    /**
     * Whether to show the number of the week in the calendar.
    */
    get showWeekNumbers() {
        return this.i.ah;
    }
    set showWeekNumbers(v) {
        this.i.ah = ensureBool(v);
    }
    /**
     * Format to display the value in when not editing.
     * Defaults to the input format if not set.
    */
    get displayFormat() {
        return this.i.an;
    }
    set displayFormat(v) {
        this.i.an = v;
    }
    /**
     * The date format to apply on the input.
     * Defaults to the current locale Intl.DateTimeFormat
    */
    get inputFormat() {
        return this.i.ao;
    }
    set inputFormat(v) {
        this.i.ao = v;
    }
    /**
     * The locale settings used to display the value.
    */
    get locale() {
        return this.i.aq;
    }
    set locale(v) {
        this.i.aq = v;
    }
    /**
     * The prompt symbol to use for unfilled parts of the mask.
    */
    get prompt() {
        return this.i.at;
    }
    set prompt(v) {
        this.i.at = v;
    }
    /**
     * The resource strings of the calendar.
    */
    get resourceStrings() {
        const r = this.i.o;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrCalendarResourceStrings();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set resourceStrings(v) {
        v == null ? this.i.o = null : this.i.o = v.i;
    }
    /**
     * Sets the start day of the week for the calendar.
    */
    get weekStart() {
        return this.i.y;
    }
    set weekStart(v) {
        this.i.y = ensureEnum(WeekDays_$type, v);
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.z;
    }
    set disabled(v) {
        this.i.z = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.ag;
    }
    set required(v) {
        this.i.ag = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.ar;
    }
    set name(v) {
        this.i.ar = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.ac;
    }
    set invalid(v) {
        this.i.ac = ensureBool(v);
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.resourceStrings && this.resourceStrings.name && this.resourceStrings.name == name) {
            return this.resourceStrings;
        }
        return null;
    }
    connectedCallback() {
        this.i.az();
    }
    /**
     * Clears the input part of the component of any user input
    
    */
    clear() {
        this.i.aw();
    }
    stepUp(datePart, delta) {
        this.i.a9((datePart == null ? null : datePart), delta);
    }
    stepDown(datePart, delta) {
        this.i.a8((datePart == null ? null : datePart), delta);
    }
    /**
     * Selects the text in the input of the component
    
    */
    select() {
        this.i.a4();
    }
    setSelectionRange(start, end, direction) {
        this.i.a7(start, end, (direction == null ? null : direction));
    }
    setRangeText(replacement, start, end, mode) {
        this.i.a6(replacement, start, end, (mode == null ? null : mode));
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.a3();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.av();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.a5(message);
    }
    get opening() {
        return this._opening;
    }
    set opening(ev) {
        if (this._opening_wrapped !== null) {
            this.i.opening = delegateRemove(this.i.opening, this._opening_wrapped);
            this._opening_wrapped = null;
            this._opening = null;
        }
        this._opening = ev;
        this._opening_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpening) {
                this.beforeOpening(this, outerArgs);
            }
            if (this._opening) {
                this._opening(this, outerArgs);
            }
        };
        this.i.opening = delegateCombine(this.i.opening, this._opening_wrapped);
        if (this.i.openingChanged) {
            this.i.openingChanged();
        }
        ;
    }
    get opened() {
        return this._opened;
    }
    set opened(ev) {
        if (this._opened_wrapped !== null) {
            this.i.opened = delegateRemove(this.i.opened, this._opened_wrapped);
            this._opened_wrapped = null;
            this._opened = null;
        }
        this._opened = ev;
        this._opened_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpened) {
                this.beforeOpened(this, outerArgs);
            }
            if (this._opened) {
                this._opened(this, outerArgs);
            }
        };
        this.i.opened = delegateCombine(this.i.opened, this._opened_wrapped);
        if (this.i.openedChanged) {
            this.i.openedChanged();
        }
        ;
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDateValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get input() {
        return this._input;
    }
    set input(ev) {
        if (this._input_wrapped !== null) {
            this.i.input = delegateRemove(this.i.input, this._input_wrapped);
            this._input_wrapped = null;
            this._input = null;
        }
        this._input = ev;
        this._input_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDateValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeInput) {
                this.beforeInput(this, outerArgs);
            }
            if (this._input) {
                this._input(this, outerArgs);
            }
        };
        this.i.input = delegateCombine(this.i.input, this._input_wrapped);
        if (this.i.inputChanged) {
            this.i.inputChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDatePickerModule {
    static register() {
        IgrBaseComboBoxLikeModule.register();
        IgrCalendarModule.register();
        IgrDateTimeInputModule.register();
        IgrDialogModule.register();
        IgrIconModule.register();
        TypeRegistrar.registerCons('IgrDatePicker', IgrDatePicker);
        TypeRegistrar.registerCons('IgrDatePicker', IgrDatePicker);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Banner = /*@__PURE__*/ (() => {
    class Banner extends BaseElement {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.i = null;
            this.closing = null;
            this.closed = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.i;
        }
        set nativeElement(a) {
            this.i = a;
            this.c.o = this.i;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get f() {
            let ret_ = this.d.n("open");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.d.w("open", value_);
        }
        closingChanged() {
            if (this.closing != null) {
                this.d.s("closing", (a) => this.closing(this, VoidEventArgs.b(a)));
            }
            else {
                this.d.v("closing");
            }
        }
        closedChanged() {
            if (this.closed != null) {
                this.d.s("closed", (a) => this.closed(this, VoidEventArgs.b(a)));
            }
            else {
                this.d.v("closed");
            }
        }
        g() {
            return (this.nativeElement.show());
        }
        e() {
            return (this.nativeElement.hide());
        }
        h() {
            return (this.nativeElement.toggle());
        }
    }
    Banner.$t = /*@__PURE__*/ markType(Banner, 'Banner', BaseElement.$);
    return Banner;
})();

/**
 * The `igc-banner` component displays important and concise message(s) for a user to address, that is specific to a page or feature.
*/
class IgrBanner extends Component {
    createImplementation() {
        return new Banner();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcBannerComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-banner", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Determines whether the banner is being shown/hidden.
    */
    get open() {
        return this.i.f;
    }
    set open(v) {
        this.i.f = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Banner");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Shows the banner if not already shown. Returns `true` when the animation has completed.
    
    */
    show() {
        let iv = this.i.g();
        return (iv);
    }
    /**
     * Hides the banner if not already hidden. Returns `true` when the animation has completed.
    
    */
    hide() {
        let iv = this.i.e();
        return (iv);
    }
    /**
     * Toggles between shown/hidden state. Returns `true` when the animation has completed.
    
    */
    toggle() {
        let iv = this.i.h();
        return (iv);
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBannerModule {
    static register() {
        TypeRegistrar.registerCons('IgrBanner', IgrBanner);
        TypeRegistrar.registerCons('IgrBanner', IgrBanner);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DividerType = /*@__PURE__*/ (function (DividerType) {
    DividerType[DividerType["Solid"] = 0] = "Solid";
    DividerType[DividerType["Dashed"] = 1] = "Dashed";
    return DividerType;
})({});
/**
 * @hidden
 */
let DividerType_$type = /*@__PURE__*/ markEnum('DividerType', 'Solid,0|Dashed,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Divider = /*@__PURE__*/ (() => {
    class Divider extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.f = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.b.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get e() {
            let ret_ = this.c.n("vertical");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.c.w("vertical", value_);
        }
        get d() {
            let ret_ = this.c.n("middle");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.c.w("middle", value_);
        }
        get a() {
            let ret_ = this.c.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DividerType_$type, EnumUtil.getEnumValue(DividerType_$type, this.c.f(DividerType_$type, ret_)));
            return EnumUtil.getEnumValue(DividerType_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(DividerType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("type", value_);
        }
    }
    Divider.$t = /*@__PURE__*/ markType(Divider, 'Divider', BaseElement.$);
    return Divider;
})();

/**
 * The igc-divider allows the content author to easily create a horizontal/vertical rule as a break between content to better organize information on a page.
 * @cssproperty --color - Sets the color of the divider.
 * @cssproperty --inset - Shrinks the divider by the given amount from the start. If `middle` is set it will shrink from both sides.
*/
class IgrDivider extends Component {
    createImplementation() {
        return new Divider();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDividerComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-divider", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Whether to render a vertical divider line.
    */
    get vertical() {
        return this.i.e;
    }
    set vertical(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * When set and inset is provided, it will shrink the divider line from both sides.
    */
    get middle() {
        return this.i.d;
    }
    set middle(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Whether to render a solid or a dashed divider line.
    */
    get type() {
        return this.i.a;
    }
    set type(v) {
        this.i.a = ensureEnum(DividerType_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Divider");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDividerModule {
    static register() {
        TypeRegistrar.registerCons('IgrDivider', IgrDivider);
        TypeRegistrar.registerCons('IgrDivider', IgrDivider);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ToggleButton = /*@__PURE__*/ (() => {
    class ToggleButton extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.e = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.a.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get g() {
            let ret_ = this.b.n("value");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.b.w("value", value_);
        }
        get d() {
            let ret_ = this.b.n("selected");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("selected", value_);
        }
        get c() {
            let ret_ = this.b.n("disabled");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("disabled", value_);
        }
        j(a) {
            this.nativeElement.focus(this.b.i(a));
        }
        h() {
            this.nativeElement.blur();
        }
        i() {
            this.nativeElement.click();
        }
    }
    ToggleButton.$t = /*@__PURE__*/ markType(ToggleButton, 'ToggleButton', BaseElement.$);
    return ToggleButton;
})();

/**
 * The `igc-toggle-button` wraps a native button element and exposes additional `value` and `selected` properties.
 * It is used in the context of an `igc-button-group` to facilitate the creation of group/toolbar like UX behaviors.
*/
class IgrToggleButton extends Component {
    createImplementation() {
        return new ToggleButton();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcToggleButtonComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-toggle-button", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The value attribute of the control.
    */
    get value() {
        return this.i.g;
    }
    set value(v) {
        this.i.g = v;
    }
    /**
     * Determines whether the button is selected.
    */
    get selected() {
        return this.i.d;
    }
    set selected(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Determines whether the button is disabled.
    */
    get disabled() {
        return this.i.c;
    }
    set disabled(v) {
        this.i.c = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("ToggleButton");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Sets focus on the button.
    
    */
    focusComponent(options) {
        this.i.j((options == null ? null : options.i));
    }
    /**
     * Removes focus from the button.
    
    */
    blurComponent() {
        this.i.h();
    }
    /**
     * Simulates a mouse click on the element.
    
    */
    click() {
        this.i.i();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrToggleButtonModule {
    static register() {
        TypeRegistrar.registerCons('IgrToggleButton', IgrToggleButton);
        TypeRegistrar.registerCons('IgrToggleButton', IgrToggleButton);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ButtonGroupAlignment = /*@__PURE__*/ (function (ButtonGroupAlignment) {
    ButtonGroupAlignment[ButtonGroupAlignment["Horizontal"] = 0] = "Horizontal";
    ButtonGroupAlignment[ButtonGroupAlignment["Vertical"] = 1] = "Vertical";
    return ButtonGroupAlignment;
})({});
/**
 * @hidden
 */
let ButtonGroupAlignment_$type = /*@__PURE__*/ markEnum('ButtonGroupAlignment', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ButtonGroupSelection = /*@__PURE__*/ (function (ButtonGroupSelection) {
    ButtonGroupSelection[ButtonGroupSelection["Single"] = 0] = "Single";
    ButtonGroupSelection[ButtonGroupSelection["SingleRequired"] = 1] = "SingleRequired";
    ButtonGroupSelection[ButtonGroupSelection["Multiple"] = 2] = "Multiple";
    return ButtonGroupSelection;
})({});
/**
 * @hidden
 */
let ButtonGroupSelection_$type = /*@__PURE__*/ markEnum('ButtonGroupSelection', 'Single,0|SingleRequired:single-required,1|Multiple,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ButtonGroup = /*@__PURE__*/ (() => {
    class ButtonGroup extends BaseElement {
        constructor() {
            super(...arguments);
            this.f = new WCNativeHelper();
            this.i = null;
            this.select = null;
            this.deselect = null;
        }
        get g() {
            return this.f;
        }
        get nativeElement() {
            return this.i;
        }
        set nativeElement(a) {
            this.i = a;
            this.f.o = this.i;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get h() {
            let ret_ = this.g.n("disabled");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.g.w("disabled", value_);
        }
        get b() {
            let ret_ = this.g.n("alignment");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ButtonGroupAlignment_$type, EnumUtil.getEnumValue(ButtonGroupAlignment_$type, this.g.f(ButtonGroupAlignment_$type, ret_)));
            return EnumUtil.getEnumValue(ButtonGroupAlignment_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(ButtonGroupAlignment_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.g.w("alignment", value_);
        }
        get c() {
            let ret_ = this.g.n("selection");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ButtonGroupSelection_$type, EnumUtil.getEnumValue(ButtonGroupSelection_$type, this.g.f(ButtonGroupSelection_$type, ret_)));
            return EnumUtil.getEnumValue(ButtonGroupSelection_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(ButtonGroupSelection_$type, a);
            value_ = WCNativeHelper.getActualName(value_);
            value_ = WCNativeHelper.camel(value_);
            this.g.w("selection", value_);
        }
        get a() {
            let ret_ = this.g.n("selectedItems");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.g.w("selectedItems", value_);
        }
        selectChanged() {
            if (this.select != null) {
                this.g.s("select", (a) => this.select(this, ComponentValueChangedEventArgs.a(a)));
            }
            else {
                this.g.v("select");
            }
        }
        deselectChanged() {
            if (this.deselect != null) {
                this.g.s("deselect", (a) => this.deselect(this, ComponentValueChangedEventArgs.a(a)));
            }
            else {
                this.g.v("deselect");
            }
        }
    }
    ButtonGroup.$t = /*@__PURE__*/ markType(ButtonGroup, 'ButtonGroup', BaseElement.$);
    return ButtonGroup;
})();

/**
 * The `igc-button-group` groups a series of `igc-toggle-button`s together, exposing features such as layout and selection.
*/
class IgrButtonGroup extends Component {
    createImplementation() {
        return new ButtonGroup();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._select = null;
        this._select_wrapped = null;
        this._deselect = null;
        this._deselect_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcButtonGroupComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-button-group", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Disables all buttons inside the group.
    */
    get disabled() {
        return this.i.h;
    }
    set disabled(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Sets the orientation of the buttons in the group.
    */
    get alignment() {
        return this.i.b;
    }
    set alignment(v) {
        this.i.b = ensureEnum(ButtonGroupAlignment_$type, v);
    }
    /**
     * Controls the mode of selection for the button group.
    */
    get selection() {
        return this.i.c;
    }
    set selection(v) {
        this.i.c = ensureEnum(ButtonGroupSelection_$type, v);
    }
    get selectedItems() {
        return this.i.a;
    }
    set selectedItems(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.a = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("ButtonGroup");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    get select() {
        return this._select;
    }
    set select(ev) {
        if (this._select_wrapped !== null) {
            this.i.select = delegateRemove(this.i.select, this._select_wrapped);
            this._select_wrapped = null;
            this._select = null;
        }
        this._select = ev;
        this._select_wrapped = (o, e) => {
            let outerArgs = new IgrComponentValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelect) {
                this.beforeSelect(this, outerArgs);
            }
            if (this._select) {
                this._select(this, outerArgs);
            }
        };
        this.i.select = delegateCombine(this.i.select, this._select_wrapped);
        if (this.i.selectChanged) {
            this.i.selectChanged();
        }
        ;
    }
    get deselect() {
        return this._deselect;
    }
    set deselect(ev) {
        if (this._deselect_wrapped !== null) {
            this.i.deselect = delegateRemove(this.i.deselect, this._deselect_wrapped);
            this._deselect_wrapped = null;
            this._deselect = null;
        }
        this._deselect = ev;
        this._deselect_wrapped = (o, e) => {
            let outerArgs = new IgrComponentValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeDeselect) {
                this.beforeDeselect(this, outerArgs);
            }
            if (this._deselect) {
                this._deselect(this, outerArgs);
            }
        };
        this.i.deselect = delegateCombine(this.i.deselect, this._deselect_wrapped);
        if (this.i.deselectChanged) {
            this.i.deselectChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrButtonGroupModule {
    static register() {
        IgrToggleButtonModule.register();
        TypeRegistrar.registerCons('IgrButtonGroup', IgrButtonGroup);
        TypeRegistrar.registerCons('IgrButtonGroup', IgrButtonGroup);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TextareaAutocapitalize = /*@__PURE__*/ (function (TextareaAutocapitalize) {
    TextareaAutocapitalize[TextareaAutocapitalize["None"] = 0] = "None";
    TextareaAutocapitalize[TextareaAutocapitalize["Off"] = 1] = "Off";
    TextareaAutocapitalize[TextareaAutocapitalize["On"] = 2] = "On";
    TextareaAutocapitalize[TextareaAutocapitalize["Sentences"] = 3] = "Sentences";
    TextareaAutocapitalize[TextareaAutocapitalize["Words"] = 4] = "Words";
    TextareaAutocapitalize[TextareaAutocapitalize["Characters"] = 5] = "Characters";
    return TextareaAutocapitalize;
})({});
/**
 * @hidden
 */
let TextareaAutocapitalize_$type = /*@__PURE__*/ markEnum('TextareaAutocapitalize', 'None,0|Off,1|On,2|Sentences,3|Words,4|Characters,5');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TextareaInputMode = /*@__PURE__*/ (function (TextareaInputMode) {
    TextareaInputMode[TextareaInputMode["None"] = 0] = "None";
    TextareaInputMode[TextareaInputMode["Email"] = 1] = "Email";
    TextareaInputMode[TextareaInputMode["Search"] = 2] = "Search";
    TextareaInputMode[TextareaInputMode["Tel"] = 3] = "Tel";
    TextareaInputMode[TextareaInputMode["Text"] = 4] = "Text";
    TextareaInputMode[TextareaInputMode["Url"] = 5] = "Url";
    TextareaInputMode[TextareaInputMode["Decimal"] = 6] = "Decimal";
    TextareaInputMode[TextareaInputMode["Numeric"] = 7] = "Numeric";
    return TextareaInputMode;
})({});
/**
 * @hidden
 */
let TextareaInputMode_$type = /*@__PURE__*/ markEnum('TextareaInputMode', 'None,0|Email,1|Search,2|Tel,3|Text,4|Url,5|Decimal,6|Numeric,7');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TextareaResize = /*@__PURE__*/ (function (TextareaResize) {
    TextareaResize[TextareaResize["None"] = 0] = "None";
    TextareaResize[TextareaResize["Vertical"] = 1] = "Vertical";
    TextareaResize[TextareaResize["Auto"] = 2] = "Auto";
    return TextareaResize;
})({});
/**
 * @hidden
 */
let TextareaResize_$type = /*@__PURE__*/ markEnum('TextareaResize', 'None,0|Vertical,1|Auto,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TextareaWrap = /*@__PURE__*/ (function (TextareaWrap) {
    TextareaWrap[TextareaWrap["Off"] = 0] = "Off";
    TextareaWrap[TextareaWrap["Hard"] = 1] = "Hard";
    TextareaWrap[TextareaWrap["Soft"] = 2] = "Soft";
    return TextareaWrap;
})({});
/**
 * @hidden
 */
let TextareaWrap_$type = /*@__PURE__*/ markEnum('TextareaWrap', 'Off,0|Hard,1|Soft,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Textarea = /*@__PURE__*/ (() => {
    class Textarea extends BaseElement {
        constructor() {
            super(...arguments);
            this.i = new WCNativeHelper();
            this.u = null;
            this.input = null;
            this.change = null;
            this.focus = null;
            this.blur = null;
        }
        get j() {
            return this.i;
        }
        get nativeElement() {
            return this.u;
        }
        set nativeElement(a) {
            this.u = a;
            this.i.o = this.u;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get w() {
            let ret_ = this.j.n("autocomplete");
            return ret_;
        }
        set w(a) {
            let value_ = a;
            this.j.w("autocomplete", value_);
        }
        get c() {
            let ret_ = this.j.n("autocapitalize");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TextareaAutocapitalize_$type, EnumUtil.getEnumValue(TextareaAutocapitalize_$type, this.j.f(TextareaAutocapitalize_$type, ret_)));
            return EnumUtil.getEnumValue(TextareaAutocapitalize_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(TextareaAutocapitalize_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("autocapitalize", value_);
        }
        get d() {
            let ret_ = this.j.n("inputMode");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TextareaInputMode_$type, EnumUtil.getEnumValue(TextareaInputMode_$type, this.j.f(TextareaInputMode_$type, ret_)));
            return EnumUtil.getEnumValue(TextareaInputMode_$type, ret_);
        }
        set d(a) {
            let value_ = enumGetBox(TextareaInputMode_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("inputMode", value_);
        }
        get x() {
            let ret_ = this.j.n("label");
            return ret_;
        }
        set x(a) {
            let value_ = a;
            this.j.w("label", value_);
        }
        get r() {
            let ret_ = this.j.n("maxLength");
            return ret_;
        }
        set r(a) {
            let value_ = a;
            this.j.w("maxLength", value_);
        }
        get s() {
            let ret_ = this.j.n("minLength");
            return ret_;
        }
        set s(a) {
            let value_ = a;
            this.j.w("minLength", value_);
        }
        get m() {
            let ret_ = this.j.n("outlined");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.j.w("outlined", value_);
        }
        get z() {
            let ret_ = this.j.n("placeholder");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.j.w("placeholder", value_);
        }
        get n() {
            let ret_ = this.j.n("readOnly");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.j.w("readOnly", value_);
        }
        get e() {
            let ret_ = this.j.n("resize");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TextareaResize_$type, EnumUtil.getEnumValue(TextareaResize_$type, this.j.f(TextareaResize_$type, ret_)));
            return EnumUtil.getEnumValue(TextareaResize_$type, ret_);
        }
        set e(a) {
            let value_ = enumGetBox(TextareaResize_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("resize", value_);
        }
        get t() {
            let ret_ = this.j.n("rows");
            return ret_;
        }
        set t(a) {
            let value_ = a;
            this.j.w("rows", value_);
        }
        get aa() {
            let ret_ = this.j.n("value");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.j.w("value", value_);
        }
        get p() {
            let ret_ = this.j.n("spellcheck");
            return ret_;
        }
        set p(a) {
            let value_ = a;
            this.j.w("spellcheck", value_);
        }
        get f() {
            let ret_ = this.j.n("wrap");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TextareaWrap_$type, EnumUtil.getEnumValue(TextareaWrap_$type, this.j.f(TextareaWrap_$type, ret_)));
            return EnumUtil.getEnumValue(TextareaWrap_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(TextareaWrap_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("wrap", value_);
        }
        get q() {
            let ret_ = this.j.n("validateOnly");
            return ret_;
        }
        set q(a) {
            let value_ = a;
            this.j.w("validateOnly", value_);
        }
        get k() {
            let ret_ = this.j.n("disabled");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.j.w("disabled", value_);
        }
        get o() {
            let ret_ = this.j.n("required");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.j.w("required", value_);
        }
        get y() {
            let ret_ = this.j.n("name");
            return ret_;
        }
        set y(a) {
            let value_ = a;
            this.j.w("name", value_);
        }
        get l() {
            let ret_ = this.j.n("invalid");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.j.w("invalid", value_);
        }
        inputChanged() {
            if (this.input != null) {
                this.j.s("input", (a) => this.input(this, ComponentValueChangedEventArgs.a(a)));
            }
            else {
                this.j.v("input");
            }
        }
        changeChanged() {
            if (this.change != null) {
                this.j.s("change", (a) => this.change(this, ComponentValueChangedEventArgs.a(a)));
            }
            else {
                this.j.v("change");
            }
        }
        focusChanged() {
            if (this.focus != null) {
                this.j.s("focus", (a) => this.focus(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.j.v("focus");
            }
        }
        blurChanged() {
            if (this.blur != null) {
                this.j.s("blur", (a) => this.blur(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.j.v("blur");
            }
        }
        ae() {
            this.nativeElement.connectedCallback();
        }
        af() {
            this.nativeElement.disconnectedCallback();
        }
        aj() {
            this.nativeElement.select();
        }
        an(a, b, c) {
            this.nativeElement.setSelectionRange(this.j.i(a), this.j.i(b), this.j.i(enumGetBox(SelectionRangeDirection_$type, c)));
        }
        am(a, b, c, d) {
            this.nativeElement.setRangeText(this.j.i(a), this.j.i(b), this.j.i(c), this.j.i(enumGetBox(RangeTextSelectMode_$type, d)));
        }
        ai() {
            this.nativeElement.reportValidity();
        }
        ad() {
            this.nativeElement.checkValidity();
        }
        ak(a) {
            this.nativeElement.setCustomValidity(this.j.i(a));
        }
    }
    Textarea.$t = /*@__PURE__*/ markType(Textarea, 'Textarea', BaseElement.$);
    return Textarea;
})();

/**
 * This element represents a multi-line plain-text editing control,
 * useful when you want to allow users to enter a sizeable amount of free-form text,
 * for example a comment on a review or feedback form.
*/
class IgrTextarea extends Component {
    createImplementation() {
        return new Textarea();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._input = null;
        this._input_wrapped = null;
        this._change = null;
        this._change_wrapped = null;
        this._focus = null;
        this._focus_wrapped = null;
        this._blur = null;
        this._blur_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcTextareaComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-textarea", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Specifies what if any permission the browser has to provide for automated assistance in filling out form field values,
     * as well as guidance to the browser as to the type of information expected in the field.
     * Refer to [this page](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for additional information.
    */
    get autocomplete() {
        return this.i.w;
    }
    set autocomplete(v) {
        this.i.w = v;
    }
    /**
     * Controls whether and how text input is automatically capitalized as it is entered/edited by the user.
     * [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize).
    */
    get autocapitalize() {
        return this.i.c;
    }
    set autocapitalize(v) {
        this.i.c = ensureEnum(TextareaAutocapitalize_$type, v);
    }
    /**
     * Hints at the type of data that might be entered by the user while editing the element or its contents.
     * This allows a browser to display an appropriate virtual keyboard.
     * [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/inputmode)
    */
    get inputMode() {
        return this.i.d;
    }
    set inputMode(v) {
        this.i.d = ensureEnum(TextareaInputMode_$type, v);
    }
    /**
     * The label for the control.
    */
    get label() {
        return this.i.x;
    }
    set label(v) {
        this.i.x = v;
    }
    /**
     * The maximum number of characters (UTF-16 code units) that the user can enter.
     * If this value isn't specified, the user can enter an unlimited number of characters.
    */
    get maxLength() {
        return this.i.r;
    }
    set maxLength(v) {
        this.i.r = +v;
    }
    /**
     * The minimum number of characters (UTF-16 code units) required that the user should enter.
    */
    get minLength() {
        return this.i.s;
    }
    set minLength(v) {
        this.i.s = +v;
    }
    /**
     * Whether the control will have outlined appearance.
    */
    get outlined() {
        return this.i.m;
    }
    set outlined(v) {
        this.i.m = ensureBool(v);
    }
    /**
     * The placeholder attribute of the control.
    */
    get placeholder() {
        return this.i.z;
    }
    set placeholder(v) {
        this.i.z = v;
    }
    /**
     * Makes the control a readonly field.
    */
    get readOnly() {
        return this.i.n;
    }
    set readOnly(v) {
        this.i.n = ensureBool(v);
    }
    /**
     * Controls whether the control can be resized.
     * When `auto` is set, the control will try to expand and fit its content.
    */
    get resize() {
        return this.i.e;
    }
    set resize(v) {
        this.i.e = ensureEnum(TextareaResize_$type, v);
    }
    /**
     * The number of visible text lines for the control. If it is specified, it must be a positive integer.
     * If it is not specified, the default value is 2.
    */
    get rows() {
        return this.i.t;
    }
    set rows(v) {
        this.i.t = +v;
    }
    /**
     * The value of the component
    */
    get value() {
        return this.i.aa;
    }
    set value(v) {
        this.i.aa = v;
    }
    /**
     * Controls whether the element may be checked for spelling errors.
    */
    get spellcheck() {
        return this.i.p;
    }
    set spellcheck(v) {
        this.i.p = ensureBool(v);
    }
    /**
     * Indicates how the control should wrap the value for form submission.
     * Refer to [this page on MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#attributes)
     * for explanation of the available values.
    */
    get wrap() {
        return this.i.f;
    }
    set wrap(v) {
        this.i.f = ensureEnum(TextareaWrap_$type, v);
    }
    /**
     * Enables validation rules to be evaluated without restricting user input. This applies to the `maxLength` property
     * when it is defined.
    */
    get validateOnly() {
        return this.i.q;
    }
    set validateOnly(v) {
        this.i.q = ensureBool(v);
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.k;
    }
    set disabled(v) {
        this.i.k = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.o;
    }
    set required(v) {
        this.i.o = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.y;
    }
    set name(v) {
        this.i.y = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.l;
    }
    set invalid(v) {
        this.i.l = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Textarea");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.ae();
    }
    disconnectedCallback() {
        this.i.af();
    }
    /**
     * Selects all text within the control.
    
    */
    select() {
        this.i.aj();
    }
    setSelectionRange(start, end, direction) {
        this.i.an(start, end, (direction == null ? null : direction));
    }
    setRangeText(replacement, start, end, selectMode) {
        this.i.am(replacement, start, end, (selectMode == null ? null : selectMode));
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.ai();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.ad();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.ak(message);
    }
    get input() {
        return this._input;
    }
    set input(ev) {
        if (this._input_wrapped !== null) {
            this.i.input = delegateRemove(this.i.input, this._input_wrapped);
            this._input_wrapped = null;
            this._input = null;
        }
        this._input = ev;
        this._input_wrapped = (o, e) => {
            let outerArgs = new IgrComponentValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeInput) {
                this.beforeInput(this, outerArgs);
            }
            if (this._input) {
                this._input(this, outerArgs);
            }
        };
        this.i.input = delegateCombine(this.i.input, this._input_wrapped);
        if (this.i.inputChanged) {
            this.i.inputChanged();
        }
        ;
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get focus() {
        return this._focus;
    }
    set focus(ev) {
        if (this._focus_wrapped !== null) {
            this.i.focus = delegateRemove(this.i.focus, this._focus_wrapped);
            this._focus_wrapped = null;
            this._focus = null;
        }
        this._focus = ev;
        this._focus_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFocus) {
                this.beforeFocus(this, outerArgs);
            }
            if (this._focus) {
                this._focus(this, outerArgs);
            }
        };
        this.i.focus = delegateCombine(this.i.focus, this._focus_wrapped);
        if (this.i.focusChanged) {
            this.i.focusChanged();
        }
        ;
    }
    get blur() {
        return this._blur;
    }
    set blur(ev) {
        if (this._blur_wrapped !== null) {
            this.i.blur = delegateRemove(this.i.blur, this._blur_wrapped);
            this._blur_wrapped = null;
            this._blur = null;
        }
        this._blur = ev;
        this._blur_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeBlur) {
                this.beforeBlur(this, outerArgs);
            }
            if (this._blur) {
                this._blur(this, outerArgs);
            }
        };
        this.i.blur = delegateCombine(this.i.blur, this._blur_wrapped);
        if (this.i.blurChanged) {
            this.i.blurChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTextareaModule {
    static register() {
        TypeRegistrar.registerCons('IgrTextarea', IgrTextarea);
        TypeRegistrar.registerCons('IgrTextarea', IgrTextarea);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var AvatarShape = /*@__PURE__*/ (function (AvatarShape) {
    AvatarShape[AvatarShape["Circle"] = 0] = "Circle";
    AvatarShape[AvatarShape["Rounded"] = 1] = "Rounded";
    AvatarShape[AvatarShape["Square"] = 2] = "Square";
    return AvatarShape;
})({});
/**
 * @hidden
 */
let AvatarShape_$type = /*@__PURE__*/ markEnum('AvatarShape', 'Circle,0|Rounded,1|Square,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Avatar = /*@__PURE__*/ (() => {
    class Avatar extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.d = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.b.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get h() {
            let ret_ = this.c.n("src");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.c.w("src", value_);
        }
        get f() {
            let ret_ = this.c.n("alt");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.c.w("alt", value_);
        }
        get g() {
            let ret_ = this.c.n("initials");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.c.w("initials", value_);
        }
        get a() {
            let ret_ = this.c.n("shape");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(AvatarShape_$type, EnumUtil.getEnumValue(AvatarShape_$type, this.c.f(AvatarShape_$type, ret_)));
            return EnumUtil.getEnumValue(AvatarShape_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(AvatarShape_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("shape", value_);
        }
    }
    Avatar.$t = /*@__PURE__*/ markType(Avatar, 'Avatar', BaseElement.$);
    return Avatar;
})();

/**
 * An avatar component is used as a representation of a user identity
 * typically in a user profile.
*/
class IgrAvatar extends Component {
    createImplementation() {
        return new Avatar();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcAvatarComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-avatar", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The image source to use.
    */
    get src() {
        return this.i.h;
    }
    set src(v) {
        this.i.h = v;
    }
    /**
     * Alternative text for the image.
    */
    get alt() {
        return this.i.f;
    }
    set alt(v) {
        this.i.f = v;
    }
    /**
     * Initials to use as a fallback when no image is available.
    */
    get initials() {
        return this.i.g;
    }
    set initials(v) {
        this.i.g = v;
    }
    /**
     * The shape of the avatar.
    */
    get shape() {
        return this.i.a;
    }
    set shape(v) {
        this.i.a = ensureEnum(AvatarShape_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Avatar");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrAvatarModule {
    static register() {
        TypeRegistrar.registerCons('IgrAvatar', IgrAvatar);
        TypeRegistrar.registerCons('IgrAvatar', IgrAvatar);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StyleVariant = /*@__PURE__*/ (function (StyleVariant) {
    StyleVariant[StyleVariant["Primary"] = 0] = "Primary";
    StyleVariant[StyleVariant["Info"] = 1] = "Info";
    StyleVariant[StyleVariant["Success"] = 2] = "Success";
    StyleVariant[StyleVariant["Warning"] = 3] = "Warning";
    StyleVariant[StyleVariant["Danger"] = 4] = "Danger";
    return StyleVariant;
})({});
/**
 * @hidden
 */
let StyleVariant_$type = /*@__PURE__*/ markEnum('StyleVariant', 'Primary,0|Info,1|Success,2|Warning,3|Danger,4');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var BadgeShape = /*@__PURE__*/ (function (BadgeShape) {
    BadgeShape[BadgeShape["Rounded"] = 0] = "Rounded";
    BadgeShape[BadgeShape["Square"] = 1] = "Square";
    return BadgeShape;
})({});
/**
 * @hidden
 */
let BadgeShape_$type = /*@__PURE__*/ markEnum('BadgeShape', 'Rounded,0|Square,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Badge = /*@__PURE__*/ (() => {
    class Badge extends BaseElement {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.f = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.c.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.n("variant");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StyleVariant_$type, EnumUtil.getEnumValue(StyleVariant_$type, this.d.f(StyleVariant_$type, ret_)));
            return EnumUtil.getEnumValue(StyleVariant_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(StyleVariant_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.d.w("variant", value_);
        }
        get e() {
            let ret_ = this.d.n("outlined");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.d.w("outlined", value_);
        }
        get a() {
            let ret_ = this.d.n("shape");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(BadgeShape_$type, EnumUtil.getEnumValue(BadgeShape_$type, this.d.f(BadgeShape_$type, ret_)));
            return EnumUtil.getEnumValue(BadgeShape_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(BadgeShape_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.d.w("shape", value_);
        }
    }
    Badge.$t = /*@__PURE__*/ markType(Badge, 'Badge', BaseElement.$);
    return Badge;
})();

/**
 * The badge is a component indicating a status on a related item or an area
 * where some active indication is required.
*/
class IgrBadge extends Component {
    createImplementation() {
        return new Badge();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcBadgeComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-badge", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The type of badge.
    */
    get variant() {
        return this.i.b;
    }
    set variant(v) {
        this.i.b = ensureEnum(StyleVariant_$type, v);
    }
    /**
     * Sets whether to draw an outlined version of the badge.
    */
    get outlined() {
        return this.i.e;
    }
    set outlined(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * The shape of the badge.
    */
    get shape() {
        return this.i.a;
    }
    set shape(v) {
        this.i.a = ensureEnum(BadgeShape_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Badge");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBadgeModule {
    static register() {
        TypeRegistrar.registerCons('IgrBadge', IgrBadge);
        TypeRegistrar.registerCons('IgrBadge', IgrBadge);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var RadioGroupAlignment = /*@__PURE__*/ (function (RadioGroupAlignment) {
    RadioGroupAlignment[RadioGroupAlignment["Horizontal"] = 0] = "Horizontal";
    RadioGroupAlignment[RadioGroupAlignment["Vertical"] = 1] = "Vertical";
    return RadioGroupAlignment;
})({});
/**
 * @hidden
 */
let RadioGroupAlignment_$type = /*@__PURE__*/ markEnum('RadioGroupAlignment', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadioChangeEventArgsDetail = /*@__PURE__*/ (() => {
    class RadioChangeEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.d = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.a.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.b.n("checked");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("checked", value_);
        }
        get f() {
            let ret_ = this.b.n("value");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.b.w("value", value_);
        }
    }
    RadioChangeEventArgsDetail.$t = /*@__PURE__*/ markType(RadioChangeEventArgsDetail, 'RadioChangeEventArgsDetail');
    return RadioChangeEventArgsDetail;
})();

class IgrRadioChangeEventArgsDetail {
    createImplementation() {
        return new RadioChangeEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get checked() {
        return this.i.c;
    }
    set checked(v) {
        this.i.c = ensureBool(v);
    }
    get value() {
        return this.i.f;
    }
    set value(v) {
        this.i.f = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadioChangeEventArgs = /*@__PURE__*/ (() => {
    class RadioChangeEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new RadioChangeEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    RadioChangeEventArgs.$t = /*@__PURE__*/ markType(RadioChangeEventArgs, 'RadioChangeEventArgs');
    return RadioChangeEventArgs;
})();

class IgrRadioChangeEventArgs {
    createImplementation() {
        return new RadioChangeEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrRadioChangeEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RadioGroup = /*@__PURE__*/ (() => {
    class RadioGroup extends BaseElement {
        constructor() {
            super(...arguments);
            this.change = null;
            this.c = new WCNativeHelper();
            this.e = null;
        }
        changeChanged() {
            if (this.change != null) {
                this.d.s("change", (a) => this.change(this, RadioChangeEventArgs.a(a)));
            }
            else {
                this.d.v("change");
            }
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.n("alignment");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(RadioGroupAlignment_$type, EnumUtil.getEnumValue(RadioGroupAlignment_$type, this.d.f(RadioGroupAlignment_$type, ret_)));
            return EnumUtil.getEnumValue(RadioGroupAlignment_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(RadioGroupAlignment_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.d.w("alignment", value_);
        }
        get g() {
            let ret_ = this.d.n("name");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.d.w("name", value_);
        }
        get h() {
            let ret_ = this.d.n("value");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.d.w("value", value_);
        }
    }
    RadioGroup.$t = /*@__PURE__*/ markType(RadioGroup, 'RadioGroup', BaseElement.$);
    return RadioGroup;
})();

/**
 * The igc-radio-group component unifies one or more igc-radio buttons.
*/
class IgrRadioGroup extends Component {
    createImplementation() {
        return new RadioGroup();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._change = null;
        this._change_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcRadioGroupComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-radio-group", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Alignment of the radio controls inside this group.
    */
    get alignment() {
        return this.i.b;
    }
    set alignment(v) {
        this.i.b = ensureEnum(RadioGroupAlignment_$type, v);
    }
    /**
     * Gets/Sets the name for all child igc-radio components.
    */
    get name() {
        return this.i.g;
    }
    set name(v) {
        this.i.g = v;
    }
    /**
     * Gets/Sets the checked igc-radio element that matches `value`
    */
    get value() {
        return this.i.h;
    }
    set value(v) {
        this.i.h = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("RadioGroup");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrRadioChangeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRadioGroupModule {
    static register() {
        TypeRegistrar.registerCons('IgrRadioGroup', IgrRadioGroup);
        TypeRegistrar.registerCons('IgrRadioGroup', IgrRadioGroup);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var RadioLabelPosition = /*@__PURE__*/ (function (RadioLabelPosition) {
    RadioLabelPosition[RadioLabelPosition["Before"] = 0] = "Before";
    RadioLabelPosition[RadioLabelPosition["After"] = 1] = "After";
    return RadioLabelPosition;
})({});
/**
 * @hidden
 */
let RadioLabelPosition_$type = /*@__PURE__*/ markEnum('RadioLabelPosition', 'Before,0|After,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Radio = /*@__PURE__*/ (() => {
    class Radio extends BaseElement {
        constructor() {
            super(...arguments);
            this.e = new WCNativeHelper();
            this.k = null;
            this.change = null;
            this.focus = null;
            this.blur = null;
        }
        get f() {
            return this.e;
        }
        get nativeElement() {
            return this.k;
        }
        set nativeElement(a) {
            this.k = a;
            this.e.o = this.k;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get n() {
            let ret_ = this.f.n("value");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.f.w("value", value_);
        }
        get g() {
            let ret_ = this.f.n("checked");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.f.w("checked", value_);
        }
        get b() {
            let ret_ = this.f.n("labelPosition");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(RadioLabelPosition_$type, EnumUtil.getEnumValue(RadioLabelPosition_$type, this.f.f(RadioLabelPosition_$type, ret_)));
            return EnumUtil.getEnumValue(RadioLabelPosition_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(RadioLabelPosition_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.f.w("labelPosition", value_);
        }
        get h() {
            let ret_ = this.f.n("disabled");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.f.w("disabled", value_);
        }
        get j() {
            let ret_ = this.f.n("required");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.f.w("required", value_);
        }
        get m() {
            let ret_ = this.f.n("name");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.f.w("name", value_);
        }
        get i() {
            let ret_ = this.f.n("invalid");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.f.w("invalid", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.f.s("change", (a) => this.change(this, RadioChangeEventArgs.a(a)));
            }
            else {
                this.f.v("change");
            }
        }
        focusChanged() {
            if (this.focus != null) {
                this.f.s("focus", (a) => this.focus(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.f.v("focus");
            }
        }
        blurChanged() {
            if (this.blur != null) {
                this.f.s("blur", (a) => this.blur(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.f.v("blur");
            }
        }
        s() {
            this.nativeElement.click();
        }
        u(a) {
            this.nativeElement.focus(this.f.i(a));
        }
        p() {
            this.nativeElement.blur();
        }
        w(a) {
            this.nativeElement.setCustomValidity(this.f.i(a));
        }
        v() {
            this.nativeElement.reportValidity();
        }
        r() {
            this.nativeElement.checkValidity();
        }
    }
    Radio.$t = /*@__PURE__*/ markType(Radio, 'Radio', BaseElement.$);
    return Radio;
})();

/**

*/
class IgrRadio extends Component {
    createImplementation() {
        return new Radio();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._change = null;
        this._change_wrapped = null;
        this._focus = null;
        this._focus_wrapped = null;
        this._blur = null;
        this._blur_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcRadioComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-radio", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The value attribute of the control.
    */
    get value() {
        return this.i.n;
    }
    set value(v) {
        this.i.n = v;
    }
    /**
     * The checked state of the control.
    */
    get checked() {
        return this.i.g;
    }
    set checked(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * The label position of the radio control.
    */
    get labelPosition() {
        return this.i.b;
    }
    set labelPosition(v) {
        this.i.b = ensureEnum(RadioLabelPosition_$type, v);
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.h;
    }
    set disabled(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.j;
    }
    set required(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.m;
    }
    set name(v) {
        this.i.m = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.i;
    }
    set invalid(v) {
        this.i.i = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Radio");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Simulates a click on the radio control.
    
    */
    click() {
        this.i.s();
    }
    /**
     * Sets focus on the radio control.
    
    */
    focusComponent(options) {
        this.i.u((options == null ? null : options.i));
    }
    /**
     * Removes focus from the radio control.
    
    */
    blurComponent() {
        this.i.p();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.w(message);
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.v();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.r();
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrRadioChangeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get focus() {
        return this._focus;
    }
    set focus(ev) {
        if (this._focus_wrapped !== null) {
            this.i.focus = delegateRemove(this.i.focus, this._focus_wrapped);
            this._focus_wrapped = null;
            this._focus = null;
        }
        this._focus = ev;
        this._focus_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFocus) {
                this.beforeFocus(this, outerArgs);
            }
            if (this._focus) {
                this._focus(this, outerArgs);
            }
        };
        this.i.focus = delegateCombine(this.i.focus, this._focus_wrapped);
        if (this.i.focusChanged) {
            this.i.focusChanged();
        }
        ;
    }
    get blur() {
        return this._blur;
    }
    set blur(ev) {
        if (this._blur_wrapped !== null) {
            this.i.blur = delegateRemove(this.i.blur, this._blur_wrapped);
            this._blur_wrapped = null;
            this._blur = null;
        }
        this._blur = ev;
        this._blur_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeBlur) {
                this.beforeBlur(this, outerArgs);
            }
            if (this._blur) {
                this._blur(this, outerArgs);
            }
        };
        this.i.blur = delegateCombine(this.i.blur, this._blur_wrapped);
        if (this.i.blurChanged) {
            this.i.blurChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRadioModule {
    static register() {
        TypeRegistrar.registerCons('IgrRadioChangeEventArgs', IgrRadioChangeEventArgs);
        TypeRegistrar.registerCons('IgrRadio', IgrRadio);
        TypeRegistrar.registerCons('IgrRadio', IgrRadio);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Card = /*@__PURE__*/ (() => {
    class Card extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.d = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.a.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.b.n("elevated");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("elevated", value_);
        }
    }
    Card.$t = /*@__PURE__*/ markType(Card, 'Card', BaseElement.$);
    return Card;
})();

/**
 * A container which wraps different elements related to a single subject
*/
class IgrCard extends Component {
    createImplementation() {
        return new Card();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCardComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-card", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Sets card elevated style, otherwise card looks outlined.
    */
    get elevated() {
        return this.i.c;
    }
    set elevated(v) {
        this.i.c = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Card");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCardModule {
    static register() {
        TypeRegistrar.registerCons('IgrCard', IgrCard);
        TypeRegistrar.registerCons('IgrCard', IgrCard);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CheckboxChangeEventArgsDetail = /*@__PURE__*/ (() => {
    class CheckboxChangeEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.d = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.a.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.b.n("checked");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("checked", value_);
        }
        get f() {
            let ret_ = this.b.n("value");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.b.w("value", value_);
        }
    }
    CheckboxChangeEventArgsDetail.$t = /*@__PURE__*/ markType(CheckboxChangeEventArgsDetail, 'CheckboxChangeEventArgsDetail');
    return CheckboxChangeEventArgsDetail;
})();

class IgrCheckboxChangeEventArgsDetail {
    createImplementation() {
        return new CheckboxChangeEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get checked() {
        return this.i.c;
    }
    set checked(v) {
        this.i.c = ensureBool(v);
    }
    get value() {
        return this.i.f;
    }
    set value(v) {
        this.i.f = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CheckboxChangeEventArgs = /*@__PURE__*/ (() => {
    class CheckboxChangeEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new CheckboxChangeEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    CheckboxChangeEventArgs.$t = /*@__PURE__*/ markType(CheckboxChangeEventArgs, 'CheckboxChangeEventArgs');
    return CheckboxChangeEventArgs;
})();

class IgrCheckboxChangeEventArgs {
    createImplementation() {
        return new CheckboxChangeEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrCheckboxChangeEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var CheckboxBaseLabelPosition = /*@__PURE__*/ (function (CheckboxBaseLabelPosition) {
    CheckboxBaseLabelPosition[CheckboxBaseLabelPosition["Before"] = 0] = "Before";
    CheckboxBaseLabelPosition[CheckboxBaseLabelPosition["After"] = 1] = "After";
    return CheckboxBaseLabelPosition;
})({});
/**
 * @hidden
 */
let CheckboxBaseLabelPosition_$type = /*@__PURE__*/ markEnum('CheckboxBaseLabelPosition', 'Before,0|After,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CheckboxBase = /*@__PURE__*/ (() => {
    class CheckboxBase extends BaseElement {
        constructor() {
            super(...arguments);
            this.e = new WCNativeHelper();
            this.k = null;
            this.change = null;
            this.focus = null;
            this.blur = null;
        }
        get f() {
            return this.e;
        }
        get nativeElement() {
            return this.k;
        }
        set nativeElement(a) {
            this.k = a;
            this.e.o = this.k;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get n() {
            let ret_ = this.f.n("value");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.f.w("value", value_);
        }
        get g() {
            let ret_ = this.f.n("checked");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.f.w("checked", value_);
        }
        get a() {
            let ret_ = this.f.n("labelPosition");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(CheckboxBaseLabelPosition_$type, EnumUtil.getEnumValue(CheckboxBaseLabelPosition_$type, this.f.f(CheckboxBaseLabelPosition_$type, ret_)));
            return EnumUtil.getEnumValue(CheckboxBaseLabelPosition_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(CheckboxBaseLabelPosition_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.f.w("labelPosition", value_);
        }
        get h() {
            let ret_ = this.f.n("disabled");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.f.w("disabled", value_);
        }
        get j() {
            let ret_ = this.f.n("required");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.f.w("required", value_);
        }
        get m() {
            let ret_ = this.f.n("name");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.f.w("name", value_);
        }
        get i() {
            let ret_ = this.f.n("invalid");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.f.w("invalid", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.f.s("change", (a) => this.change(this, CheckboxChangeEventArgs.a(a)));
            }
            else {
                this.f.v("change");
            }
        }
        focusChanged() {
            if (this.focus != null) {
                this.f.s("focus", (a) => this.focus(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.f.v("focus");
            }
        }
        blurChanged() {
            if (this.blur != null) {
                this.f.s("blur", (a) => this.blur(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.f.v("blur");
            }
        }
        s() {
            this.nativeElement.click();
        }
        u(a) {
            this.nativeElement.focus(this.f.i(a));
        }
        p() {
            this.nativeElement.blur();
        }
        v() {
            this.nativeElement.reportValidity();
        }
        r() {
            this.nativeElement.checkValidity();
        }
        w(a) {
            this.nativeElement.setCustomValidity(this.f.i(a));
        }
    }
    CheckboxBase.$t = /*@__PURE__*/ markType(CheckboxBase, 'CheckboxBase', BaseElement.$);
    return CheckboxBase;
})();

class IgrCheckboxBase extends Component {
    createImplementation() {
        return new CheckboxBase();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._change = null;
        this._change_wrapped = null;
        this._focus = null;
        this._focus_wrapped = null;
        this._blur = null;
        this._blur_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-checkbox-base", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The value attribute of the control.
    */
    get value() {
        return this.i.n;
    }
    set value(v) {
        this.i.n = v;
    }
    /**
     * The checked state of the control.
    */
    get checked() {
        return this.i.g;
    }
    set checked(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * The label position of the control.
    */
    get labelPosition() {
        return this.i.a;
    }
    set labelPosition(v) {
        this.i.a = ensureEnum(CheckboxBaseLabelPosition_$type, v);
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.h;
    }
    set disabled(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.j;
    }
    set required(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.m;
    }
    set name(v) {
        this.i.m = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.i;
    }
    set invalid(v) {
        this.i.i = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("CheckboxBase");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Simulates a click on the control.
    
    */
    click() {
        this.i.s();
    }
    /**
     * Sets focus on the control.
    
    */
    focusComponent(options) {
        this.i.u((options == null ? null : options.i));
    }
    /**
     * Removes focus from the control.
    
    */
    blurComponent() {
        this.i.p();
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.v();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.r();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.w(message);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrCheckboxChangeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get focus() {
        return this._focus;
    }
    set focus(ev) {
        if (this._focus_wrapped !== null) {
            this.i.focus = delegateRemove(this.i.focus, this._focus_wrapped);
            this._focus_wrapped = null;
            this._focus = null;
        }
        this._focus = ev;
        this._focus_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFocus) {
                this.beforeFocus(this, outerArgs);
            }
            if (this._focus) {
                this._focus(this, outerArgs);
            }
        };
        this.i.focus = delegateCombine(this.i.focus, this._focus_wrapped);
        if (this.i.focusChanged) {
            this.i.focusChanged();
        }
        ;
    }
    get blur() {
        return this._blur;
    }
    set blur(ev) {
        if (this._blur_wrapped !== null) {
            this.i.blur = delegateRemove(this.i.blur, this._blur_wrapped);
            this._blur_wrapped = null;
            this._blur = null;
        }
        this._blur = ev;
        this._blur_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeBlur) {
                this.beforeBlur(this, outerArgs);
            }
            if (this._blur) {
                this._blur(this, outerArgs);
            }
        };
        this.i.blur = delegateCombine(this.i.blur, this._blur_wrapped);
        if (this.i.blurChanged) {
            this.i.blurChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCheckboxBaseModule {
    static register() {
        TypeRegistrar.registerCons('IgrCheckboxChangeEventArgs', IgrCheckboxChangeEventArgs);
        TypeRegistrar.registerCons('IgrCheckboxBase', IgrCheckboxBase);
        TypeRegistrar.registerCons('IgrCheckboxBase', IgrCheckboxBase);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Checkbox = /*@__PURE__*/ (() => {
    class Checkbox extends CheckboxBase {
        get y() {
            let ret_ = this.f.n("indeterminate");
            return ret_;
        }
        set y(a) {
            let value_ = a;
            this.f.w("indeterminate", value_);
        }
    }
    Checkbox.$t = /*@__PURE__*/ markType(Checkbox, 'Checkbox', CheckboxBase.$);
    return Checkbox;
})();

/**
 * A check box allowing single values to be selected/deselected.
*/
class IgrCheckbox extends IgrCheckboxBase {
    createImplementation() {
        return new Checkbox();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCheckboxComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-checkbox", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Draws the checkbox in indeterminate state.
    */
    get indeterminate() {
        return this.i.y;
    }
    set indeterminate(v) {
        this.i.y = ensureBool(v);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCheckboxModule {
    static register() {
        IgrCheckboxBaseModule.register();
        TypeRegistrar.registerCons('IgrCheckbox', IgrCheckbox);
        TypeRegistrar.registerCons('IgrCheckbox', IgrCheckbox);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var InputType = /*@__PURE__*/ (function (InputType) {
    InputType[InputType["Number"] = 0] = "Number";
    InputType[InputType["Email"] = 1] = "Email";
    InputType[InputType["Password"] = 2] = "Password";
    InputType[InputType["Search"] = 3] = "Search";
    InputType[InputType["Tel"] = 4] = "Tel";
    InputType[InputType["Text"] = 5] = "Text";
    InputType[InputType["Url"] = 6] = "Url";
    return InputType;
})({});
/**
 * @hidden
 */
let InputType_$type = /*@__PURE__*/ markEnum('InputType', 'Number,0|Email,1|Password,2|Search,3|Tel,4|Text,5|Url,6');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Input = /*@__PURE__*/ (() => {
    class Input extends InputBase {
        constructor() {
            super(...arguments);
            this.change = null;
        }
        changeChanged() {
            if (this.change != null) {
                this.e.s("change", (a) => this.change(this, ComponentDataValueChangedEventArgs.a(a)));
            }
            else {
                this.e.v("change");
            }
        }
        get am() {
            let ret_ = this.e.n("value");
            return ret_;
        }
        set am(a) {
            let value_ = a;
            this.e.w("value", value_);
        }
        get ab() {
            let ret_ = this.e.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(InputType_$type, EnumUtil.getEnumValue(InputType_$type, this.e.f(InputType_$type, ret_)));
            return EnumUtil.getEnumValue(InputType_$type, ret_);
        }
        set ab(a) {
            let value_ = enumGetBox(InputType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("type", value_);
        }
        get ai() {
            let ret_ = this.e.n("inputMode");
            return ret_;
        }
        set ai(a) {
            let value_ = a;
            this.e.w("inputMode", value_);
        }
        get al() {
            let ret_ = this.e.n("pattern");
            return ret_;
        }
        set al(a) {
            let value_ = a;
            this.e.w("pattern", value_);
        }
        get af() {
            let ret_ = this.e.n("minLength");
            return ret_;
        }
        set af(a) {
            let value_ = a;
            this.e.w("minLength", value_);
        }
        get ae() {
            let ret_ = this.e.n("maxLength");
            return ret_;
        }
        set ae(a) {
            let value_ = a;
            this.e.w("maxLength", value_);
        }
        get ak() {
            let ret_ = this.e.n("min");
            return ret_;
        }
        set ak(a) {
            let value_ = a;
            this.e.w("min", value_);
        }
        get aj() {
            let ret_ = this.e.n("max");
            return ret_;
        }
        set aj(a) {
            let value_ = a;
            this.e.w("max", value_);
        }
        get ag() {
            let ret_ = this.e.n("step");
            return ret_;
        }
        set ag(a) {
            let value_ = a;
            this.e.w("step", value_);
        }
        get ac() {
            let ret_ = this.e.n("autofocus");
            return ret_;
        }
        set ac(a) {
            let value_ = a;
            this.e.w("autofocus", value_);
        }
        get ah() {
            let ret_ = this.e.n("autocomplete");
            return ret_;
        }
        set ah(a) {
            let value_ = a;
            this.e.w("autocomplete", value_);
        }
        get ad() {
            let ret_ = this.e.n("validateOnly");
            return ret_;
        }
        set ad(a) {
            let value_ = a;
            this.e.w("validateOnly", value_);
        }
        ao() {
            this.nativeElement.select();
        }
        aq(a = -1) {
            this.nativeElement.stepUp(this.e.i(a));
        }
        ap(a = -1) {
            this.nativeElement.stepDown(this.e.i(a));
        }
    }
    Input.$t = /*@__PURE__*/ markType(Input, 'Input', InputBase.$);
    return Input;
})();

/**

*/
class IgrInput extends IgrInputBase {
    createImplementation() {
        return new Input();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcInputComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-input", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The value of the control.
    */
    get value() {
        return this.i.am;
    }
    set value(v) {
        this.i.am = v;
    }
    /**
     * The type attribute of the control.
    */
    get type() {
        return this.i.ab;
    }
    set type(v) {
        this.i.ab = ensureEnum(InputType_$type, v);
    }
    /**
     * The input mode attribute of the control.
     * See [relevant MDN article](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/inputmode)
    */
    get inputMode() {
        return this.i.ai;
    }
    set inputMode(v) {
        this.i.ai = v;
    }
    /**
     * The pattern attribute of the control.
    */
    get pattern() {
        return this.i.al;
    }
    set pattern(v) {
        this.i.al = v;
    }
    /**
     * The minimum string length required by the control.
    */
    get minLength() {
        return this.i.af;
    }
    set minLength(v) {
        this.i.af = +v;
    }
    /**
     * The maximum string length of the control.
    */
    get maxLength() {
        return this.i.ae;
    }
    set maxLength(v) {
        this.i.ae = +v;
    }
    /**
     * The min attribute of the control.
    */
    get min() {
        return this.i.ak;
    }
    set min(v) {
        this.i.ak = v;
    }
    /**
     * The max attribute of the control.
    */
    get max() {
        return this.i.aj;
    }
    set max(v) {
        this.i.aj = v;
    }
    /**
     * The step attribute of the control.
    */
    get step() {
        return this.i.ag;
    }
    set step(v) {
        this.i.ag = +v;
    }
    /**
     * The autofocus attribute of the control.
    */
    get autofocus() {
        return this.i.ac;
    }
    set autofocus(v) {
        this.i.ac = ensureBool(v);
    }
    /**
     * The autocomplete attribute of the control.
    */
    get autocomplete() {
        return this.i.ah;
    }
    set autocomplete(v) {
        this.i.ah = v;
    }
    /**
     * Enables validation rules to be evaluated without restricting user input. This applies to the `maxLength` property for
     * string-type inputs or allows spin buttons to exceed the predefined `min/max` limits for number-type inputs.
    */
    get validateOnly() {
        return this.i.ad;
    }
    set validateOnly(v) {
        this.i.ad = ensureBool(v);
    }
    /**
     * Selects all text within the input.
    
    */
    select() {
        this.i.ao();
    }
    /**
     * Increments the numeric value of the input by one or more steps.
    
    */
    stepUp(n) {
        this.i.aq(n);
    }
    /**
     * Decrements the numeric value of the input by one or more steps.
    
    */
    stepDown(n) {
        this.i.ap(n);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDataValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrInputModule {
    static register() {
        IgrInputBaseModule.register();
        TypeRegistrar.registerCons('IgrInput', IgrInput);
        TypeRegistrar.registerCons('IgrInput', IgrInput);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ListHeader = /*@__PURE__*/ (() => {
    class ListHeader extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    ListHeader.$t = /*@__PURE__*/ markType(ListHeader, 'ListHeader', BaseElement.$);
    return ListHeader;
})();

/**
 * Header list item.
*/
class IgrListHeader extends Component {
    createImplementation() {
        return new ListHeader();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcListHeaderComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-list-header", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("ListHeader");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrListHeaderModule {
    static register() {
        TypeRegistrar.registerCons('IgrListHeader', IgrListHeader);
        TypeRegistrar.registerCons('IgrListHeader', IgrListHeader);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ListItem = /*@__PURE__*/ (() => {
    class ListItem extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    ListItem.$t = /*@__PURE__*/ markType(ListItem, 'ListItem', BaseElement.$);
    return ListItem;
})();

/**
 * The list-item component is a container
 * intended for row items in the list component.
*/
class IgrListItem extends Component {
    createImplementation() {
        return new ListItem();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcListItemComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-list-item", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("ListItem");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrListItemModule {
    static register() {
        TypeRegistrar.registerCons('IgrListItem', IgrListItem);
        TypeRegistrar.registerCons('IgrListItem', IgrListItem);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let List = /*@__PURE__*/ (() => {
    class List extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    List.$t = /*@__PURE__*/ markType(List, 'List', BaseElement.$);
    return List;
})();

/**
 * Displays a collection of data items in a templatable list format.
*/
class IgrList extends Component {
    createImplementation() {
        return new List();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcListComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-list", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("List");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrListModule {
    static register() {
        TypeRegistrar.registerCons('IgrList', IgrList);
        TypeRegistrar.registerCons('IgrList', IgrList);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Navbar = /*@__PURE__*/ (() => {
    class Navbar extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    Navbar.$t = /*@__PURE__*/ markType(Navbar, 'Navbar', BaseElement.$);
    return Navbar;
})();

/**
 * A navigation bar component is used to facilitate navigation through
 * a series of hierarchical screens within an app.
*/
class IgrNavbar extends Component {
    createImplementation() {
        return new Navbar();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcNavbarComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-navbar", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Navbar");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrNavbarModule {
    static register() {
        TypeRegistrar.registerCons('IgrNavbar', IgrNavbar);
        TypeRegistrar.registerCons('IgrNavbar', IgrNavbar);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Ripple = /*@__PURE__*/ (() => {
    class Ripple extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    Ripple.$t = /*@__PURE__*/ markType(Ripple, 'Ripple', BaseElement.$);
    return Ripple;
})();

/**
 * A ripple can be applied to an element to represent
 * interactive surface.
*/
class IgrRipple extends Component {
    createImplementation() {
        return new Ripple();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcRippleComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-ripple", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Ripple");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRippleModule {
    static register() {
        TypeRegistrar.registerCons('IgrRipple', IgrRipple);
        TypeRegistrar.registerCons('IgrRipple', IgrRipple);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Switch = /*@__PURE__*/ (() => {
    class Switch extends CheckboxBase {
    }
    Switch.$t = /*@__PURE__*/ markType(Switch, 'Switch', CheckboxBase.$);
    return Switch;
})();

/**
 * Similar to a checkbox, a switch controls the state of a single setting on or off.
*/
class IgrSwitch extends IgrCheckboxBase {
    createImplementation() {
        return new Switch();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSwitchComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-switch", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSwitchModule {
    static register() {
        IgrCheckboxBaseModule.register();
        TypeRegistrar.registerCons('IgrSwitch', IgrSwitch);
        TypeRegistrar.registerCons('IgrSwitch', IgrSwitch);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var IconButtonVariant = /*@__PURE__*/ (function (IconButtonVariant) {
    IconButtonVariant[IconButtonVariant["Flat"] = 0] = "Flat";
    IconButtonVariant[IconButtonVariant["Contained"] = 1] = "Contained";
    IconButtonVariant[IconButtonVariant["Outlined"] = 2] = "Outlined";
    return IconButtonVariant;
})({});
/**
 * @hidden
 */
let IconButtonVariant_$type = /*@__PURE__*/ markEnum('IconButtonVariant', 'Flat,0|Contained,1|Outlined,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let IconButton = /*@__PURE__*/ (() => {
    class IconButton extends ButtonBase {
        get y() {
            let ret_ = this.g.n("name");
            return ret_;
        }
        set y(a) {
            let value_ = a;
            this.g.w("name", value_);
        }
        get x() {
            let ret_ = this.g.n("collection");
            return ret_;
        }
        set x(a) {
            let value_ = a;
            this.g.w("collection", value_);
        }
        get w() {
            let ret_ = this.g.n("mirrored");
            return ret_;
        }
        set w(a) {
            let value_ = a;
            this.g.w("mirrored", value_);
        }
        get v() {
            let ret_ = this.g.n("variant");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(IconButtonVariant_$type, EnumUtil.getEnumValue(IconButtonVariant_$type, this.g.f(IconButtonVariant_$type, ret_)));
            return EnumUtil.getEnumValue(IconButtonVariant_$type, ret_);
        }
        set v(a) {
            let value_ = enumGetBox(IconButtonVariant_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.g.w("variant", value_);
        }
        z(a, b, c) {
            this.nativeElement.registerIcon(this.g.i(a), this.g.i(b), this.g.i(c));
        }
        aa(a, b, c) {
            this.nativeElement.registerIconFromText(this.g.i(a), this.g.i(b), this.g.i(c));
        }
    }
    IconButton.$t = /*@__PURE__*/ markType(IconButton, 'IconButton', ButtonBase.$);
    return IconButton;
})();

/**

*/
class IgrIconButton extends IgrButtonBase {
    createImplementation() {
        return new IconButton();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcIconButtonComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-icon-button", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The name of the icon.
    */
    get name() {
        return this.i.y;
    }
    set name(v) {
        this.i.y = v;
    }
    /**
     * The name of the icon collection.
    */
    get collection() {
        return this.i.x;
    }
    set collection(v) {
        this.i.x = v;
    }
    /**
     * Whether to flip the icon button. Useful for RTL layouts.
    */
    get mirrored() {
        return this.i.w;
    }
    set mirrored(v) {
        this.i.w = ensureBool(v);
    }
    /**
     * The visual variant of the icon button.
    */
    get variant() {
        return this.i.v;
    }
    set variant(v) {
        this.i.v = ensureEnum(IconButtonVariant_$type, v);
    }
    registerIcon(name, url, collection) {
        this.i.z(name, url, collection);
    }
    registerIconFromText(name, iconText, collection) {
        this.i.aa(name, iconText, collection);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrIconButtonModule {
    static register() {
        IgrButtonBaseModule.register();
        TypeRegistrar.registerCons('IgrIconButton', IgrIconButton);
        TypeRegistrar.registerCons('IgrIconButton', IgrIconButton);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let NavDrawerHeaderItem = /*@__PURE__*/ (() => {
    class NavDrawerHeaderItem extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    NavDrawerHeaderItem.$t = /*@__PURE__*/ markType(NavDrawerHeaderItem, 'NavDrawerHeaderItem', BaseElement.$);
    return NavDrawerHeaderItem;
})();

/**
 * A wrapper for navigation drawer's header.
*/
class IgrNavDrawerHeaderItem extends Component {
    createImplementation() {
        return new NavDrawerHeaderItem();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcNavDrawerHeaderItemComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-nav-drawer-header-item", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("NavDrawerHeaderItem");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrNavDrawerHeaderItemModule {
    static register() {
        TypeRegistrar.registerCons('IgrNavDrawerHeaderItem', IgrNavDrawerHeaderItem);
        TypeRegistrar.registerCons('IgrNavDrawerHeaderItem', IgrNavDrawerHeaderItem);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let NavDrawerItem = /*@__PURE__*/ (() => {
    class NavDrawerItem extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.e = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.a.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get d() {
            let ret_ = this.b.n("disabled");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("disabled", value_);
        }
        get c() {
            let ret_ = this.b.n("active");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("active", value_);
        }
    }
    NavDrawerItem.$t = /*@__PURE__*/ markType(NavDrawerItem, 'NavDrawerItem', BaseElement.$);
    return NavDrawerItem;
})();

/**
 * Represents a navigation drawer item.
*/
class IgrNavDrawerItem extends Component {
    createImplementation() {
        return new NavDrawerItem();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcNavDrawerItemComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-nav-drawer-item", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Determines whether the drawer is disabled.
    */
    get disabled() {
        return this.i.d;
    }
    set disabled(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Determines whether the drawer is active.
    */
    get active() {
        return this.i.c;
    }
    set active(v) {
        this.i.c = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("NavDrawerItem");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrNavDrawerItemModule {
    static register() {
        TypeRegistrar.registerCons('IgrNavDrawerItem', IgrNavDrawerItem);
        TypeRegistrar.registerCons('IgrNavDrawerItem', IgrNavDrawerItem);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var NavDrawerPosition = /*@__PURE__*/ (function (NavDrawerPosition) {
    NavDrawerPosition[NavDrawerPosition["Bottom"] = 0] = "Bottom";
    NavDrawerPosition[NavDrawerPosition["Top"] = 1] = "Top";
    NavDrawerPosition[NavDrawerPosition["Start"] = 2] = "Start";
    NavDrawerPosition[NavDrawerPosition["End"] = 3] = "End";
    NavDrawerPosition[NavDrawerPosition["Relative"] = 4] = "Relative";
    return NavDrawerPosition;
})({});
/**
 * @hidden
 */
let NavDrawerPosition_$type = /*@__PURE__*/ markEnum('NavDrawerPosition', 'Bottom,0|Top,1|Start,2|End,3|Relative,4');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let NavDrawer = /*@__PURE__*/ (() => {
    class NavDrawer extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.h = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.h;
        }
        set nativeElement(a) {
            this.h = a;
            this.b.o = this.h;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.n("position");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(NavDrawerPosition_$type, EnumUtil.getEnumValue(NavDrawerPosition_$type, this.c.f(NavDrawerPosition_$type, ret_)));
            return EnumUtil.getEnumValue(NavDrawerPosition_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(NavDrawerPosition_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("position", value_);
        }
        get e() {
            let ret_ = this.c.n("open");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.c.w("open", value_);
        }
        f() {
            return (this.nativeElement.show());
        }
        d() {
            return (this.nativeElement.hide());
        }
        g() {
            return (this.nativeElement.toggle());
        }
    }
    NavDrawer.$t = /*@__PURE__*/ markType(NavDrawer, 'NavDrawer', BaseElement.$);
    return NavDrawer;
})();

/**
 * Represents a side navigation container that provides
 * quick access between views.
*/
class IgrNavDrawer extends Component {
    createImplementation() {
        return new NavDrawer();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcNavDrawerComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-nav-drawer", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The position of the drawer.
    */
    get position() {
        return this.i.a;
    }
    set position(v) {
        this.i.a = ensureEnum(NavDrawerPosition_$type, v);
    }
    /**
     * Determines whether the drawer is opened.
    */
    get open() {
        return this.i.e;
    }
    set open(v) {
        this.i.e = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("NavDrawer");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Opens the drawer.
    
    */
    show() {
        let iv = this.i.f();
        return (iv);
    }
    /**
     * Closes the drawer.
    
    */
    hide() {
        let iv = this.i.d();
        return (iv);
    }
    /**
     * Toggles the open state of the drawer.
    
    */
    toggle() {
        let iv = this.i.g();
        return (iv);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrNavDrawerModule {
    static register() {
        TypeRegistrar.registerCons('IgrNavDrawer', IgrNavDrawer);
        TypeRegistrar.registerCons('IgrNavDrawer', IgrNavDrawer);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var CardActionsOrientation = /*@__PURE__*/ (function (CardActionsOrientation) {
    CardActionsOrientation[CardActionsOrientation["Horizontal"] = 0] = "Horizontal";
    CardActionsOrientation[CardActionsOrientation["Vertical"] = 1] = "Vertical";
    return CardActionsOrientation;
})({});
/**
 * @hidden
 */
let CardActionsOrientation_$type = /*@__PURE__*/ markEnum('CardActionsOrientation', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CardActions = /*@__PURE__*/ (() => {
    class CardActions extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.d = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.b.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.n("orientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(CardActionsOrientation_$type, EnumUtil.getEnumValue(CardActionsOrientation_$type, this.c.f(CardActionsOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(CardActionsOrientation_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(CardActionsOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("orientation", value_);
        }
    }
    CardActions.$t = /*@__PURE__*/ markType(CardActions, 'CardActions', BaseElement.$);
    return CardActions;
})();

/**
 * A container for card action items like buttons
*/
class IgrCardActions extends Component {
    createImplementation() {
        return new CardActions();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCardActionsComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-card-actions", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The orientation of the actions.
    */
    get orientation() {
        return this.i.a;
    }
    set orientation(v) {
        this.i.a = ensureEnum(CardActionsOrientation_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("CardActions");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCardActionsModule {
    static register() {
        TypeRegistrar.registerCons('IgrCardActions', IgrCardActions);
        TypeRegistrar.registerCons('IgrCardActions', IgrCardActions);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CardContent = /*@__PURE__*/ (() => {
    class CardContent extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    CardContent.$t = /*@__PURE__*/ markType(CardContent, 'CardContent', BaseElement.$);
    return CardContent;
})();

/**
 * A container for card's text content
*/
class IgrCardContent extends Component {
    createImplementation() {
        return new CardContent();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCardContentComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-card-content", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("CardContent");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCardContentModule {
    static register() {
        TypeRegistrar.registerCons('IgrCardContent', IgrCardContent);
        TypeRegistrar.registerCons('IgrCardContent', IgrCardContent);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CardHeader = /*@__PURE__*/ (() => {
    class CardHeader extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    CardHeader.$t = /*@__PURE__*/ markType(CardHeader, 'CardHeader', BaseElement.$);
    return CardHeader;
})();

/**
 * A container for card's header
*/
class IgrCardHeader extends Component {
    createImplementation() {
        return new CardHeader();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCardHeaderComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-card-header", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("CardHeader");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCardHeaderModule {
    static register() {
        TypeRegistrar.registerCons('IgrCardHeader', IgrCardHeader);
        TypeRegistrar.registerCons('IgrCardHeader', IgrCardHeader);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CardMedia = /*@__PURE__*/ (() => {
    class CardMedia extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    CardMedia.$t = /*@__PURE__*/ markType(CardMedia, 'CardMedia', BaseElement.$);
    return CardMedia;
})();

/**
 * A container for card's media - could be an image, gif, video
*/
class IgrCardMedia extends Component {
    createImplementation() {
        return new CardMedia();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCardMediaComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-card-media", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("CardMedia");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCardMediaModule {
    static register() {
        TypeRegistrar.registerCons('IgrCardMedia', IgrCardMedia);
        TypeRegistrar.registerCons('IgrCardMedia', IgrCardMedia);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var SliderBaseTickOrientation = /*@__PURE__*/ (function (SliderBaseTickOrientation) {
    SliderBaseTickOrientation[SliderBaseTickOrientation["Start"] = 0] = "Start";
    SliderBaseTickOrientation[SliderBaseTickOrientation["End"] = 1] = "End";
    SliderBaseTickOrientation[SliderBaseTickOrientation["Mirror"] = 2] = "Mirror";
    return SliderBaseTickOrientation;
})({});
/**
 * @hidden
 */
let SliderBaseTickOrientation_$type = /*@__PURE__*/ markEnum('SliderBaseTickOrientation', 'Start,0|End,1|Mirror,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TickLabelRotation = /*@__PURE__*/ (function (TickLabelRotation) {
    TickLabelRotation[TickLabelRotation["Zero"] = 0] = "Zero";
    TickLabelRotation[TickLabelRotation["Ninety"] = 1] = "Ninety";
    TickLabelRotation[TickLabelRotation["NegativeNinety"] = 2] = "NegativeNinety";
    return TickLabelRotation;
})({});
/**
 * @hidden
 */
let TickLabelRotation_$type = /*@__PURE__*/ markEnum('TickLabelRotation', 'Zero:0,0|Ninety:90,1|NegativeNinety:-90,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SliderBase = /*@__PURE__*/ (() => {
    class SliderBase extends BaseElement {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.r = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.r;
        }
        set nativeElement(a) {
            this.r = a;
            this.d.o = this.r;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get m() {
            let ret_ = this.e.n("min");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.e.w("min", value_);
        }
        get l() {
            let ret_ = this.e.n("max");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.e.w("max", value_);
        }
        get k() {
            let ret_ = this.e.n("lowerBound");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.e.w("lowerBound", value_);
        }
        get q() {
            let ret_ = this.e.n("upperBound");
            return ret_;
        }
        set q(a) {
            let value_ = a;
            this.e.w("upperBound", value_);
        }
        get f() {
            let ret_ = this.e.n("disabled");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.e.w("disabled", value_);
        }
        get g() {
            let ret_ = this.e.n("discreteTrack");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.e.w("discreteTrack", value_);
        }
        get j() {
            let ret_ = this.e.n("hideTooltip");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.e.w("hideTooltip", value_);
        }
        get p() {
            let ret_ = this.e.n("step");
            return ret_;
        }
        set p(a) {
            let value_ = a;
            this.e.w("step", value_);
        }
        get n() {
            let ret_ = this.e.n("primaryTicks");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.e.w("primaryTicks", value_);
        }
        get o() {
            let ret_ = this.e.n("secondaryTicks");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.e.w("secondaryTicks", value_);
        }
        get b() {
            let ret_ = this.e.n("tickOrientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(SliderBaseTickOrientation_$type, EnumUtil.getEnumValue(SliderBaseTickOrientation_$type, this.e.f(SliderBaseTickOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(SliderBaseTickOrientation_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(SliderBaseTickOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("tickOrientation", value_);
        }
        get h() {
            let ret_ = this.e.n("hidePrimaryLabels");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.e.w("hidePrimaryLabels", value_);
        }
        get i() {
            let ret_ = this.e.n("hideSecondaryLabels");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.e.w("hideSecondaryLabels", value_);
        }
        get t() {
            let ret_ = this.e.n("locale");
            return ret_;
        }
        set t(a) {
            let value_ = a;
            this.e.w("locale", value_);
        }
        get u() {
            let ret_ = this.e.n("valueFormat");
            return ret_;
        }
        set u(a) {
            let value_ = a;
            this.e.w("valueFormat", value_);
        }
        get c() {
            let ret_ = this.e.n("tickLabelRotation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TickLabelRotation_$type, EnumUtil.getEnumValue(TickLabelRotation_$type, this.e.f(TickLabelRotation_$type, ret_)));
            return EnumUtil.getEnumValue(TickLabelRotation_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(TickLabelRotation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("tickLabelRotation", value_);
        }
        v() {
            this.nativeElement.connectedCallback();
        }
        get a() {
            let ret_ = this.e.n("valueFormatOptions");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.e.w("valueFormatOptions", value_);
        }
    }
    SliderBase.$t = /*@__PURE__*/ markType(SliderBase, 'SliderBase', BaseElement.$);
    return SliderBase;
})();

class IgrSliderBase extends Component {
    createImplementation() {
        return new SliderBase();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-slider-base", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The minimum value of the slider scale. Defaults to 0.
     * If `min` is greater than `max` the call is a no-op.
     * If `labels` are provided (projected), then `min` is always set to 0.
     * If `lowerBound` ends up being less than than the current `min` value,
     * it is automatically assigned the new `min` value.
    */
    get min() {
        return this.i.m;
    }
    set min(v) {
        this.i.m = +v;
    }
    /**
     * The maximum value of the slider scale. Defaults to 100.
     * If `max` is less than `min` the call is a no-op.
     * If `labels` are provided (projected), then `max` is always set to
     * the number of labels.
     * If `upperBound` ends up being greater than than the current `max` value,
     * it is automatically assigned the new `max` value.
    */
    get max() {
        return this.i.l;
    }
    set max(v) {
        this.i.l = +v;
    }
    /**
     * The lower bound of the slider value. If not set, the `min` value is applied.
    */
    get lowerBound() {
        return this.i.k;
    }
    set lowerBound(v) {
        this.i.k = +v;
    }
    /**
     * The upper bound of the slider value. If not set, the `max` value is applied.
    */
    get upperBound() {
        return this.i.q;
    }
    set upperBound(v) {
        this.i.q = +v;
    }
    /**
     * Disables the UI interactions of the slider.
    */
    get disabled() {
        return this.i.f;
    }
    set disabled(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * Marks the slider track as discrete so it displays the steps.
     * If the `step` is 0, the slider will remain continuos even if `discreteTrack` is `true`.
    */
    get discreteTrack() {
        return this.i.g;
    }
    set discreteTrack(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * Hides the thumb tooltip.
    */
    get hideTooltip() {
        return this.i.j;
    }
    set hideTooltip(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * Specifies the granularity that the value must adhere to.
     * If set to 0 no stepping is implied and any value in the range is allowed.
     * If `labels` are provided (projected) then the step is always assumed to be 1 since it is a discrete slider.
    */
    get step() {
        return this.i.p;
    }
    set step(v) {
        this.i.p = +v;
    }
    /**
     * The number of primary ticks. It defaults to 0 which means no primary ticks are displayed.
    */
    get primaryTicks() {
        return this.i.n;
    }
    set primaryTicks(v) {
        this.i.n = +v;
    }
    /**
     * The number of secondary ticks. It defaults to 0 which means no secondary ticks are displayed.
    */
    get secondaryTicks() {
        return this.i.o;
    }
    set secondaryTicks(v) {
        this.i.o = +v;
    }
    /**
     * Changes the orientation of the ticks.
    */
    get tickOrientation() {
        return this.i.b;
    }
    set tickOrientation(v) {
        this.i.b = ensureEnum(SliderBaseTickOrientation_$type, v);
    }
    /**
     * Hides the primary tick labels.
    */
    get hidePrimaryLabels() {
        return this.i.h;
    }
    set hidePrimaryLabels(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Hides the secondary tick labels.
    */
    get hideSecondaryLabels() {
        return this.i.i;
    }
    set hideSecondaryLabels(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * The locale used to format the thumb and tick label values in the slider.
    */
    get locale() {
        return this.i.t;
    }
    set locale(v) {
        this.i.t = v;
    }
    /**
     * String format used for the thumb and tick label values in the slider.
    */
    get valueFormat() {
        return this.i.u;
    }
    set valueFormat(v) {
        this.i.u = v;
    }
    /**
     * The degrees for the rotation of the tick labels. Defaults to 0.
    */
    get tickLabelRotation() {
        return this.i.c;
    }
    set tickLabelRotation(v) {
        this.i.c = ensureEnum(TickLabelRotation_$type, v);
    }
    /**
     * Number format options used for the thumb and tick label values in the slider.
    */
    get valueFormatOptions() {
        return this.i.a;
    }
    set valueFormatOptions(v) {
        this.i.a = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.valueFormatOptions && this.valueFormatOptions.name && this.valueFormatOptions.name == name) {
            return this.valueFormatOptions;
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("SliderBase");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.v();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSliderBaseModule {
    static register() {
        TypeRegistrar.registerCons('IgrSliderBase', IgrSliderBase);
        TypeRegistrar.registerCons('IgrSliderBase', IgrSliderBase);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RangeSliderValue = /*@__PURE__*/ (() => {
    class RangeSliderValue extends Base {
        constructor() {
            super(...arguments);
            this.a = 0;
            this.b = 0;
        }
    }
    RangeSliderValue.$t = /*@__PURE__*/ markType(RangeSliderValue, 'RangeSliderValue');
    return RangeSliderValue;
})();

class IgrRangeSliderValue {
    createImplementation() {
        return new RangeSliderValue();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get lower() {
        return this.i.a;
    }
    set lower(v) {
        this.i.a = +v;
    }
    get upper() {
        return this.i.b;
    }
    set upper(v) {
        this.i.b = +v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RangeSliderValueEventArgs = /*@__PURE__*/ (() => {
    class RangeSliderValueEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new RangeSliderValueEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    RangeSliderValueEventArgs.$t = /*@__PURE__*/ markType(RangeSliderValueEventArgs, 'RangeSliderValueEventArgs');
    return RangeSliderValueEventArgs;
})();

class IgrRangeSliderValueEventArgs {
    createImplementation() {
        return new RangeSliderValueEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrRangeSliderValue();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RangeSlider = /*@__PURE__*/ (() => {
    class RangeSlider extends SliderBase {
        constructor() {
            super(...arguments);
            this.input = null;
            this.change = null;
        }
        get z() {
            let ret_ = this.e.n("lower");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.e.w("lower", value_);
        }
        get aa() {
            let ret_ = this.e.n("upper");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.e.w("upper", value_);
        }
        get ab() {
            let ret_ = this.e.n("thumbLabelLower");
            return ret_;
        }
        set ab(a) {
            let value_ = a;
            this.e.w("thumbLabelLower", value_);
        }
        get ac() {
            let ret_ = this.e.n("thumbLabelUpper");
            return ret_;
        }
        set ac(a) {
            let value_ = a;
            this.e.w("thumbLabelUpper", value_);
        }
        inputChanged() {
            if (this.input != null) {
                this.e.s("input", (a) => this.input(this, RangeSliderValueEventArgs.b(a)));
            }
            else {
                this.e.v("input");
            }
        }
        changeChanged() {
            if (this.change != null) {
                this.e.s("change", (a) => this.change(this, RangeSliderValueEventArgs.b(a)));
            }
            else {
                this.e.v("change");
            }
        }
    }
    RangeSlider.$t = /*@__PURE__*/ markType(RangeSlider, 'RangeSlider', SliderBase.$);
    return RangeSlider;
})();

/**
 * A range slider component used to select two numeric values within a range.
*/
class IgrRangeSlider extends IgrSliderBase {
    createImplementation() {
        return new RangeSlider();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._input = null;
        this._input_wrapped = null;
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcRangeSliderComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-range-slider", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The current value of the lower thumb.
    */
    get lower() {
        return this.i.z;
    }
    set lower(v) {
        this.i.z = +v;
    }
    /**
     * The current value of the upper thumb.
    */
    get upper() {
        return this.i.aa;
    }
    set upper(v) {
        this.i.aa = +v;
    }
    /**
     * The aria label for the lower thumb.
    */
    get thumbLabelLower() {
        return this.i.ab;
    }
    set thumbLabelLower(v) {
        this.i.ab = v;
    }
    /**
     * The aria label for the upper thumb.
    */
    get thumbLabelUpper() {
        return this.i.ac;
    }
    set thumbLabelUpper(v) {
        this.i.ac = v;
    }
    /**
     * Emitted when a value is changed via thumb drag or keyboard interaction.
    */
    get input() {
        return this._input;
    }
    set input(ev) {
        if (this._input_wrapped !== null) {
            this.i.input = delegateRemove(this.i.input, this._input_wrapped);
            this._input_wrapped = null;
            this._input = null;
        }
        this._input = ev;
        this._input_wrapped = (o, e) => {
            let outerArgs = new IgrRangeSliderValueEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeInput) {
                this.beforeInput(this, outerArgs);
            }
            if (this._input) {
                this._input(this, outerArgs);
            }
        };
        this.i.input = delegateCombine(this.i.input, this._input_wrapped);
        if (this.i.inputChanged) {
            this.i.inputChanged();
        }
        ;
    }
    /**
     * Emitted when a value change is committed on a thumb drag end or keyboard interaction.
    */
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrRangeSliderValueEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRangeSliderModule {
    static register() {
        IgrSliderBaseModule.register();
        TypeRegistrar.registerCons('IgrRangeSliderValueEventArgs', IgrRangeSliderValueEventArgs);
        TypeRegistrar.registerCons('IgrRangeSlider', IgrRangeSlider);
        TypeRegistrar.registerCons('IgrRangeSlider', IgrRangeSlider);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let NumberEventArgs = /*@__PURE__*/ (() => {
    class NumberEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = 0;
        }
        static a(a) {
            return ((() => {
                let $ret = new NumberEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    NumberEventArgs.$t = /*@__PURE__*/ markType(NumberEventArgs, 'NumberEventArgs');
    return NumberEventArgs;
})();

class IgrNumberEventArgs {
    createImplementation() {
        return new NumberEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        return this.i.b;
    }
    set detail(v) {
        this.i.b = +v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Slider = /*@__PURE__*/ (() => {
    class Slider extends SliderBase {
        constructor() {
            super(...arguments);
            this.input = null;
            this.change = null;
        }
        get aa() {
            let ret_ = this.e.n("value");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.e.w("value", value_);
        }
        get ab() {
            let ret_ = this.e.n("name");
            return ret_;
        }
        set ab(a) {
            let value_ = a;
            this.e.w("name", value_);
        }
        get z() {
            let ret_ = this.e.n("invalid");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.e.w("invalid", value_);
        }
        inputChanged() {
            if (this.input != null) {
                this.e.s("input", (a) => this.input(this, NumberEventArgs.a(a)));
            }
            else {
                this.e.v("input");
            }
        }
        changeChanged() {
            if (this.change != null) {
                this.e.s("change", (a) => this.change(this, NumberEventArgs.a(a)));
            }
            else {
                this.e.v("change");
            }
        }
        ai(a = -1) {
            this.nativeElement.stepUp(this.e.i(a));
        }
        ah(a = -1) {
            this.nativeElement.stepDown(this.e.i(a));
        }
        af() {
            this.nativeElement.reportValidity();
        }
        ad() {
            this.nativeElement.checkValidity();
        }
        ag(a) {
            this.nativeElement.setCustomValidity(this.e.i(a));
        }
    }
    Slider.$t = /*@__PURE__*/ markType(Slider, 'Slider', SliderBase.$);
    return Slider;
})();

/**
 * A slider component used to select numeric value within a range.
*/
class IgrSlider extends IgrSliderBase {
    createImplementation() {
        return new Slider();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._input = null;
        this._input_wrapped = null;
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSliderComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-slider", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The current value of the component.
    */
    get value() {
        return this.i.aa;
    }
    set value(v) {
        this.i.aa = +v;
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.ab;
    }
    set name(v) {
        this.i.ab = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.z;
    }
    set invalid(v) {
        this.i.z = ensureBool(v);
    }
    /**
     * Increments the value of the slider by `stepIncrement * step`, where `stepIncrement` defaults to 1.
     * stepIncrement Optional step increment. If no parameter is passed, it defaults to 1.
    
    * @param stepIncrement  * Optional step increment. If no parameter is passed, it defaults to 1.
    */
    stepUp(stepIncrement) {
        this.i.ai(stepIncrement);
    }
    /**
     * Decrements the value of the slider by `stepDecrement * step`, where `stepDecrement` defaults to 1.
     * stepDecrement Optional step decrement. If no parameter is passed, it defaults to 1.
    
    * @param stepDecrement  * Optional step decrement. If no parameter is passed, it defaults to 1.
    */
    stepDown(stepDecrement) {
        this.i.ah(stepDecrement);
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.af();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.ad();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.ag(message);
    }
    /**
     * Emitted when a value is changed via thumb drag or keyboard interaction.
    */
    get input() {
        return this._input;
    }
    set input(ev) {
        if (this._input_wrapped !== null) {
            this.i.input = delegateRemove(this.i.input, this._input_wrapped);
            this._input_wrapped = null;
            this._input = null;
        }
        this._input = ev;
        this._input_wrapped = (o, e) => {
            let outerArgs = new IgrNumberEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeInput) {
                this.beforeInput(this, outerArgs);
            }
            if (this._input) {
                this._input(this, outerArgs);
            }
        };
        this.i.input = delegateCombine(this.i.input, this._input_wrapped);
        if (this.i.inputChanged) {
            this.i.inputChanged();
        }
        ;
    }
    /**
     * Emitted when a value change is committed on a thumb drag end or keyboard interaction.
    */
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrNumberEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSliderModule {
    static register() {
        IgrSliderBaseModule.register();
        TypeRegistrar.registerCons('IgrSlider', IgrSlider);
        TypeRegistrar.registerCons('IgrSlider', IgrSlider);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SliderLabel = /*@__PURE__*/ (() => {
    class SliderLabel extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    SliderLabel.$t = /*@__PURE__*/ markType(SliderLabel, 'SliderLabel', BaseElement.$);
    return SliderLabel;
})();

class IgrSliderLabel extends Component {
    createImplementation() {
        return new SliderLabel();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSliderLabelComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-slider-label", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("SliderLabel");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSliderLabelModule {
    static register() {
        TypeRegistrar.registerCons('IgrSliderLabel', IgrSliderLabel);
        TypeRegistrar.registerCons('IgrSliderLabel', IgrSliderLabel);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ComponentBoolValueChangedEventArgs = /*@__PURE__*/ (() => {
    class ComponentBoolValueChangedEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = false;
        }
        static a(a) {
            return ((() => {
                let $ret = new ComponentBoolValueChangedEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    ComponentBoolValueChangedEventArgs.$t = /*@__PURE__*/ markType(ComponentBoolValueChangedEventArgs, 'ComponentBoolValueChangedEventArgs');
    return ComponentBoolValueChangedEventArgs;
})();

class IgrComponentBoolValueChangedEventArgs {
    createImplementation() {
        return new ComponentBoolValueChangedEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        return this.i.b;
    }
    set detail(v) {
        this.i.b = ensureBool(v);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Chip = /*@__PURE__*/ (() => {
    class Chip extends BaseElement {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.j = null;
            this.remove = null;
            this.select = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.j;
        }
        set nativeElement(a) {
            this.j = a;
            this.d.o = this.j;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get f() {
            let ret_ = this.e.n("disabled");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.e.w("disabled", value_);
        }
        get g() {
            let ret_ = this.e.n("removable");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.e.w("removable", value_);
        }
        get h() {
            let ret_ = this.e.n("selectable");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.e.w("selectable", value_);
        }
        get i() {
            let ret_ = this.e.n("selected");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.e.w("selected", value_);
        }
        get c() {
            let ret_ = this.e.n("variant");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StyleVariant_$type, EnumUtil.getEnumValue(StyleVariant_$type, this.e.f(StyleVariant_$type, ret_)));
            return EnumUtil.getEnumValue(StyleVariant_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(StyleVariant_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("variant", value_);
        }
        removeChanged() {
            if (this.remove != null) {
                this.e.s("remove", (a) => this.remove(this, ComponentBoolValueChangedEventArgs.a(a)));
            }
            else {
                this.e.v("remove");
            }
        }
        selectChanged() {
            if (this.select != null) {
                this.e.s("select", (a) => this.select(this, ComponentBoolValueChangedEventArgs.a(a)));
            }
            else {
                this.e.v("select");
            }
        }
    }
    Chip.$t = /*@__PURE__*/ markType(Chip, 'Chip', BaseElement.$);
    return Chip;
})();

/**
 * Chips help people enter information, make selections, filter content, or trigger actions.
*/
class IgrChip extends Component {
    createImplementation() {
        return new Chip();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._remove = null;
        this._remove_wrapped = null;
        this._select = null;
        this._select_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcChipComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-chip", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Sets the disabled state for the chip.
    */
    get disabled() {
        return this.i.f;
    }
    set disabled(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * Defines if the chip is removable or not.
    */
    get removable() {
        return this.i.g;
    }
    set removable(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * Defines if the chip is selectable or not.
    */
    get selectable() {
        return this.i.h;
    }
    set selectable(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * Defines if the chip is selected or not.
    */
    get selected() {
        return this.i.i;
    }
    set selected(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * A property that sets the color variant of the chip component.
    */
    get variant() {
        return this.i.c;
    }
    set variant(v) {
        this.i.c = ensureEnum(StyleVariant_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Chip");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    get remove() {
        return this._remove;
    }
    set remove(ev) {
        if (this._remove_wrapped !== null) {
            this.i.remove = delegateRemove(this.i.remove, this._remove_wrapped);
            this._remove_wrapped = null;
            this._remove = null;
        }
        this._remove = ev;
        this._remove_wrapped = (o, e) => {
            let outerArgs = new IgrComponentBoolValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeRemove) {
                this.beforeRemove(this, outerArgs);
            }
            if (this._remove) {
                this._remove(this, outerArgs);
            }
        };
        this.i.remove = delegateCombine(this.i.remove, this._remove_wrapped);
        if (this.i.removeChanged) {
            this.i.removeChanged();
        }
        ;
    }
    get select() {
        return this._select;
    }
    set select(ev) {
        if (this._select_wrapped !== null) {
            this.i.select = delegateRemove(this.i.select, this._select_wrapped);
            this._select_wrapped = null;
            this._select = null;
        }
        this._select = ev;
        this._select_wrapped = (o, e) => {
            let outerArgs = new IgrComponentBoolValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelect) {
                this.beforeSelect(this, outerArgs);
            }
            if (this._select) {
                this._select(this, outerArgs);
            }
        };
        this.i.select = delegateCombine(this.i.select, this._select_wrapped);
        if (this.i.selectChanged) {
            this.i.selectChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrChipModule {
    static register() {
        TypeRegistrar.registerCons('IgrChip', IgrChip);
        TypeRegistrar.registerCons('IgrChip', IgrChip);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CircularGradient = /*@__PURE__*/ (() => {
    class CircularGradient extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.d = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.a.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get g() {
            let ret_ = this.b.n("offset");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.b.w("offset", value_);
        }
        get f() {
            let ret_ = this.b.n("color");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.b.w("color", value_);
        }
        get c() {
            let ret_ = this.b.n("opacity");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("opacity", value_);
        }
    }
    CircularGradient.$t = /*@__PURE__*/ markType(CircularGradient, 'CircularGradient', BaseElement.$);
    return CircularGradient;
})();

/**
 * Used for defining gradient stops in the igc-circular-progress.
 * For each `igc-circular-gradient` defined as `gradient` slot of `igc-circular-progress` element would be created a SVG stop element.
 * The values passed as `color`, `offset` and `opacity` would be set as
 * `stop-color`, `offset` and `stop-opacity` of the SVG element without further validations.
*/
class IgrCircularGradient extends Component {
    createImplementation() {
        return new CircularGradient();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCircularGradientComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-circular-gradient", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Defines where the gradient stop is placed along the gradient vector
    */
    get offset() {
        return this.i.g;
    }
    set offset(v) {
        this.i.g = v;
    }
    /**
     * Defines the color of the gradient stop
    */
    get color() {
        return this.i.f;
    }
    set color(v) {
        this.i.f = v;
    }
    /**
     * Defines the opacity of the gradient stop
    */
    get opacity() {
        return this.i.c;
    }
    set opacity(v) {
        this.i.c = +v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("CircularGradient");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCircularGradientModule {
    static register() {
        TypeRegistrar.registerCons('IgrCircularGradient', IgrCircularGradient);
        TypeRegistrar.registerCons('IgrCircularGradient', IgrCircularGradient);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrProgressBaseModule {
    static register() {
    }
}

class IgrProgressBase extends Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
     * Maximum value of the control.
    */
    get max() {
        return this.i.g;
    }
    set max(v) {
        this.i.g = +v;
    }
    /**
     * The value of the control.
    */
    get value() {
        return this.i.h;
    }
    set value(v) {
        this.i.h = +v;
    }
    /**
     * The variant of the control.
    */
    get variant() {
        return this.i.a;
    }
    set variant(v) {
        this.i.a = ensureEnum(StyleVariant_$type, v);
    }
    /**
     * Animation duration in milliseconds.
    */
    get animationDuration() {
        return this.i.f;
    }
    set animationDuration(v) {
        this.i.f = +v;
    }
    /**
     * The indeterminate state of the control.
    */
    get indeterminate() {
        return this.i.e;
    }
    set indeterminate(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * Shows/hides the label of the control.
    */
    get hideLabel() {
        return this.i.d;
    }
    set hideLabel(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Format string for the default label of the control.
     * Placeholders:
     * {0} - current value of the control.
     * {1} - max value of the control.
    */
    get labelFormat() {
        return this.i.k;
    }
    set labelFormat(v) {
        this.i.k = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("ProgressBase");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.l();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ProgressBase = /*@__PURE__*/ (() => {
    class ProgressBase extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.i = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.i;
        }
        set nativeElement(a) {
            this.i = a;
            this.b.o = this.i;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get g() {
            let ret_ = this.c.n("max");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.c.w("max", value_);
        }
        get h() {
            let ret_ = this.c.n("value");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.c.w("value", value_);
        }
        get a() {
            let ret_ = this.c.n("variant");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StyleVariant_$type, EnumUtil.getEnumValue(StyleVariant_$type, this.c.f(StyleVariant_$type, ret_)));
            return EnumUtil.getEnumValue(StyleVariant_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(StyleVariant_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("variant", value_);
        }
        get f() {
            let ret_ = this.c.n("animationDuration");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.c.w("animationDuration", value_);
        }
        get e() {
            let ret_ = this.c.n("indeterminate");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.c.w("indeterminate", value_);
        }
        get d() {
            let ret_ = this.c.n("hideLabel");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.c.w("hideLabel", value_);
        }
        get k() {
            let ret_ = this.c.n("labelFormat");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.c.w("labelFormat", value_);
        }
        l() {
            this.nativeElement.connectedCallback();
        }
    }
    ProgressBase.$t = /*@__PURE__*/ markType(ProgressBase, 'ProgressBase', BaseElement.$);
    return ProgressBase;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CircularProgress = /*@__PURE__*/ (() => {
    class CircularProgress extends ProgressBase {
    }
    CircularProgress.$t = /*@__PURE__*/ markType(CircularProgress, 'CircularProgress', ProgressBase.$);
    return CircularProgress;
})();

/**
 * A circular progress indicator used to express unspecified wait time or display
 * the length of a process.
*/
class IgrCircularProgress extends IgrProgressBase {
    createImplementation() {
        return new CircularProgress();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcCircularProgressComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-circular-progress", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCircularProgressModule {
    static register() {
        IgrProgressBaseModule.register();
        TypeRegistrar.registerCons('IgrCircularProgress', IgrCircularProgress);
        TypeRegistrar.registerCons('IgrCircularProgress', IgrCircularProgress);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var LinearProgressLabelAlign = /*@__PURE__*/ (function (LinearProgressLabelAlign) {
    LinearProgressLabelAlign[LinearProgressLabelAlign["Bottom"] = 0] = "Bottom";
    LinearProgressLabelAlign[LinearProgressLabelAlign["Top"] = 1] = "Top";
    LinearProgressLabelAlign[LinearProgressLabelAlign["TopStart"] = 2] = "TopStart";
    LinearProgressLabelAlign[LinearProgressLabelAlign["TopEnd"] = 3] = "TopEnd";
    LinearProgressLabelAlign[LinearProgressLabelAlign["BottomStart"] = 4] = "BottomStart";
    LinearProgressLabelAlign[LinearProgressLabelAlign["BottomEnd"] = 5] = "BottomEnd";
    return LinearProgressLabelAlign;
})({});
/**
 * @hidden
 */
let LinearProgressLabelAlign_$type = /*@__PURE__*/ markEnum('LinearProgressLabelAlign', 'Bottom,0|Top,1|TopStart:top-start,2|TopEnd:top-end,3|BottomStart:bottom-start,4|BottomEnd:bottom-end,5');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LinearProgress = /*@__PURE__*/ (() => {
    class LinearProgress extends ProgressBase {
        get o() {
            let ret_ = this.c.n("striped");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.c.w("striped", value_);
        }
        get n() {
            let ret_ = this.c.n("labelAlign");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(LinearProgressLabelAlign_$type, EnumUtil.getEnumValue(LinearProgressLabelAlign_$type, this.c.f(LinearProgressLabelAlign_$type, ret_)));
            return EnumUtil.getEnumValue(LinearProgressLabelAlign_$type, ret_);
        }
        set n(a) {
            let value_ = enumGetBox(LinearProgressLabelAlign_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("labelAlign", value_);
        }
    }
    LinearProgress.$t = /*@__PURE__*/ markType(LinearProgress, 'LinearProgress', ProgressBase.$);
    return LinearProgress;
})();

/**
 * A linear progress indicator used to express unspecified wait time or display
 * the length of a process.
*/
class IgrLinearProgress extends IgrProgressBase {
    createImplementation() {
        return new LinearProgress();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcLinearProgressComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-linear-progress", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Sets the striped look of the control.
    */
    get striped() {
        return this.i.o;
    }
    set striped(v) {
        this.i.o = ensureBool(v);
    }
    /**
     * The position for the default label of the control.
    */
    get labelAlign() {
        return this.i.n;
    }
    set labelAlign(v) {
        this.i.n = ensureEnum(LinearProgressLabelAlign_$type, v);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrLinearProgressModule {
    static register() {
        IgrProgressBaseModule.register();
        TypeRegistrar.registerCons('IgrLinearProgress', IgrLinearProgress);
        TypeRegistrar.registerCons('IgrLinearProgress', IgrLinearProgress);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Rating = /*@__PURE__*/ (() => {
    class Rating extends BaseElement {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.n = null;
            this.change = null;
            this.hover = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.n;
        }
        set nativeElement(a) {
            this.n = a;
            this.c.o = this.n;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get k() {
            let ret_ = this.d.n("max");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.d.w("max", value_);
        }
        get l() {
            let ret_ = this.d.n("step");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.d.w("step", value_);
        }
        get p() {
            let ret_ = this.d.n("label");
            return ret_;
        }
        set p(a) {
            let value_ = a;
            this.d.w("label", value_);
        }
        get r() {
            let ret_ = this.d.n("valueFormat");
            return ret_;
        }
        set r(a) {
            let value_ = a;
            this.d.w("valueFormat", value_);
        }
        get m() {
            let ret_ = this.d.n("value");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.d.w("value", value_);
        }
        get g() {
            let ret_ = this.d.n("hoverPreview");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.d.w("hoverPreview", value_);
        }
        get i() {
            let ret_ = this.d.n("readOnly");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.d.w("readOnly", value_);
        }
        get j() {
            let ret_ = this.d.n("single");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.d.w("single", value_);
        }
        get e() {
            let ret_ = this.d.n("allowReset");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.d.w("allowReset", value_);
        }
        get f() {
            let ret_ = this.d.n("disabled");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.d.w("disabled", value_);
        }
        get q() {
            let ret_ = this.d.n("name");
            return ret_;
        }
        set q(a) {
            let value_ = a;
            this.d.w("name", value_);
        }
        get h() {
            let ret_ = this.d.n("invalid");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.d.w("invalid", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.d.s("change", (a) => this.change(this, NumberEventArgs.a(a)));
            }
            else {
                this.d.v("change");
            }
        }
        hoverChanged() {
            if (this.hover != null) {
                this.d.s("hover", (a) => this.hover(this, NumberEventArgs.a(a)));
            }
            else {
                this.d.v("hover");
            }
        }
        z(a = -1) {
            this.nativeElement.stepUp(this.d.i(a));
        }
        y(a = -1) {
            this.nativeElement.stepDown(this.d.i(a));
        }
        v() {
            this.nativeElement.reportValidity();
        }
        t() {
            this.nativeElement.checkValidity();
        }
        w(a) {
            this.nativeElement.setCustomValidity(this.d.i(a));
        }
    }
    Rating.$t = /*@__PURE__*/ markType(Rating, 'Rating', BaseElement.$);
    return Rating;
})();

/**
 * Rating provides insight regarding others' opinions and experiences,
 * and can allow the user to submit a rating of their own
 * @cssproperty --symbol-size - The size of the symbols.
 * @cssproperty --symbol-full-color - The color of the filled symbol.
 * @cssproperty --symbol-empty-color - The color of the empty symbol.
 * @cssproperty --symbol-full-filter - The filter(s) used for the filled symbol.
 * @cssproperty --symbol-empty-filter - The filter(s) used for the empty symbol.
*/
class IgrRating extends Component {
    createImplementation() {
        return new Rating();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._change = null;
        this._change_wrapped = null;
        this._hover = null;
        this._hover_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcRatingComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-rating", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The maximum value for the rating.
     * If there are projected symbols, the maximum value will be resolved
     * based on the number of symbols.
    */
    get max() {
        return this.i.k;
    }
    set max(v) {
        this.i.k = +v;
    }
    /**
     * The minimum value change allowed.
     * Valid values are in the interval between 0 and 1 inclusive.
    */
    get step() {
        return this.i.l;
    }
    set step(v) {
        this.i.l = +v;
    }
    /**
     * The label of the control.
    */
    get label() {
        return this.i.p;
    }
    set label(v) {
        this.i.p = v;
    }
    /**
     * A format string which sets aria-valuetext. Instances of '{0}' will be replaced
     * with the current value of the control and instances of '{1}' with the maximum value for the control.
     * Important for screen-readers and useful for localization.
    */
    get valueFormat() {
        return this.i.r;
    }
    set valueFormat(v) {
        this.i.r = v;
    }
    /**
     * The current value of the component
    */
    get value() {
        return this.i.m;
    }
    set value(v) {
        this.i.m = +v;
    }
    /**
     * Sets hover preview behavior for the component
    */
    get hoverPreview() {
        return this.i.g;
    }
    set hoverPreview(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * Makes the control a readonly field.
    */
    get readOnly() {
        return this.i.i;
    }
    set readOnly(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * Toggles single selection visual mode.
    */
    get single() {
        return this.i.j;
    }
    set single(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * Whether to reset the rating when the user selects the same value.
    */
    get allowReset() {
        return this.i.e;
    }
    set allowReset(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.f;
    }
    set disabled(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.q;
    }
    set name(v) {
        this.i.q = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.h;
    }
    set invalid(v) {
        this.i.h = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Rating");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Increments the value of the control by `n` steps multiplied by the
     * step factor.
    
    */
    stepUp(n) {
        this.i.z(n);
    }
    /**
     * Decrements the value of the control by `n` steps multiplied by
     * the step factor.
    
    */
    stepDown(n) {
        this.i.y(n);
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.v();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.t();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.w(message);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrNumberEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get hover() {
        return this._hover;
    }
    set hover(ev) {
        if (this._hover_wrapped !== null) {
            this.i.hover = delegateRemove(this.i.hover, this._hover_wrapped);
            this._hover_wrapped = null;
            this._hover = null;
        }
        this._hover = ev;
        this._hover_wrapped = (o, e) => {
            let outerArgs = new IgrNumberEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeHover) {
                this.beforeHover(this, outerArgs);
            }
            if (this._hover) {
                this._hover(this, outerArgs);
            }
        };
        this.i.hover = delegateCombine(this.i.hover, this._hover_wrapped);
        if (this.i.hoverChanged) {
            this.i.hoverChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRatingModule {
    static register() {
        TypeRegistrar.registerCons('IgrRating', IgrRating);
        TypeRegistrar.registerCons('IgrRating', IgrRating);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let RatingSymbol = /*@__PURE__*/ (() => {
    class RatingSymbol extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        e() {
            this.nativeElement.connectedCallback();
        }
    }
    RatingSymbol.$t = /*@__PURE__*/ markType(RatingSymbol, 'RatingSymbol', BaseElement.$);
    return RatingSymbol;
})();

/**
 * Used when a custom icon/symbol/element needs to be passed to the igc-rating component.
*/
class IgrRatingSymbol extends Component {
    createImplementation() {
        return new RatingSymbol();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcRatingSymbolComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-rating-symbol", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("RatingSymbol");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.e();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrRatingSymbolModule {
    static register() {
        TypeRegistrar.registerCons('IgrRatingSymbol', IgrRatingSymbol);
        TypeRegistrar.registerCons('IgrRatingSymbol', IgrRatingSymbol);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBaseAlertLikeModule {
    static register() {
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var BaseAlertLikePosition = /*@__PURE__*/ (function (BaseAlertLikePosition) {
    BaseAlertLikePosition[BaseAlertLikePosition["Bottom"] = 0] = "Bottom";
    BaseAlertLikePosition[BaseAlertLikePosition["Middle"] = 1] = "Middle";
    BaseAlertLikePosition[BaseAlertLikePosition["Top"] = 2] = "Top";
    return BaseAlertLikePosition;
})({});
/**
 * @hidden
 */
let BaseAlertLikePosition_$type = /*@__PURE__*/ markEnum('BaseAlertLikePosition', 'Bottom,0|Middle,1|Top,2');

class IgrBaseAlertLike extends Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
     * Whether the component is in shown state.
    */
    get open() {
        return this.i.f;
    }
    set open(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * Determines the duration in ms in which the component will be visible.
    */
    get displayTime() {
        return this.i.i;
    }
    set displayTime(v) {
        this.i.i = +v;
    }
    /**
     * Determines whether the component should close after the `displayTime` is over.
    */
    get keepOpen() {
        return this.i.e;
    }
    set keepOpen(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * Sets the position of the component in the viewport.
    */
    get position() {
        return this.i.a;
    }
    set position(v) {
        this.i.a = ensureEnum(BaseAlertLikePosition_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("BaseAlertLike");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Opens the component.
    
    */
    show() {
        let iv = this.i.g();
        return (iv);
    }
    /**
     * Closes the component.
    
    */
    hide() {
        let iv = this.i.d();
        return (iv);
    }
    /**
     * Toggles the open state of the component.
    
    */
    toggle() {
        let iv = this.i.h();
        return (iv);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BaseAlertLike = /*@__PURE__*/ (() => {
    class BaseAlertLike extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.j = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.j;
        }
        set nativeElement(a) {
            this.j = a;
            this.b.o = this.j;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get f() {
            let ret_ = this.c.n("open");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.c.w("open", value_);
        }
        get i() {
            let ret_ = this.c.n("displayTime");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.c.w("displayTime", value_);
        }
        get e() {
            let ret_ = this.c.n("keepOpen");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.c.w("keepOpen", value_);
        }
        get a() {
            let ret_ = this.c.n("position");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(BaseAlertLikePosition_$type, EnumUtil.getEnumValue(BaseAlertLikePosition_$type, this.c.f(BaseAlertLikePosition_$type, ret_)));
            return EnumUtil.getEnumValue(BaseAlertLikePosition_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(BaseAlertLikePosition_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("position", value_);
        }
        g() {
            return (this.nativeElement.show());
        }
        d() {
            return (this.nativeElement.hide());
        }
        h() {
            return (this.nativeElement.toggle());
        }
    }
    BaseAlertLike.$t = /*@__PURE__*/ markType(BaseAlertLike, 'BaseAlertLike', BaseElement.$);
    return BaseAlertLike;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Snackbar = /*@__PURE__*/ (() => {
    class Snackbar extends BaseAlertLike {
        constructor() {
            super(...arguments);
            this.action = null;
        }
        get n() {
            let ret_ = this.c.n("actionText");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.c.w("actionText", value_);
        }
        actionChanged() {
            if (this.action != null) {
                this.c.s("action", (a) => this.action(this, VoidEventArgs.b(a)));
            }
            else {
                this.c.v("action");
            }
        }
    }
    Snackbar.$t = /*@__PURE__*/ markType(Snackbar, 'Snackbar', BaseAlertLike.$);
    return Snackbar;
})();

/**
 * A snackbar component is used to provide feedback about an operation
 * by showing a brief message at the bottom of the screen.
*/
class IgrSnackbar extends IgrBaseAlertLike {
    createImplementation() {
        return new Snackbar();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._action = null;
        this._action_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSnackbarComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-snackbar", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The snackbar action button.
    */
    get actionText() {
        return this.i.n;
    }
    set actionText(v) {
        this.i.n = v;
    }
    get action() {
        return this._action;
    }
    set action(ev) {
        if (this._action_wrapped !== null) {
            this.i.action = delegateRemove(this.i.action, this._action_wrapped);
            this._action_wrapped = null;
            this._action = null;
        }
        this._action = ev;
        this._action_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeAction) {
                this.beforeAction(this, outerArgs);
            }
            if (this._action) {
                this._action(this, outerArgs);
            }
        };
        this.i.action = delegateCombine(this.i.action, this._action_wrapped);
        if (this.i.actionChanged) {
            this.i.actionChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSnackbarModule {
    static register() {
        IgrBaseAlertLikeModule.register();
        TypeRegistrar.registerCons('IgrSnackbar', IgrSnackbar);
        TypeRegistrar.registerCons('IgrSnackbar', IgrSnackbar);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Toast = /*@__PURE__*/ (() => {
    class Toast extends BaseAlertLike {
    }
    Toast.$t = /*@__PURE__*/ markType(Toast, 'Toast', BaseAlertLike.$);
    return Toast;
})();

/**
 * A toast component is used to show a notification
*/
class IgrToast extends IgrBaseAlertLike {
    createImplementation() {
        return new Toast();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcToastComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-toast", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrToastModule {
    static register() {
        IgrBaseAlertLikeModule.register();
        TypeRegistrar.registerCons('IgrToast', IgrToast);
        TypeRegistrar.registerCons('IgrToast', IgrToast);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DropdownGroup = /*@__PURE__*/ (() => {
    class DropdownGroup extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    DropdownGroup.$t = /*@__PURE__*/ markType(DropdownGroup, 'DropdownGroup', BaseElement.$);
    return DropdownGroup;
})();

/**
 * A container for a group of `igc-dropdown-item` components.
*/
class IgrDropdownGroup extends Component {
    createImplementation() {
        return new DropdownGroup();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDropdownGroupComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-dropdown-group", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DropdownGroup");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDropdownGroupModule {
    static register() {
        TypeRegistrar.registerCons('IgrDropdownGroup', IgrDropdownGroup);
        TypeRegistrar.registerCons('IgrDropdownGroup', IgrDropdownGroup);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DropdownHeader = /*@__PURE__*/ (() => {
    class DropdownHeader extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    DropdownHeader.$t = /*@__PURE__*/ markType(DropdownHeader, 'DropdownHeader', BaseElement.$);
    return DropdownHeader;
})();

/**
 * Represents a header item in a igc-dropdown list.
*/
class IgrDropdownHeader extends Component {
    createImplementation() {
        return new DropdownHeader();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDropdownHeaderComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-dropdown-header", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DropdownHeader");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDropdownHeaderModule {
    static register() {
        TypeRegistrar.registerCons('IgrDropdownHeader', IgrDropdownHeader);
        TypeRegistrar.registerCons('IgrDropdownHeader', IgrDropdownHeader);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBaseOptionLikeModule {
    static register() {
    }
}

class IgrBaseOptionLike extends Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
     * Whether the item is active.
    */
    get active() {
        return this.i.c;
    }
    set active(v) {
        this.i.c = ensureBool(v);
    }
    /**
     * Whether the item is disabled.
    */
    get disabled() {
        return this.i.d;
    }
    set disabled(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Whether the item is selected.
    */
    get selected() {
        return this.i.e;
    }
    set selected(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * The current value of the item.
     * If not specified, the element's text content is used.
    */
    get value() {
        return this.i.h;
    }
    set value(v) {
        this.i.h = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("BaseOptionLike");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.i();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BaseOptionLike = /*@__PURE__*/ (() => {
    class BaseOptionLike extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.f = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.a.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.b.n("active");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("active", value_);
        }
        get d() {
            let ret_ = this.b.n("disabled");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("disabled", value_);
        }
        get e() {
            let ret_ = this.b.n("selected");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.b.w("selected", value_);
        }
        get h() {
            let ret_ = this.b.n("value");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.b.w("value", value_);
        }
        i() {
            this.nativeElement.connectedCallback();
        }
    }
    BaseOptionLike.$t = /*@__PURE__*/ markType(BaseOptionLike, 'BaseOptionLike', BaseElement.$);
    return BaseOptionLike;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DropdownItem = /*@__PURE__*/ (() => {
    class DropdownItem extends BaseOptionLike {
    }
    DropdownItem.$t = /*@__PURE__*/ markType(DropdownItem, 'DropdownItem', BaseOptionLike.$);
    return DropdownItem;
})();

/**
 * Represents an item in a dropdown list.
*/
class IgrDropdownItem extends IgrBaseOptionLike {
    createImplementation() {
        return new DropdownItem();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDropdownItemComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-dropdown-item", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDropdownItemModule {
    static register() {
        IgrBaseOptionLikeModule.register();
        TypeRegistrar.registerCons('IgrDropdownItem', IgrDropdownItem);
        TypeRegistrar.registerCons('IgrDropdownItem', IgrDropdownItem);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DropdownItemComponentEventArgs = /*@__PURE__*/ (() => {
    class DropdownItemComponentEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new DropdownItemComponentEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    DropdownItemComponentEventArgs.$t = /*@__PURE__*/ markType(DropdownItemComponentEventArgs, 'DropdownItemComponentEventArgs');
    return DropdownItemComponentEventArgs;
})();

class IgrDropdownItemComponentEventArgs {
    createImplementation() {
        return new DropdownItemComponentEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDropdownItem({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DropdownPlacement = /*@__PURE__*/ (function (DropdownPlacement) {
    DropdownPlacement[DropdownPlacement["Top"] = 0] = "Top";
    DropdownPlacement[DropdownPlacement["TopStart"] = 1] = "TopStart";
    DropdownPlacement[DropdownPlacement["TopEnd"] = 2] = "TopEnd";
    DropdownPlacement[DropdownPlacement["Bottom"] = 3] = "Bottom";
    DropdownPlacement[DropdownPlacement["BottomStart"] = 4] = "BottomStart";
    DropdownPlacement[DropdownPlacement["BottomEnd"] = 5] = "BottomEnd";
    DropdownPlacement[DropdownPlacement["Right"] = 6] = "Right";
    DropdownPlacement[DropdownPlacement["RightStart"] = 7] = "RightStart";
    DropdownPlacement[DropdownPlacement["RightEnd"] = 8] = "RightEnd";
    DropdownPlacement[DropdownPlacement["Left"] = 9] = "Left";
    DropdownPlacement[DropdownPlacement["LeftStart"] = 10] = "LeftStart";
    DropdownPlacement[DropdownPlacement["LeftEnd"] = 11] = "LeftEnd";
    return DropdownPlacement;
})({});
/**
 * @hidden
 */
let DropdownPlacement_$type = /*@__PURE__*/ markEnum('DropdownPlacement', 'Top,0|TopStart:top-start,1|TopEnd:top-end,2|Bottom,3|BottomStart:bottom-start,4|BottomEnd:bottom-end,5|Right,6|RightStart:right-start,7|RightEnd:right-end,8|Left,9|LeftStart:left-start,10|LeftEnd:left-end,11');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DropdownScrollStrategy = /*@__PURE__*/ (function (DropdownScrollStrategy) {
    DropdownScrollStrategy[DropdownScrollStrategy["Scroll"] = 0] = "Scroll";
    DropdownScrollStrategy[DropdownScrollStrategy["Block"] = 1] = "Block";
    DropdownScrollStrategy[DropdownScrollStrategy["Close"] = 2] = "Close";
    return DropdownScrollStrategy;
})({});
/**
 * @hidden
 */
let DropdownScrollStrategy_$type = /*@__PURE__*/ markEnum('DropdownScrollStrategy', 'Scroll,0|Block,1|Close,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Dropdown = /*@__PURE__*/ (() => {
    class Dropdown extends BaseComboBoxLike {
        constructor() {
            super(...arguments);
            this.opening = null;
            this.opened = null;
            this.closing = null;
            this.closed = null;
            this.change = null;
        }
        showTarget(target_) {
            this.nativeElement.show(target_);
        }
        toggleTarget(target_) {
            this.nativeElement.toggle(target_);
        }
        o(a) {
            return (this.nativeElement.navigateTo(a));
        }
        p(a) {
            return (this.nativeElement.select(a));
        }
        get s() {
            let ret_ = this.b.n("placement");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DropdownPlacement_$type, EnumUtil.getEnumValue(DropdownPlacement_$type, this.b.f(DropdownPlacement_$type, ret_)));
            return EnumUtil.getEnumValue(DropdownPlacement_$type, ret_);
        }
        set s(a) {
            let value_ = enumGetBox(DropdownPlacement_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("placement", value_);
        }
        get t() {
            let ret_ = this.b.n("scrollStrategy");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DropdownScrollStrategy_$type, EnumUtil.getEnumValue(DropdownScrollStrategy_$type, this.b.f(DropdownScrollStrategy_$type, ret_)));
            return EnumUtil.getEnumValue(DropdownScrollStrategy_$type, ret_);
        }
        set t(a) {
            let value_ = enumGetBox(DropdownScrollStrategy_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("scrollStrategy", value_);
        }
        get y() {
            let ret_ = this.b.n("flip");
            return ret_;
        }
        set y(a) {
            let value_ = a;
            this.b.w("flip", value_);
        }
        get aa() {
            let ret_ = this.b.n("distance");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.b.w("distance", value_);
        }
        get z() {
            let ret_ = this.b.n("sameWidth");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.b.w("sameWidth", value_);
        }
        get n() {
            let ret_ = this.b.m("items", (a) => new DropdownItem());
            return ret_;
        }
        get m() {
            let ret_ = this.b.m("groups", (a) => new DropdownGroup());
            return ret_;
        }
        get q() {
            let ret_ = this.b.m("selectedItem", (a) => new DropdownItem());
            return ret_;
        }
        openingChanged() {
            if (this.opening != null) {
                this.b.s("opening", (a) => this.opening(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("opening");
            }
        }
        openedChanged() {
            if (this.opened != null) {
                this.b.s("opened", (a) => this.opened(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("opened");
            }
        }
        closingChanged() {
            if (this.closing != null) {
                this.b.s("closing", (a) => this.closing(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("closing");
            }
        }
        closedChanged() {
            if (this.closed != null) {
                this.b.s("closed", (a) => this.closed(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("closed");
            }
        }
        changeChanged() {
            if (this.change != null) {
                this.b.s("change", (a) => this.change(this, DropdownItemComponentEventArgs.b(a)));
            }
            else {
                this.b.v("change");
            }
        }
        af() {
            this.nativeElement.disconnectedCallback();
        }
        ac() {
            this.nativeElement.clearSelection();
        }
    }
    Dropdown.$t = /*@__PURE__*/ markType(Dropdown, 'Dropdown', BaseComboBoxLike.$);
    return Dropdown;
})();

/**
 * Represents a DropDown component.
*/
class IgrDropdown extends IgrBaseComboBoxLike {
    createImplementation() {
        return new Dropdown();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._opening = null;
        this._opening_wrapped = null;
        this._opened = null;
        this._opened_wrapped = null;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcDropdownComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-dropdown", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The preferred placement of the component around the target element.
     * @type {'top' | 'top-start' | 'top-end' | 'bottom' | 'bottom-start' | 'bottom-end' | 'right' | 'right-start' | 'right-end' | 'left' | 'left-start' | 'left-end'}
    */
    get placement() {
        return this.i.s;
    }
    set placement(v) {
        this.i.s = ensureEnum(DropdownPlacement_$type, v);
    }
    /**
     * Determines the behavior of the component during scrolling of the parent container.
    */
    get scrollStrategy() {
        return this.i.t;
    }
    set scrollStrategy(v) {
        this.i.t = ensureEnum(DropdownScrollStrategy_$type, v);
    }
    /**
     * Whether the component should be flipped to the opposite side of the target once it's about to overflow the visible area.
     * When true, once enough space is detected on its preferred side, it will flip back.
    */
    get flip() {
        return this.i.y;
    }
    set flip(v) {
        this.i.y = ensureBool(v);
    }
    /**
     * The distance from the target element.
    */
    get distance() {
        return this.i.aa;
    }
    set distance(v) {
        this.i.aa = +v;
    }
    /**
     * Whether the dropdown's width should be the same as the target's one.
    */
    get sameWidth() {
        return this.i.z;
    }
    set sameWidth(v) {
        this.i.z = ensureBool(v);
    }
    /**
     * Returns the items of the dropdown.
    */
    get items() {
        if (!this.i.n) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.n.length; i++) {
            let impl = this.i.n[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrDropdownItem) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrDropdownItem._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    /**
     * Returns the group items of the dropdown.
    */
    get groups() {
        if (!this.i.m) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.m.length; i++) {
            let impl = this.i.m[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrDropdownGroup) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrDropdownGroup._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    /**
     * Returns the selected item from the dropdown or null.
    */
    get selectedItem() {
        const r = this.i.q;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDropdownItem({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.selectedItem && this.selectedItem._styling) {
            this.selectedItem._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Shows the dropdown.
    
    */
    showTarget(target_) {
        this.i.showTarget(target_);
    }
    /**
     * Toggles the open state of the dropdown.
    
    */
    toggleTarget(target_) {
        this.i.toggleTarget(target_);
    }
    /**
     * Navigates to the item at the specified index. If it exists, returns the found item, otherwise - null.
    
    */
    navigateTo(index) {
        let iv = this.i.o(index);
        let ret = null;
        if (iv && iv.externalObject) {
            ret = iv.externalObject;
        }
        else {
            if (iv) {
                let e = IgrDropdownItem._createFromInternal(iv);
                e._implementation = iv;
                iv.externalObject = e;
                ret = e;
            }
        }
        return ret;
    }
    /**
     * Selects the item with the specified value. If it exists, returns the found item, otherwise - null.
    
    */
    select(value) {
        let iv = this.i.p(value);
        let ret = null;
        if (iv && iv.externalObject) {
            ret = iv.externalObject;
        }
        else {
            if (iv) {
                let e = IgrDropdownItem._createFromInternal(iv);
                e._implementation = iv;
                iv.externalObject = e;
                ret = e;
            }
        }
        return ret;
    }
    disconnectedCallback() {
        this.i.af();
    }
    /**
     * Clears the current selection of the dropdown.
    
    */
    clearSelection() {
        this.i.ac();
    }
    get opening() {
        return this._opening;
    }
    set opening(ev) {
        if (this._opening_wrapped !== null) {
            this.i.opening = delegateRemove(this.i.opening, this._opening_wrapped);
            this._opening_wrapped = null;
            this._opening = null;
        }
        this._opening = ev;
        this._opening_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpening) {
                this.beforeOpening(this, outerArgs);
            }
            if (this._opening) {
                this._opening(this, outerArgs);
            }
        };
        this.i.opening = delegateCombine(this.i.opening, this._opening_wrapped);
        if (this.i.openingChanged) {
            this.i.openingChanged();
        }
        ;
    }
    get opened() {
        return this._opened;
    }
    set opened(ev) {
        if (this._opened_wrapped !== null) {
            this.i.opened = delegateRemove(this.i.opened, this._opened_wrapped);
            this._opened_wrapped = null;
            this._opened = null;
        }
        this._opened = ev;
        this._opened_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpened) {
                this.beforeOpened(this, outerArgs);
            }
            if (this._opened) {
                this._opened(this, outerArgs);
            }
        };
        this.i.opened = delegateCombine(this.i.opened, this._opened_wrapped);
        if (this.i.openedChanged) {
            this.i.openedChanged();
        }
        ;
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrDropdownItemComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDropdownModule {
    static register() {
        IgrBaseComboBoxLikeModule.register();
        IgrDropdownItemModule.register();
        IgrDropdownHeaderModule.register();
        IgrDropdownGroupModule.register();
        TypeRegistrar.registerCons('IgrDropdownItemComponentEventArgs', IgrDropdownItemComponentEventArgs);
        TypeRegistrar.registerCons('IgrDropdown', IgrDropdown);
        TypeRegistrar.registerCons('IgrDropdown', IgrDropdown);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DockManagerPaneType = /*@__PURE__*/ (function (DockManagerPaneType) {
    DockManagerPaneType[DockManagerPaneType["SplitPane"] = 0] = "SplitPane";
    DockManagerPaneType[DockManagerPaneType["ContentPane"] = 1] = "ContentPane";
    DockManagerPaneType[DockManagerPaneType["TabGroupPane"] = 2] = "TabGroupPane";
    DockManagerPaneType[DockManagerPaneType["DocumentHost"] = 3] = "DocumentHost";
    return DockManagerPaneType;
})({});
/**
 * @hidden
 */
let DockManagerPaneType_$type = /*@__PURE__*/ markEnum('DockManagerPaneType', 'SplitPane,0|ContentPane,1|TabGroupPane,2|DocumentHost,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var SplitPaneOrientation = /*@__PURE__*/ (function (SplitPaneOrientation) {
    SplitPaneOrientation[SplitPaneOrientation["Horizontal"] = 0] = "Horizontal";
    SplitPaneOrientation[SplitPaneOrientation["Vertical"] = 1] = "Vertical";
    return SplitPaneOrientation;
})({});
/**
 * @hidden
 */
let SplitPaneOrientation_$type = /*@__PURE__*/ markEnum('SplitPaneOrientation', 'Horizontal:horizontal,0|Vertical:vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var UnpinnedLocation = /*@__PURE__*/ (function (UnpinnedLocation) {
    UnpinnedLocation[UnpinnedLocation["Top"] = 0] = "Top";
    UnpinnedLocation[UnpinnedLocation["Bottom"] = 1] = "Bottom";
    UnpinnedLocation[UnpinnedLocation["Left"] = 2] = "Left";
    UnpinnedLocation[UnpinnedLocation["Right"] = 3] = "Right";
    return UnpinnedLocation;
})({});
/**
 * @hidden
 */
let UnpinnedLocation_$type = /*@__PURE__*/ markEnum('UnpinnedLocation', 'Top:top,0|Bottom:bottom,1|Left:left,2|Right:right,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DockManagerPoint = /*@__PURE__*/ (() => {
    class DockManagerPoint extends Base {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.e = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.a.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.b.n("x");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("x", value_);
        }
        get d() {
            let ret_ = this.b.n("y");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("y", value_);
        }
    }
    DockManagerPoint.$t = /*@__PURE__*/ markType(DockManagerPoint, 'DockManagerPoint');
    return DockManagerPoint;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DockManagerPane = /*@__PURE__*/ (() => {
    class DockManagerPane extends Base {
        constructor() {
            super(...arguments);
            this.___mustPassByValue = true;
        }
        get d() {
            let ret_ = this.b().n("name");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b().w("name", value_);
        }
        static createFromNative(native_) {
            if (native_ == null) {
                return null;
            }
            let a = (native_.type);
            if (a == null || a == undefined) {
                return null;
            }
            switch (a.toLowerCase()) {
                case "splitpane":
                    {
                        let b = new SplitPane();
                        b.setNativeElement(native_);
                        return b;
                    }
                case "contentpane":
                    {
                        let c = new ContentPane();
                        c.setNativeElement(native_);
                        return c;
                    }
                case "tabgrouppane":
                    {
                        let d = new TabGroupPane();
                        d.setNativeElement(native_);
                        return d;
                    }
                case "documenthost":
                    {
                        let e = new DocumentHost();
                        e.setNativeElement(native_);
                        return e;
                    }
            }
            return null;
        }
    }
    DockManagerPane.$t = /*@__PURE__*/ markType(DockManagerPane, 'DockManagerPane');
    return DockManagerPane;
})();
/**
 * @hidden
 */
let DocumentHost = /*@__PURE__*/ (() => {
    class DocumentHost extends DockManagerPane {
        constructor() {
            super(...arguments);
            this.g = new WCNativeHelper();
            this.j = null;
        }
        get h() {
            return this.g;
        }
        get nativeElement() {
            return this.j;
        }
        set nativeElement(a) {
            this.j = a;
            this.g.o = this.j;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get l() {
            let ret_ = this.h.n("id");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.h.w("id", value_);
        }
        get e() {
            let ret_ = this.h.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DockManagerPaneType_$type, EnumUtil.getEnumValue(DockManagerPaneType_$type, this.h.f(DockManagerPaneType_$type, ret_)));
            return EnumUtil.getEnumValue(DockManagerPaneType_$type, ret_);
        }
        set e(a) {
            let value_ = enumGetBox(DockManagerPaneType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.h.w("type", value_);
        }
        get f() {
            let ret_ = this.h.m("rootPane", (a) => new SplitPane());
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.h.w("rootPane", value_);
        }
        get i() {
            let ret_ = this.h.n("size");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.h.w("size", value_);
        }
        b() {
            return this.h;
        }
    }
    DocumentHost.$t = /*@__PURE__*/ markType(DocumentHost, 'DocumentHost', DockManagerPane.$);
    return DocumentHost;
})();
/**
 * @hidden
 */
let TabGroupPane = /*@__PURE__*/ (() => {
    class TabGroupPane extends DockManagerPane {
        constructor() {
            super(...arguments);
            this.g = new WCNativeHelper();
            this.m = null;
        }
        get h() {
            return this.g;
        }
        get nativeElement() {
            return this.m;
        }
        set nativeElement(a) {
            this.m = a;
            this.g.o = this.m;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get o() {
            let ret_ = this.h.n("id");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.h.w("id", value_);
        }
        get f() {
            let ret_ = this.h.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DockManagerPaneType_$type, EnumUtil.getEnumValue(DockManagerPaneType_$type, this.h.f(DockManagerPaneType_$type, ret_)));
            return EnumUtil.getEnumValue(DockManagerPaneType_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(DockManagerPaneType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.h.w("type", value_);
        }
        get e() {
            let ret_ = this.h.k("panes", (a) => new ContentPaneCollection(), (a) => new ContentPane());
            return ret_;
        }
        get l() {
            let ret_ = this.h.n("size");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.h.w("size", value_);
        }
        get k() {
            let ret_ = this.h.n("selectedIndex");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.h.w("selectedIndex", value_);
        }
        get i() {
            let ret_ = this.h.n("allowEmpty");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.h.w("allowEmpty", value_);
        }
        get j() {
            let ret_ = this.h.n("isMaximized");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.h.w("isMaximized", value_);
        }
        b() {
            return this.h;
        }
    }
    TabGroupPane.$t = /*@__PURE__*/ markType(TabGroupPane, 'TabGroupPane', DockManagerPane.$);
    return TabGroupPane;
})();
/**
 * @hidden
 */
let ContentPane = /*@__PURE__*/ (() => {
    class ContentPane extends DockManagerPane {
        constructor() {
            super(...arguments);
            this.g = new WCNativeHelper();
            this.v = null;
        }
        b() {
            return this.h;
        }
        get h() {
            return this.g;
        }
        get nativeElement() {
            return this.v;
        }
        set nativeElement(a) {
            this.v = a;
            this.g.o = this.v;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get ab() {
            let ret_ = this.h.n("id");
            return ret_;
        }
        set ab(a) {
            let value_ = a;
            this.h.w("id", value_);
        }
        get e() {
            let ret_ = this.h.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DockManagerPaneType_$type, EnumUtil.getEnumValue(DockManagerPaneType_$type, this.h.f(DockManagerPaneType_$type, ret_)));
            return EnumUtil.getEnumValue(DockManagerPaneType_$type, ret_);
        }
        set e(a) {
            let value_ = enumGetBox(DockManagerPaneType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.h.w("type", value_);
        }
        get x() {
            let ret_ = this.h.n("contentId");
            return ret_;
        }
        set x(a) {
            let value_ = a;
            this.h.w("contentId", value_);
        }
        get z() {
            let ret_ = this.h.n("header");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.h.w("header", value_);
        }
        get aa() {
            let ret_ = this.h.n("headerId");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.h.w("headerId", value_);
        }
        get ac() {
            let ret_ = this.h.n("tabHeaderId");
            return ret_;
        }
        set ac(a) {
            let value_ = a;
            this.h.w("tabHeaderId", value_);
        }
        get ad() {
            let ret_ = this.h.n("unpinnedHeaderId");
            return ret_;
        }
        set ad(a) {
            let value_ = a;
            this.h.w("unpinnedHeaderId", value_);
        }
        get y() {
            let ret_ = this.h.n("floatingHeaderId");
            return ret_;
        }
        set y(a) {
            let value_ = a;
            this.h.w("floatingHeaderId", value_);
        }
        get t() {
            let ret_ = this.h.n("size");
            return ret_;
        }
        set t(a) {
            let value_ = a;
            this.h.w("size", value_);
        }
        get j() {
            let ret_ = this.h.n("allowClose");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.h.w("allowClose", value_);
        }
        get m() {
            let ret_ = this.h.n("allowMaximize");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.h.w("allowMaximize", value_);
        }
        get n() {
            let ret_ = this.h.n("allowPinning");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.h.w("allowPinning", value_);
        }
        get k() {
            let ret_ = this.h.n("allowDocking");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.h.w("allowDocking", value_);
        }
        get i() {
            let ret_ = this.h.n("acceptsInnerDock");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.h.w("acceptsInnerDock", value_);
        }
        get l() {
            let ret_ = this.h.n("allowFloating");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.h.w("allowFloating", value_);
        }
        get u() {
            let ret_ = this.h.n("unpinnedSize");
            return ret_;
        }
        set u(a) {
            let value_ = a;
            this.h.w("unpinnedSize", value_);
        }
        get s() {
            let ret_ = this.h.n("isPinned");
            return ret_;
        }
        set s(a) {
            let value_ = a;
            this.h.w("isPinned", value_);
        }
        get r() {
            let ret_ = this.h.n("isMaximized");
            return ret_;
        }
        set r(a) {
            let value_ = a;
            this.h.w("isMaximized", value_);
        }
        get f() {
            let ret_ = this.h.n("unpinnedLocation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(UnpinnedLocation_$type, EnumUtil.getEnumValue(UnpinnedLocation_$type, this.h.f(UnpinnedLocation_$type, ret_)));
            return EnumUtil.getEnumValue(UnpinnedLocation_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(UnpinnedLocation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.h.w("unpinnedLocation", value_);
        }
        get q() {
            let ret_ = this.h.n("hidden");
            return ret_;
        }
        set q(a) {
            let value_ = a;
            this.h.w("hidden", value_);
        }
        get o() {
            let ret_ = this.h.n("disabled");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.h.w("disabled", value_);
        }
        get p() {
            let ret_ = this.h.n("documentOnly");
            return ret_;
        }
        set p(a) {
            let value_ = a;
            this.h.w("documentOnly", value_);
        }
    }
    ContentPane.$t = /*@__PURE__*/ markType(ContentPane, 'ContentPane', DockManagerPane.$);
    return ContentPane;
})();
/**
 * @hidden
 */
let ContentPaneCollection = /*@__PURE__*/ (() => {
    class ContentPaneCollection extends ObservableCollection$1 {
        constructor() {
            super(ContentPane.$, 0);
        }
    }
    ContentPaneCollection.$t = /*@__PURE__*/ markType(ContentPaneCollection, 'ContentPaneCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(ContentPane.$));
    return ContentPaneCollection;
})();
/**
 * @hidden
 */
let SplitPane = /*@__PURE__*/ (() => {
    class SplitPane extends DockManagerPane {
        constructor() {
            super(...arguments);
            this.i = new WCNativeHelper();
            this.q = null;
        }
        b() {
            return this.j;
        }
        get j() {
            return this.i;
        }
        get nativeElement() {
            return this.q;
        }
        set nativeElement(a) {
            this.q = a;
            this.i.o = this.q;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get s() {
            let ret_ = this.j.n("id");
            return ret_;
        }
        set s(a) {
            let value_ = a;
            this.j.w("id", value_);
        }
        get f() {
            let ret_ = this.j.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DockManagerPaneType_$type, EnumUtil.getEnumValue(DockManagerPaneType_$type, this.j.f(DockManagerPaneType_$type, ret_)));
            return EnumUtil.getEnumValue(DockManagerPaneType_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(DockManagerPaneType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("type", value_);
        }
        get h() {
            let ret_ = this.j.n("orientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(SplitPaneOrientation_$type, EnumUtil.getEnumValue(SplitPaneOrientation_$type, this.j.f(SplitPaneOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(SplitPaneOrientation_$type, ret_);
        }
        set h(a) {
            let value_ = enumGetBox(SplitPaneOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("orientation", value_);
        }
        get e() {
            let ret_ = this.j.k("panes", (a) => new DockManagerPaneCollection(), (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        get p() {
            let ret_ = this.j.n("size");
            return ret_;
        }
        set p(a) {
            let value_ = a;
            this.j.w("size", value_);
        }
        get g() {
            let ret_ = this.j.m("floatingLocation", (a) => new DockManagerPoint());
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.j.w("floatingLocation", value_);
        }
        get o() {
            let ret_ = this.j.n("floatingWidth");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.j.w("floatingWidth", value_);
        }
        get n() {
            let ret_ = this.j.n("floatingHeight");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.j.w("floatingHeight", value_);
        }
        get l() {
            let ret_ = this.j.n("floatingResizable");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.j.w("floatingResizable", value_);
        }
        get k() {
            let ret_ = this.j.n("allowEmpty");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.j.w("allowEmpty", value_);
        }
        get m() {
            let ret_ = this.j.n("isMaximized");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.j.w("isMaximized", value_);
        }
    }
    SplitPane.$t = /*@__PURE__*/ markType(SplitPane, 'SplitPane', DockManagerPane.$);
    return SplitPane;
})();
/**
 * @hidden
 */
let DockManagerPaneCollection = /*@__PURE__*/ (() => {
    class DockManagerPaneCollection extends ObservableCollection$1 {
        constructor() {
            super(DockManagerPane.$, 0);
        }
    }
    DockManagerPaneCollection.$t = /*@__PURE__*/ markType(DockManagerPaneCollection, 'DockManagerPaneCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(DockManagerPane.$));
    return DockManagerPaneCollection;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgrDockManagerPane extends Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    get name() {
        return this.i.d;
    }
    set name(v) {
        this.i.d = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DockManagerPane");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
}

class IgrDockManagerPaneCollection extends IgCollection {
    constructor(list) {
        super();
        if (!IgrDockManagerPane.$type) {
            IgrDockManagerPane.$type = markType(IgrDockManagerPane, "IgrDockManagerPane");
        }
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        if (!IgrDockManagerPane.$type) {
            IgrDockManagerPane.$type = markType(IgrDockManagerPane, "IgrDockManagerPane");
        }
        let coll = new SyncableObservableCollection$2(IgrDockManagerPane.$type, DockManagerPane.$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext._implementation;
        };
        coll.createFrom = (int) => {
            let ext = int.externalObject;
            if (!ext) {
                ext = IgrDockManagerPane._createFromInternal(int);
                if (ext) {
                    if (!int.$type && ext._implementation.setNativeElement) {
                        ext._implementation.setNativeElement(int);
                    }
                    else {
                        ext._implementation = int;
                    }
                }
            }
            return ext;
        };
        return coll;
    }
}

class IgrDockManagerPoint {
    createImplementation() {
        return new DockManagerPoint();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get x() {
        return this.i.c;
    }
    set x(v) {
        this.i.c = +v;
    }
    get y() {
        return this.i.d;
    }
    set y(v) {
        this.i.d = +v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgrSplitPane extends IgrDockManagerPane {
    createImplementation() {
        return new SplitPane();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._panes = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineCustomElements();
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The id of the pane. If not set the Dock Manager generates it automatically.
    */
    get id() {
        return this.i.s;
    }
    set id(v) {
        this.i.s = v;
    }
    /**
     * The type of the pane.
    */
    get type() {
        return this.i.f;
    }
    set type(v) {
        this.i.f = ensureEnum(DockManagerPaneType_$type, v);
    }
    /**
     * The orientation of the split pane.
    */
    get orientation() {
        return this.i.h;
    }
    set orientation(v) {
        this.i.h = ensureEnum(SplitPaneOrientation_$type, v);
    }
    /**
     * The child panes of the split pane.
    */
    get panes() {
        if (this._panes === null) {
            let coll = new IgrDockManagerPaneCollection();
            let innerColl = this.i.e;
            if (!innerColl) {
                innerColl = new DockManagerPaneCollection();
            }
            this._panes = coll._fromInner(innerColl);
        }
        return this._panes;
    }
    set panes(v) {
        if (this._panes !== null) {
            this._panes._setSyncTarget(null);
            this._panes = null;
        }
        let coll = new IgrDockManagerPaneCollection();
        this._panes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(DockManagerPane.$type);
        let innerColl = this.i.e;
        if (!innerColl) {
            innerColl = new DockManagerPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._panes._setSyncTarget(syncColl);
    }
    /**
     * The size of the pane relative to its sibling panes' sizes. Defaults to 100.
    */
    get size() {
        return this.i.p;
    }
    set size(v) {
        this.i.p = +v;
    }
    /**
     * The absolute location point of the pane. Applies only for floating panes.
    */
    get floatingLocation() {
        const r = this.i.g;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerPoint();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set floatingLocation(v) {
        v == null ? this.i.g = null : this.i.g = v.i;
    }
    /**
     * The absolute width of the pane. Applies only for floating panes. Defaults to 100.
    */
    get floatingWidth() {
        return this.i.o;
    }
    set floatingWidth(v) {
        this.i.o = +v;
    }
    /**
     * The absolute height of the pane. Applies only for floating panes. Defaults to 100.
    */
    get floatingHeight() {
        return this.i.n;
    }
    set floatingHeight(v) {
        this.i.n = +v;
    }
    /**
     * Determines whether floating pane resizing is allowed. Applies only for floating panes.
    */
    get floatingResizable() {
        return this.i.l;
    }
    set floatingResizable(v) {
        this.i.l = ensureBool(v);
    }
    /**
     * Determines whether the pane should present in the UI when empty.
    */
    get allowEmpty() {
        return this.i.k;
    }
    set allowEmpty(v) {
        this.i.k = ensureBool(v);
    }
    /**
     * Determines whether a split pane is maximized or not. Defaults to false.
     * @deprecated Use the `isMaximized` property of TabGroupPane and/or ContentPane instead.  Having isMaximized set to true on a split pane level has no real effect as split panes serve as containers only, meaning they have no actual content to be shown maximized.
    */
    get isMaximized() {
        return this.i.m;
    }
    set isMaximized(v) {
        this.i.m = ensureBool(v);
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.panes != null && this.panes.findByName && this.panes.findByName(name)) {
            return this.panes.findByName(name);
        }
        if (this.floatingLocation && this.floatingLocation.name && this.floatingLocation.name == name) {
            return this.floatingLocation;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

class IgrSplitPaneCollection extends IgCollection {
    constructor(list) {
        super();
        if (!IgrSplitPane.$type) {
            IgrSplitPane.$type = markType(IgrSplitPane, "IgrSplitPane");
        }
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        if (!IgrSplitPane.$type) {
            IgrSplitPane.$type = markType(IgrSplitPane, "IgrSplitPane");
        }
        let coll = new SyncableObservableCollection$2(IgrSplitPane.$type, SplitPane.$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext._implementation;
        };
        coll.createFrom = (int) => {
            let ext = int.externalObject;
            if (!ext) {
                ext = IgrSplitPane._createFromInternal(int);
                if (ext) {
                    if (!int.$type && ext._implementation.setNativeElement) {
                        ext._implementation.setNativeElement(int);
                    }
                    else {
                        ext._implementation = int;
                    }
                }
            }
            return ext;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SplitPaneCollection = /*@__PURE__*/ (() => {
    class SplitPaneCollection extends ObservableCollection$1 {
        constructor() {
            super(SplitPane.$, 0);
        }
    }
    SplitPaneCollection.$t = /*@__PURE__*/ markType(SplitPaneCollection, 'SplitPaneCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(SplitPane.$));
    return SplitPaneCollection;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DockManagerLayout = /*@__PURE__*/ (() => {
    class DockManagerLayout extends Base {
        constructor() {
            super(...arguments);
            this.___mustPassByValue = true;
            this.c = new WCNativeHelper();
            this.f = null;
        }
        get h() {
            let ret_ = this.d.n("name");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.d.w("name", value_);
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.c.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.d.m("rootPane", (a) => new SplitPane());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("rootPane", value_);
        }
        get b() {
            let ret_ = this.d.k("floatingPanes", (a) => new SplitPaneCollection(), (a) => new SplitPane());
            return ret_;
        }
    }
    DockManagerLayout.$t = /*@__PURE__*/ markType(DockManagerLayout, 'DockManagerLayout');
    return DockManagerLayout;
})();

/**
 * Describes a Dock Manager layout.
*/
class IgrDockManagerLayout {
    createImplementation() {
        return new DockManagerLayout();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._floatingPanes = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get name() {
        return this.i.h;
    }
    set name(v) {
        this.i.h = v;
    }
    /**
     * The root split pane of the layout.
    */
    get rootPane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrSplitPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set rootPane(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    /**
     * The floating panes of the layout.
    */
    get floatingPanes() {
        if (this._floatingPanes === null) {
            let coll = new IgrSplitPaneCollection();
            let innerColl = this.i.b;
            if (!innerColl) {
                innerColl = new SplitPaneCollection();
            }
            this._floatingPanes = coll._fromInner(innerColl);
        }
        return this._floatingPanes;
    }
    set floatingPanes(v) {
        if (this._floatingPanes !== null) {
            this._floatingPanes._setSyncTarget(null);
            this._floatingPanes = null;
        }
        let coll = new IgrSplitPaneCollection();
        this._floatingPanes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(SplitPane.$type);
        let innerColl = this.i.b;
        if (!innerColl) {
            innerColl = new SplitPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._floatingPanes._setSyncTarget(syncColl);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.rootPane && this.rootPane.name && this.rootPane.name == name) {
            return this.rootPane;
        }
        if (this.floatingPanes != null && this.floatingPanes.findByName && this.floatingPanes.findByName(name)) {
            return this.floatingPanes.findByName(name);
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDockManagerLayoutModule {
    static register() {
        TypeRegistrar.registerCons("IgrDockManagerLayout", IgrDockManagerLayout);
        TypeRegistrar.register("DockManagerLayout", DockManagerLayout.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgrContentPane extends IgrDockManagerPane {
    createImplementation() {
        return new ContentPane();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineCustomElements();
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The id of the pane. If not set the Dock Manager generates it automatically.
    */
    get id() {
        return this.i.ab;
    }
    set id(v) {
        this.i.ab = v;
    }
    /**
     * The type of the pane.
    */
    get type() {
        return this.i.e;
    }
    set type(v) {
        this.i.e = ensureEnum(DockManagerPaneType_$type, v);
    }
    /**
     * The slot attribute's value of the content element.
    */
    get contentId() {
        return this.i.x;
    }
    set contentId(v) {
        this.i.x = v;
    }
    /**
     * The text header of the content pane. Even if header slot templates are used, the text header is used for aria label.
    */
    get header() {
        return this.i.z;
    }
    set header(v) {
        this.i.z = v;
    }
    /**
     * The slot attribute's value of the content pane header element. If not set, the `header` property value is used.
    */
    get headerId() {
        return this.i.aa;
    }
    set headerId(v) {
        this.i.aa = v;
    }
    /**
     * The slot attribute's value of the tab header element. If not set, the `header` property value is used.
    */
    get tabHeaderId() {
        return this.i.ac;
    }
    set tabHeaderId(v) {
        this.i.ac = v;
    }
    /**
     * The slot attribute's value of the unpinned header element. If not set, the `header` property value is used.
    */
    get unpinnedHeaderId() {
        return this.i.ad;
    }
    set unpinnedHeaderId(v) {
        this.i.ad = v;
    }
    /**
     * The slot attribute's value of the floating header element. If not set, the `headerId` property value is used.
    */
    get floatingHeaderId() {
        return this.i.y;
    }
    set floatingHeaderId(v) {
        this.i.y = v;
    }
    /**
     * The size of the pane relative to its sibling panes' sizes. Defaults to 100.
    */
    get size() {
        return this.i.t;
    }
    set size(v) {
        this.i.t = +v;
    }
    /**
     * Determines whether the end user is allowed to close the pane. Defaults to true.
    */
    get allowClose() {
        return this.i.j;
    }
    set allowClose(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * Determines whether the end user is allowed to maximize the pane.
    */
    get allowMaximize() {
        return this.i.m;
    }
    set allowMaximize(v) {
        this.i.m = ensureBool(v);
    }
    /**
     * Determines whether the end user is allowed to pin/unpin the pane. Defaults to true.
    */
    get allowPinning() {
        return this.i.n;
    }
    set allowPinning(v) {
        this.i.n = ensureBool(v);
    }
    /**
     * Determines whether the end user is allowed to dock the pane. Defaults to true.
    */
    get allowDocking() {
        return this.i.k;
    }
    set allowDocking(v) {
        this.i.k = ensureBool(v);
    }
    /**
     * Determines whether the end user can inner dock another pane in this one. Defaults to true.
    */
    get acceptsInnerDock() {
        return this.i.i;
    }
    set acceptsInnerDock(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * Determines whether the end user is allowed to make the pane floating. Defaults to true.
    */
    get allowFloating() {
        return this.i.l;
    }
    set allowFloating(v) {
        this.i.l = ensureBool(v);
    }
    /**
     * The absolute size of the pane in an unpinned state. Defaults to 200.
    */
    get unpinnedSize() {
        return this.i.u;
    }
    set unpinnedSize(v) {
        this.i.u = +v;
    }
    /**
     * Determines whether a content pane is pinned or not. Defaults to true.
    */
    get isPinned() {
        return this.i.s;
    }
    set isPinned(v) {
        this.i.s = ensureBool(v);
    }
    /**
     * Determines whether a content pane is maximized or not. Defaults to false.
    */
    get isMaximized() {
        return this.i.r;
    }
    set isMaximized(v) {
        this.i.r = ensureBool(v);
    }
    /**
     * The desired unpinned location of the content pane.
     * If not set the Dock Manager automatically calculates it based on the location of the pane relatively to the document host.
     * If more than one document host is presented, the closest one in the pane hierarchy will be used for the calculation.
     * If there is no document host, the default location is left.
    */
    get unpinnedLocation() {
        return this.i.f;
    }
    set unpinnedLocation(v) {
        this.i.f = ensureEnum(UnpinnedLocation_$type, v);
    }
    /**
     * Determines whether a pane is hidden in the UI. Defaults to false.
    */
    get hidden() {
        return this.i.q;
    }
    set hidden(v) {
        this.i.q = ensureBool(v);
    }
    /**
     * Determines whether a pane is disabled. Defaults to false.
    */
    get disabled() {
        return this.i.o;
    }
    set disabled(v) {
        this.i.o = ensureBool(v);
    }
    /**
     * Marks that a content pane can be docked only inside a document host.
    */
    get documentOnly() {
        return this.i.p;
    }
    set documentOnly(v) {
        this.i.p = ensureBool(v);
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrContentPaneModule {
    static register() {
        TypeRegistrar.registerCons("IgrContentPane", IgrContentPane);
        TypeRegistrar.register("ContentPane", ContentPane.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSplitPaneModule {
    static register() {
        TypeRegistrar.registerCons("IgrSplitPane", IgrSplitPane);
        TypeRegistrar.register("SplitPane", SplitPane.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgrDocumentHost extends IgrDockManagerPane {
    createImplementation() {
        return new DocumentHost();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineCustomElements();
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The id of the pane. If not set the Dock Manager generates it automatically.
    */
    get id() {
        return this.i.l;
    }
    set id(v) {
        this.i.l = v;
    }
    /**
     * The type of the pane.
    */
    get type() {
        return this.i.e;
    }
    set type(v) {
        this.i.e = ensureEnum(DockManagerPaneType_$type, v);
    }
    /**
     * The root split pane of the document host.
    */
    get rootPane() {
        const r = this.i.f;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrSplitPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set rootPane(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.f = null : this.i.f = v.i;
    }
    /**
     * The size of the pane relative to its sibling panes' sizes. Defaults to 100.
    */
    get size() {
        return this.i.i;
    }
    set size(v) {
        this.i.i = +v;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.rootPane && this.rootPane.name && this.rootPane.name == name) {
            return this.rootPane;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.rootPane && this.rootPane._styling) {
            this.rootPane._styling(container, component, this);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDocumentHostModule {
    static register() {
        TypeRegistrar.registerCons("IgrDocumentHost", IgrDocumentHost);
        TypeRegistrar.register("DocumentHost", DocumentHost.$type);
    }
}

class IgrContentPaneCollection extends IgCollection {
    constructor(list) {
        super();
        if (!IgrContentPane.$type) {
            IgrContentPane.$type = markType(IgrContentPane, "IgrContentPane");
        }
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        if (!IgrContentPane.$type) {
            IgrContentPane.$type = markType(IgrContentPane, "IgrContentPane");
        }
        let coll = new SyncableObservableCollection$2(IgrContentPane.$type, ContentPane.$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext._implementation;
        };
        coll.createFrom = (int) => {
            let ext = int.externalObject;
            if (!ext) {
                ext = IgrContentPane._createFromInternal(int);
                if (ext) {
                    if (!int.$type && ext._implementation.setNativeElement) {
                        ext._implementation.setNativeElement(int);
                    }
                    else {
                        ext._implementation = int;
                    }
                }
            }
            return ext;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgrTabGroupPane extends IgrDockManagerPane {
    createImplementation() {
        return new TabGroupPane();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._panes = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineCustomElements();
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The id of the pane. If not set the Dock Manager generates it automatically.
    */
    get id() {
        return this.i.o;
    }
    set id(v) {
        this.i.o = v;
    }
    /**
     * The type of the pane.
    */
    get type() {
        return this.i.f;
    }
    set type(v) {
        this.i.f = ensureEnum(DockManagerPaneType_$type, v);
    }
    /**
     * The child content panes of the tab group.
    */
    get panes() {
        if (this._panes === null) {
            let coll = new IgrContentPaneCollection();
            let innerColl = this.i.e;
            if (!innerColl) {
                innerColl = new ContentPaneCollection();
            }
            this._panes = coll._fromInner(innerColl);
        }
        return this._panes;
    }
    set panes(v) {
        if (this._panes !== null) {
            this._panes._setSyncTarget(null);
            this._panes = null;
        }
        let coll = new IgrContentPaneCollection();
        this._panes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ContentPane.$type);
        let innerColl = this.i.e;
        if (!innerColl) {
            innerColl = new ContentPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._panes._setSyncTarget(syncColl);
    }
    /**
     * The size of the pane relative to its sibling panes' sizes. Defaults to 100.
    */
    get size() {
        return this.i.l;
    }
    set size(v) {
        this.i.l = +v;
    }
    /**
     * The index of the selected tab.
    */
    get selectedIndex() {
        return this.i.k;
    }
    set selectedIndex(v) {
        this.i.k = +v;
    }
    /**
     * Determines whether the pane should present in the UI when empty.
    */
    get allowEmpty() {
        return this.i.i;
    }
    set allowEmpty(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * Determines whether a tab group is maximized or not. Defaults to false.
    */
    get isMaximized() {
        return this.i.j;
    }
    set isMaximized(v) {
        this.i.j = ensureBool(v);
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.panes != null && this.panes.findByName && this.panes.findByName(name)) {
            return this.panes.findByName(name);
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTabGroupPaneModule {
    static register() {
        TypeRegistrar.registerCons("IgrTabGroupPane", IgrTabGroupPane);
        TypeRegistrar.register("TabGroupPane", TabGroupPane.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DragService = /*@__PURE__*/ (() => {
    class DragService extends Base {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    DragService.$t = /*@__PURE__*/ markType(DragService, 'DragService');
    return DragService;
})();

class IgrDragService {
    createImplementation() {
        return new DragService();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TabHeaderElement = /*@__PURE__*/ (() => {
    class TabHeaderElement extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.d = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.b.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.m("dragService", (a) => new DragService());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.c.w("dragService", value_);
        }
    }
    TabHeaderElement.$t = /*@__PURE__*/ markType(TabHeaderElement, 'TabHeaderElement', BaseElement.$);
    return TabHeaderElement;
})();

/**
 * Describes a tab header element.
*/
class IgrTabHeaderElement {
    createImplementation() {
        return new TabHeaderElement();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets/sets the drag service.
    */
    get dragService() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDragService();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set dragService(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.dragService && this.dragService.name && this.dragService.name == name) {
            return this.dragService;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTabHeaderElementModule {
    static register() {
        TypeRegistrar.registerCons("IgrTabHeaderElement", IgrTabHeaderElement);
        TypeRegistrar.register("TabHeaderElement", TabHeaderElement.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DockManagerShowHeaderIconOnHover = /*@__PURE__*/ (function (DockManagerShowHeaderIconOnHover) {
    DockManagerShowHeaderIconOnHover[DockManagerShowHeaderIconOnHover["CloseOnly"] = 0] = "CloseOnly";
    DockManagerShowHeaderIconOnHover[DockManagerShowHeaderIconOnHover["MoreOptionsOnly"] = 1] = "MoreOptionsOnly";
    DockManagerShowHeaderIconOnHover[DockManagerShowHeaderIconOnHover["All"] = 2] = "All";
    return DockManagerShowHeaderIconOnHover;
})({});
/**
 * @hidden
 */
let DockManagerShowHeaderIconOnHover_$type = /*@__PURE__*/ markEnum('DockManagerShowHeaderIconOnHover', 'CloseOnly,0|MoreOptionsOnly,1|All,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DockManagerResourceStrings = /*@__PURE__*/ (() => {
    class DockManagerResourceStrings extends Base {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get e() {
            let ret_ = this.b.n("close");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.b.w("close", value_);
        }
        get l() {
            let ret_ = this.b.n("pin");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.b.w("pin", value_);
        }
        get m() {
            let ret_ = this.b.n("unpin");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.b.w("unpin", value_);
        }
        get g() {
            let ret_ = this.b.n("maximize");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.b.w("maximize", value_);
        }
        get h() {
            let ret_ = this.b.n("minimize");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.b.w("minimize", value_);
        }
        get i() {
            let ret_ = this.b.n("moreOptions");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.b.w("moreOptions", value_);
        }
        get j() {
            let ret_ = this.b.n("moreTabs");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.b.w("moreTabs", value_);
        }
        get k() {
            let ret_ = this.b.n("panes");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.b.w("panes", value_);
        }
        get f() {
            let ret_ = this.b.n("documents");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.b.w("documents", value_);
        }
    }
    DockManagerResourceStrings.$t = /*@__PURE__*/ markType(DockManagerResourceStrings, 'DockManagerResourceStrings');
    return DockManagerResourceStrings;
})();

/**
 * Describes dock manager resource strings.
*/
class IgrDockManagerResourceStrings {
    createImplementation() {
        return new DockManagerResourceStrings();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get close() {
        return this.i.e;
    }
    set close(v) {
        this.i.e = v;
    }
    get pin() {
        return this.i.l;
    }
    set pin(v) {
        this.i.l = v;
    }
    get unpin() {
        return this.i.m;
    }
    set unpin(v) {
        this.i.m = v;
    }
    get maximize() {
        return this.i.g;
    }
    set maximize(v) {
        this.i.g = v;
    }
    get minimize() {
        return this.i.h;
    }
    set minimize(v) {
        this.i.h = v;
    }
    get moreOptions() {
        return this.i.i;
    }
    set moreOptions(v) {
        this.i.i = v;
    }
    get moreTabs() {
        return this.i.j;
    }
    set moreTabs(v) {
        this.i.j = v;
    }
    get panes() {
        return this.i.k;
    }
    set panes(v) {
        this.i.k = v;
    }
    get documents() {
        return this.i.f;
    }
    set documents(v) {
        this.i.f = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DockManagerShowPaneHeaders = /*@__PURE__*/ (function (DockManagerShowPaneHeaders) {
    DockManagerShowPaneHeaders[DockManagerShowPaneHeaders["OnHoverOnly"] = 0] = "OnHoverOnly";
    DockManagerShowPaneHeaders[DockManagerShowPaneHeaders["Always"] = 1] = "Always";
    return DockManagerShowPaneHeaders;
})({});
/**
 * @hidden
 */
let DockManagerShowPaneHeaders_$type = /*@__PURE__*/ markEnum('DockManagerShowPaneHeaders', 'OnHoverOnly,0|Always,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LayoutChangeEventArgs = /*@__PURE__*/ (() => {
    class LayoutChangeEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new LayoutChangeEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    LayoutChangeEventArgs.$t = /*@__PURE__*/ markType(LayoutChangeEventArgs, 'LayoutChangeEventArgs');
    return LayoutChangeEventArgs;
})();

class IgrLayoutChangeEventArgs {
    createImplementation() {
        return new LayoutChangeEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerLayout();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DockManager = /*@__PURE__*/ (() => {
    class DockManager extends BaseElement {
        constructor() {
            super(...arguments);
            this.layoutChange = null;
            this.j = new WCNativeHelper();
            this.r = null;
        }
        layoutChangeChanged() {
            if (this.layoutChange != null) {
                this.k.s("layoutChange", (a) => this.layoutChange(this, LayoutChangeEventArgs.b(this.b)), false);
            }
            else {
                this.k.v("layoutChange");
            }
        }
        get k() {
            return this.j;
        }
        get nativeElement() {
            return this.r;
        }
        set nativeElement(a) {
            this.r = a;
            this.j.o = this.r;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.k.m("layout", (a) => new DockManagerLayout());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.k.w("layout", value_);
        }
        get c() {
            let ret_ = this.k.m("draggedPane", (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.k.w("draggedPane", value_);
        }
        get e() {
            let ret_ = this.k.m("dropPosition", (a) => new DockManagerPoint());
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.k.w("dropPosition", value_);
        }
        get a() {
            let ret_ = this.k.m("activePane", (a) => new ContentPane());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.k.w("activePane", value_);
        }
        get n() {
            let ret_ = this.k.n("allowMaximize");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.k.w("allowMaximize", value_);
        }
        get o() {
            let ret_ = this.k.n("containedInBoundaries");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.k.w("containedInBoundaries", value_);
        }
        get g() {
            let ret_ = this.k.n("showHeaderIconOnHover");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DockManagerShowHeaderIconOnHover_$type, EnumUtil.getEnumValue(DockManagerShowHeaderIconOnHover_$type, this.k.f(DockManagerShowHeaderIconOnHover_$type, ret_)));
            return EnumUtil.getEnumValue(DockManagerShowHeaderIconOnHover_$type, ret_);
        }
        set g(a) {
            let value_ = enumGetBox(DockManagerShowHeaderIconOnHover_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.k.w("showHeaderIconOnHover", value_);
        }
        get d() {
            let ret_ = this.k.m("maximizedPane", (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.k.w("maximizedPane", value_);
        }
        get f() {
            let ret_ = this.k.m("resourceStrings", (a) => new DockManagerResourceStrings());
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.k.w("resourceStrings", value_);
        }
        get l() {
            let ret_ = this.k.n("allowFloatingPanesResize");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.k.w("allowFloatingPanesResize", value_);
        }
        get p() {
            let ret_ = this.k.n("disableKeyboardNavigation");
            return ret_;
        }
        set p(a) {
            let value_ = a;
            this.k.w("disableKeyboardNavigation", value_);
        }
        get m() {
            let ret_ = this.k.n("allowInnerDock");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.k.w("allowInnerDock", value_);
        }
        get h() {
            let ret_ = this.k.n("showPaneHeaders");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DockManagerShowPaneHeaders_$type, EnumUtil.getEnumValue(DockManagerShowPaneHeaders_$type, this.k.f(DockManagerShowPaneHeaders_$type, ret_)));
            return EnumUtil.getEnumValue(DockManagerShowPaneHeaders_$type, ret_);
        }
        set h(a) {
            let value_ = enumGetBox(DockManagerShowPaneHeaders_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.k.w("showPaneHeaders", value_);
        }
        get q() {
            let ret_ = this.k.n("proximityDock");
            return ret_;
        }
        set q(a) {
            let value_ = a;
            this.k.w("proximityDock", value_);
        }
        t(a) {
            this.nativeElement.focusPane(this.k.i(a));
        }
    }
    DockManager.$t = /*@__PURE__*/ markType(DockManager, 'DockManager', BaseElement.$);
    return DockManager;
})();

/**
 * Describes a Dock Manager component.
*/
class IgrDockManager extends Component {
    createImplementation() {
        return new DockManager();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._layoutChange = null;
        this._layoutChange_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineCustomElements();
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-dockmanager", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Gets/sets the layout configuration of the Dock Manager.
    */
    get layout() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerLayout();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set layout(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    /**
     * Gets/sets the currently dragged pane.
    */
    get draggedPane() {
        const r = this.i.c;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set draggedPane(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.c = null : this.i.c = v.i;
    }
    /**
     * Gets/sets the current drop position when performing custom drag/drop.
    */
    get dropPosition() {
        const r = this.i.e;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerPoint();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set dropPosition(v) {
        v == null ? this.i.e = null : this.i.e = v.i;
    }
    /**
     * Gets/sets the active pane of the Dock Manager.
    */
    get activePane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrContentPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set activePane(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    /**
     * Determines whether the end user is allowed to maximize panes. Defaults to true.
    */
    get allowMaximize() {
        return this.i.n;
    }
    set allowMaximize(v) {
        this.i.n = ensureBool(v);
    }
    /**
     * Determines whether the floating panes are kept inside the Dock Manager boundaries. Defaults to false.
    */
    get containedInBoundaries() {
        return this.i.o;
    }
    set containedInBoundaries(v) {
        this.i.o = ensureBool(v);
    }
    /**
     * Determines which tab header icons should show when hovering over the tab with the mouse. Defaults to undefined.
    */
    get showHeaderIconOnHover() {
        return this.i.g;
    }
    set showHeaderIconOnHover(v) {
        this.i.g = ensureEnum(DockManagerShowHeaderIconOnHover_$type, v);
    }
    /**
     * Gets/sets the maximized pane.
    */
    get maximizedPane() {
        const r = this.i.d;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set maximizedPane(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.d = null : this.i.d = v.i;
    }
    /**
     * Gets/sets the resource strings.
    */
    get resourceStrings() {
        const r = this.i.f;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerResourceStrings();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set resourceStrings(v) {
        v == null ? this.i.f = null : this.i.f = v.i;
    }
    /**
     * Determines whether the end user is allowed to resize floating panes. Defaults to true.
    */
    get allowFloatingPanesResize() {
        return this.i.l;
    }
    set allowFloatingPanesResize(v) {
        this.i.l = ensureBool(v);
    }
    /**
     * Disables the built-in keyboard shortcuts for pane navigation. Defaults to false.
    */
    get disableKeyboardNavigation() {
        return this.i.p;
    }
    set disableKeyboardNavigation(v) {
        this.i.p = ensureBool(v);
    }
    /**
     * Determines whether the end user is allowed to inner dock panes. Defaults to true.
    */
    get allowInnerDock() {
        return this.i.m;
    }
    set allowInnerDock(v) {
        this.i.m = ensureBool(v);
    }
    /**
     * Determines whether pane headers are only shown on hover or always visible. Defaults to 'always'.
    */
    get showPaneHeaders() {
        return this.i.h;
    }
    set showPaneHeaders(v) {
        this.i.h = ensureEnum(DockManagerShowPaneHeaders_$type, v);
    }
    /**
     * Determines whether the end user can dock the dragged pane by dragging it close to the target pane edges.
     * If enabled, docking indicators are not visible. Defaults to false.
    */
    get proximityDock() {
        return this.i.q;
    }
    set proximityDock(v) {
        this.i.q = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.layout && this.layout.name && this.layout.name == name) {
            return this.layout;
        }
        if (this.draggedPane && this.draggedPane.name && this.draggedPane.name == name) {
            return this.draggedPane;
        }
        if (this.dropPosition && this.dropPosition.name && this.dropPosition.name == name) {
            return this.dropPosition;
        }
        if (this.activePane && this.activePane.name && this.activePane.name == name) {
            return this.activePane;
        }
        if (this.maximizedPane && this.maximizedPane.name && this.maximizedPane.name == name) {
            return this.maximizedPane;
        }
        if (this.resourceStrings && this.resourceStrings.name && this.resourceStrings.name == name) {
            return this.resourceStrings;
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DockManager");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this.draggedPane && this.draggedPane._styling) {
            this.draggedPane._styling(container, component, this);
        }
        if (this.activePane && this.activePane._styling) {
            this.activePane._styling(container, component, this);
        }
        if (this.maximizedPane && this.maximizedPane._styling) {
            this.maximizedPane._styling(container, component, this);
        }
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Focuses a pane from the layout.
    
    */
    focusPane(contentId) {
        this.i.t(contentId);
    }
    get layoutChange() {
        return this._layoutChange;
    }
    set layoutChange(ev) {
        if (this._layoutChange_wrapped !== null) {
            this.i.layoutChange = delegateRemove(this.i.layoutChange, this._layoutChange_wrapped);
            this._layoutChange_wrapped = null;
            this._layoutChange = null;
        }
        this._layoutChange = ev;
        this._layoutChange_wrapped = (o, e) => {
            let outerArgs = new IgrLayoutChangeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeLayoutChange) {
                this.beforeLayoutChange(this, outerArgs);
            }
            if (this._layoutChange) {
                this._layoutChange(this, outerArgs);
            }
        };
        this.i.layoutChange = delegateCombine(this.i.layoutChange, this._layoutChange_wrapped);
        if (this.i.layoutChangeChanged) {
            this.i.layoutChangeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDockManagerModule {
    static register() {
        IgrDockManagerLayoutModule.register();
        IgrContentPaneModule.register();
        IgrSplitPaneModule.register();
        IgrDocumentHostModule.register();
        IgrTabGroupPaneModule.register();
        IgrTabHeaderElementModule.register();
        TypeRegistrar.registerCons('IgrDockManager', IgrDockManager);
        TypeRegistrar.registerCons('IgrDockManager', IgrDockManager);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ExpansionPanelIndicatorPosition = /*@__PURE__*/ (function (ExpansionPanelIndicatorPosition) {
    ExpansionPanelIndicatorPosition[ExpansionPanelIndicatorPosition["None"] = 0] = "None";
    ExpansionPanelIndicatorPosition[ExpansionPanelIndicatorPosition["Start"] = 1] = "Start";
    ExpansionPanelIndicatorPosition[ExpansionPanelIndicatorPosition["End"] = 2] = "End";
    return ExpansionPanelIndicatorPosition;
})({});
/**
 * @hidden
 */
let ExpansionPanelIndicatorPosition_$type = /*@__PURE__*/ markEnum('ExpansionPanelIndicatorPosition', 'None,0|Start,1|End,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ExpansionPanel = /*@__PURE__*/ (() => {
    class ExpansionPanel extends BaseElement {
        constructor() {
            super(...arguments);
            this.f = new WCNativeHelper();
            this.m = null;
            this.opening = null;
            this.opened = null;
            this.closing = null;
            this.closed = null;
        }
        get g() {
            return this.f;
        }
        get nativeElement() {
            return this.m;
        }
        set nativeElement(a) {
            this.m = a;
            this.f.o = this.m;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get j() {
            let ret_ = this.g.n("open");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.g.w("open", value_);
        }
        get h() {
            let ret_ = this.g.n("disabled");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.g.w("disabled", value_);
        }
        get e() {
            let ret_ = this.g.n("indicatorPosition");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ExpansionPanelIndicatorPosition_$type, EnumUtil.getEnumValue(ExpansionPanelIndicatorPosition_$type, this.g.f(ExpansionPanelIndicatorPosition_$type, ret_)));
            return EnumUtil.getEnumValue(ExpansionPanelIndicatorPosition_$type, ret_);
        }
        set e(a) {
            let value_ = enumGetBox(ExpansionPanelIndicatorPosition_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.g.w("indicatorPosition", value_);
        }
        openingChanged() {
            if (this.opening != null) {
                this.g.s("opening", (a) => this.opening(this, ExpansionPanelComponentEventArgs.b(a)));
            }
            else {
                this.g.v("opening");
            }
        }
        openedChanged() {
            if (this.opened != null) {
                this.g.s("opened", (a) => this.opened(this, ExpansionPanelComponentEventArgs.b(a)));
            }
            else {
                this.g.v("opened");
            }
        }
        closingChanged() {
            if (this.closing != null) {
                this.g.s("closing", (a) => this.closing(this, ExpansionPanelComponentEventArgs.b(a)));
            }
            else {
                this.g.v("closing");
            }
        }
        closedChanged() {
            if (this.closed != null) {
                this.g.s("closed", (a) => this.closed(this, ExpansionPanelComponentEventArgs.b(a)));
            }
            else {
                this.g.v("closed");
            }
        }
        q() {
            this.nativeElement.connectedCallback();
        }
        l() {
            return (this.nativeElement.toggle());
        }
        i() {
            return (this.nativeElement.hide());
        }
        k() {
            return (this.nativeElement.show());
        }
    }
    ExpansionPanel.$t = /*@__PURE__*/ markType(ExpansionPanel, 'ExpansionPanel', BaseElement.$);
    return ExpansionPanel;
})();
/**
 * @hidden
 */
let ExpansionPanelComponentEventArgs = /*@__PURE__*/ (() => {
    class ExpansionPanelComponentEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new ExpansionPanelComponentEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    ExpansionPanelComponentEventArgs.$t = /*@__PURE__*/ markType(ExpansionPanelComponentEventArgs, 'ExpansionPanelComponentEventArgs');
    return ExpansionPanelComponentEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * The Expansion Panel Component provides a way to display information in a toggleable way -
 * compact summary view containing title and description and expanded detail view containing
 * additional content to the summary header.
*/
class IgrExpansionPanel extends Component {
    createImplementation() {
        return new ExpansionPanel();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._opening = null;
        this._opening_wrapped = null;
        this._opened = null;
        this._opened_wrapped = null;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcExpansionPanelComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-expansion-panel", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Indicates whether the contents of the control should be visible.
    */
    get open() {
        return this.i.j;
    }
    set open(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * Get/Set whether the expansion panel is disabled. Disabled panels are ignored for user interactions.
    */
    get disabled() {
        return this.i.h;
    }
    set disabled(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * The indicator position of the expansion panel.
    */
    get indicatorPosition() {
        return this.i.e;
    }
    set indicatorPosition(v) {
        this.i.e = ensureEnum(ExpansionPanelIndicatorPosition_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("ExpansionPanel");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.q();
    }
    /**
     * Toggles the panel open/close state.
    
    */
    toggle() {
        let iv = this.i.l();
        return (iv);
    }
    /**
     * Hides the panel content.
    
    */
    hide() {
        let iv = this.i.i();
        return (iv);
    }
    /**
     * Shows the panel content.
    
    */
    show() {
        let iv = this.i.k();
        return (iv);
    }
    get opening() {
        return this._opening;
    }
    set opening(ev) {
        if (this._opening_wrapped !== null) {
            this.i.opening = delegateRemove(this.i.opening, this._opening_wrapped);
            this._opening_wrapped = null;
            this._opening = null;
        }
        this._opening = ev;
        this._opening_wrapped = (o, e) => {
            let outerArgs = new IgrExpansionPanelComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpening) {
                this.beforeOpening(this, outerArgs);
            }
            if (this._opening) {
                this._opening(this, outerArgs);
            }
        };
        this.i.opening = delegateCombine(this.i.opening, this._opening_wrapped);
        if (this.i.openingChanged) {
            this.i.openingChanged();
        }
        ;
    }
    get opened() {
        return this._opened;
    }
    set opened(ev) {
        if (this._opened_wrapped !== null) {
            this.i.opened = delegateRemove(this.i.opened, this._opened_wrapped);
            this._opened_wrapped = null;
            this._opened = null;
        }
        this._opened = ev;
        this._opened_wrapped = (o, e) => {
            let outerArgs = new IgrExpansionPanelComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpened) {
                this.beforeOpened(this, outerArgs);
            }
            if (this._opened) {
                this._opened(this, outerArgs);
            }
        };
        this.i.opened = delegateCombine(this.i.opened, this._opened_wrapped);
        if (this.i.openedChanged) {
            this.i.openedChanged();
        }
        ;
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrExpansionPanelComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrExpansionPanelComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgrExpansionPanelComponentEventArgs {
    createImplementation() {
        return new ExpansionPanelComponentEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrExpansionPanel({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrExpansionPanelModule {
    static register() {
        TypeRegistrar.registerCons('IgrExpansionPanelComponentEventArgs', IgrExpansionPanelComponentEventArgs);
        TypeRegistrar.registerCons('IgrExpansionPanel', IgrExpansionPanel);
        TypeRegistrar.registerCons('IgrExpansionPanel', IgrExpansionPanel);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var MaskInputValueMode = /*@__PURE__*/ (function (MaskInputValueMode) {
    MaskInputValueMode[MaskInputValueMode["Raw"] = 0] = "Raw";
    MaskInputValueMode[MaskInputValueMode["WithFormatting"] = 1] = "WithFormatting";
    return MaskInputValueMode;
})({});
/**
 * @hidden
 */
let MaskInputValueMode_$type = /*@__PURE__*/ markEnum('MaskInputValueMode', 'Raw,0|WithFormatting,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let MaskInput = /*@__PURE__*/ (() => {
    class MaskInput extends MaskInputBase {
        constructor() {
            super(...arguments);
            this.change = null;
        }
        get ae() {
            let ret_ = this.e.n("valueMode");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(MaskInputValueMode_$type, EnumUtil.getEnumValue(MaskInputValueMode_$type, this.e.f(MaskInputValueMode_$type, ret_)));
            return EnumUtil.getEnumValue(MaskInputValueMode_$type, ret_);
        }
        set ae(a) {
            let value_ = enumGetBox(MaskInputValueMode_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("valueMode", value_);
        }
        get ag() {
            let ret_ = this.e.n("value");
            return ret_;
        }
        set ag(a) {
            let value_ = a;
            this.e.w("value", value_);
        }
        get af() {
            let ret_ = this.e.n("mask");
            return ret_;
        }
        set af(a) {
            let value_ = a;
            this.e.w("mask", value_);
        }
        ai() {
            this.nativeElement.connectedCallback();
        }
        changeChanged() {
            if (this.change != null) {
                this.e.s("change", (a) => this.change(this, ComponentDataValueChangedEventArgs.a(a)));
            }
            else {
                this.e.v("change");
            }
        }
    }
    MaskInput.$t = /*@__PURE__*/ markType(MaskInput, 'MaskInput', MaskInputBase.$);
    return MaskInput;
})();

/**
 * A masked input is an input field where a developer can control user input and format the visible value,
 * based on configurable rules
*/
class IgrMaskInput extends IgrMaskInputBase {
    createImplementation() {
        return new MaskInput();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._change = null;
        this._change_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcMaskInputComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-mask-input", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Dictates the behavior when retrieving the value of the control:
     * - `raw` will return the clean user input.
     * - `withFormatting` will return the value with all literals and prompts.
    */
    get valueMode() {
        return this.i.ae;
    }
    set valueMode(v) {
        this.i.ae = ensureEnum(MaskInputValueMode_$type, v);
    }
    get value() {
        return this.i.ag;
    }
    set value(v) {
        this.i.ag = v;
    }
    /**
     * The mask pattern to apply on the input.
    */
    get mask() {
        return this.i.af;
    }
    set mask(v) {
        this.i.af = v;
    }
    connectedCallback() {
        this.i.ai();
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComponentDataValueChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrMaskInputModule {
    static register() {
        IgrMaskInputBaseModule.register();
        TypeRegistrar.registerCons('IgrMaskInput', IgrMaskInput);
        TypeRegistrar.registerCons('IgrMaskInput', IgrMaskInput);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeItem = /*@__PURE__*/ (() => {
    class TreeItem extends BaseElement {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.k = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.k;
        }
        set nativeElement(a) {
            this.k = a;
            this.c.o = this.k;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.m("parent", (a) => new TreeItem());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("parent", value_);
        }
        get j() {
            let ret_ = this.d.n("level");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.d.w("level", value_);
        }
        get n() {
            let ret_ = this.d.n("label");
            return ret_;
        }
        set n(a) {
            let value_ = a;
            this.d.w("label", value_);
        }
        get g() {
            let ret_ = this.d.n("expanded");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.d.w("expanded", value_);
        }
        get e() {
            let ret_ = this.d.n("active");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.d.w("active", value_);
        }
        get f() {
            let ret_ = this.d.n("disabled");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.d.w("disabled", value_);
        }
        get i() {
            let ret_ = this.d.n("selected");
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.d.w("selected", value_);
        }
        get h() {
            let ret_ = this.d.n("loading");
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.d.w("loading", value_);
        }
        get m() {
            let ret_ = this.d.n("value");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.d.w("value", value_);
        }
        get a() {
            let ret_ = this.d.m("path", (a) => new TreeItem());
            return ret_;
        }
        q() {
            this.nativeElement.connectedCallback();
        }
        r() {
            this.nativeElement.disconnectedCallback();
        }
        t() {
            this.nativeElement.expandWithEvent();
        }
        p() {
            this.nativeElement.collapseWithEvent();
        }
        v() {
            this.nativeElement.toggle();
        }
        s() {
            this.nativeElement.expand();
        }
        o() {
            this.nativeElement.collapse();
        }
    }
    TreeItem.$t = /*@__PURE__*/ markType(TreeItem, 'TreeItem', BaseElement.$);
    return TreeItem;
})();

/**
 * The tree-item component represents a child item of the tree component or another tree item.
*/
class IgrTreeItem extends Component {
    createImplementation() {
        return new TreeItem();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcTreeItemComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-tree-item", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The parent item of the current tree item (if any)
    */
    get parent() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrTreeItem({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set parent(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    /**
     * The depth of the item, relative to the root.
    */
    get level() {
        return this.i.j;
    }
    set level(v) {
        this.i.j = +v;
    }
    /**
     * The tree item label.
    */
    get label() {
        return this.i.n;
    }
    set label(v) {
        this.i.n = v;
    }
    /**
     * The tree item expansion state.
    */
    get expanded() {
        return this.i.g;
    }
    set expanded(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * Marks the item as the tree's active item.
    */
    get active() {
        return this.i.e;
    }
    set active(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * Get/Set whether the tree item is disabled. Disabled items are ignored for user interactions.
    */
    get disabled() {
        return this.i.f;
    }
    set disabled(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * The tree item selection state.
    */
    get selected() {
        return this.i.i;
    }
    set selected(v) {
        this.i.i = ensureBool(v);
    }
    /**
     * To be used for load-on-demand scenarios in order to specify whether the item is loading data.
    */
    get loading() {
        return this.i.h;
    }
    set loading(v) {
        this.i.h = ensureBool(v);
    }
    /**
     * The value entry that the tree item is visualizing. Required for searching through items.
     * @type any
    */
    get value() {
        return this.i.m;
    }
    set value(v) {
        this.i.m = v;
    }
    /**
     * The full path to the tree item, starting from the top-most ancestor.
    */
    get path() {
        if (!this.i.a) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.a.length; i++) {
            let impl = this.i.a[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrTreeItem) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrTreeItem._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.parent && this.parent.name && this.parent.name == name) {
            return this.parent;
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("TreeItem");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this.parent && this.parent._styling) {
            this.parent._styling(container, component, this);
        }
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.q();
    }
    disconnectedCallback() {
        this.i.r();
    }
    /**
     * @private
     * Expands the tree item.
    
    */
    expandWithEvent() {
        this.i.t();
    }
    /**
     * @private
     * Collapses the tree item.
    
    */
    collapseWithEvent() {
        this.i.p();
    }
    /**
     * Toggles tree item expansion state.
    
    */
    toggle() {
        this.i.v();
    }
    /**
     * Expands the tree item.
    
    */
    expand() {
        this.i.s();
    }
    /**
     * Collapses the tree item.
    
    */
    collapse() {
        this.i.o();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTreeItemModule {
    static register() {
        TypeRegistrar.registerCons('IgrTreeItem', IgrTreeItem);
        TypeRegistrar.registerCons('IgrTreeItem', IgrTreeItem);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeSelectionChangeDetail = /*@__PURE__*/ (() => {
    class TreeSelectionChangeDetail extends Base {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.d = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.b.o = this.d;
        }
        get a() {
            let ret_ = this.c.m("newSelection", (a) => new TreeItem());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.c.w("newSelection", value_);
        }
    }
    TreeSelectionChangeDetail.$t = /*@__PURE__*/ markType(TreeSelectionChangeDetail, 'TreeSelectionChangeDetail');
    return TreeSelectionChangeDetail;
})();

class IgrTreeSelectionChangeDetail {
    createImplementation() {
        return new TreeSelectionChangeDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get newSelection() {
        if (!this.i.a) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.a.length; i++) {
            let impl = this.i.a[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrTreeItem) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrTreeItem._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    set newSelection(v) {
        let arr = [];
        for (let i = 0; i < v.length; i++) {
            arr.push(v[i].i);
        }
        this.i.a = arr;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeSelectionChangeEventArgs = /*@__PURE__*/ (() => {
    class TreeSelectionChangeEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new TreeSelectionChangeEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    TreeSelectionChangeEventArgs.$t = /*@__PURE__*/ markType(TreeSelectionChangeEventArgs, 'TreeSelectionChangeEventArgs');
    return TreeSelectionChangeEventArgs;
})();

class IgrTreeSelectionChangeEventArgs {
    createImplementation() {
        return new TreeSelectionChangeEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrTreeSelectionChangeDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeItemComponentEventArgs = /*@__PURE__*/ (() => {
    class TreeItemComponentEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new TreeItemComponentEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    TreeItemComponentEventArgs.$t = /*@__PURE__*/ markType(TreeItemComponentEventArgs, 'TreeItemComponentEventArgs');
    return TreeItemComponentEventArgs;
})();

class IgrTreeItemComponentEventArgs {
    createImplementation() {
        return new TreeItemComponentEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrTreeItem({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TreeSelection = /*@__PURE__*/ (function (TreeSelection) {
    TreeSelection[TreeSelection["None"] = 0] = "None";
    TreeSelection[TreeSelection["Multiple"] = 1] = "Multiple";
    TreeSelection[TreeSelection["Cascade"] = 2] = "Cascade";
    return TreeSelection;
})({});
/**
 * @hidden
 */
let TreeSelection_$type = /*@__PURE__*/ markEnum('TreeSelection', 'None,0|Multiple,1|Cascade,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Tree = /*@__PURE__*/ (() => {
    class Tree extends BaseElement {
        constructor() {
            super(...arguments);
            this.h = new WCNativeHelper();
            this.l = null;
            this.selectionChanged = null;
            this.itemExpanding = null;
            this.itemExpanded = null;
            this.itemCollapsing = null;
            this.itemCollapsed = null;
            this.activeItem = null;
        }
        get i() {
            return this.h;
        }
        get nativeElement() {
            return this.l;
        }
        set nativeElement(a) {
            this.l = a;
            this.h.o = this.l;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get j() {
            let ret_ = this.i.n("singleBranchExpand");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.i.w("singleBranchExpand", value_);
        }
        get k() {
            let ret_ = this.i.n("toggleNodeOnClick");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.i.w("toggleNodeOnClick", value_);
        }
        get f() {
            let ret_ = this.i.n("selection");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TreeSelection_$type, EnumUtil.getEnumValue(TreeSelection_$type, this.i.f(TreeSelection_$type, ret_)));
            return EnumUtil.getEnumValue(TreeSelection_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(TreeSelection_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.i.w("selection", value_);
        }
        selectionChangedChanged() {
            if (this.selectionChanged != null) {
                this.i.s("selection", (a) => this.selectionChanged(this, TreeSelectionChangeEventArgs.b(a)));
            }
            else {
                this.i.v("selection");
            }
        }
        itemExpandingChanged() {
            if (this.itemExpanding != null) {
                this.i.s("itemExpanding", (a) => this.itemExpanding(this, TreeItemComponentEventArgs.b(a)));
            }
            else {
                this.i.v("itemExpanding");
            }
        }
        itemExpandedChanged() {
            if (this.itemExpanded != null) {
                this.i.s("itemExpanded", (a) => this.itemExpanded(this, TreeItemComponentEventArgs.b(a)));
            }
            else {
                this.i.v("itemExpanded");
            }
        }
        itemCollapsingChanged() {
            if (this.itemCollapsing != null) {
                this.i.s("itemCollapsing", (a) => this.itemCollapsing(this, TreeItemComponentEventArgs.b(a)));
            }
            else {
                this.i.v("itemCollapsing");
            }
        }
        itemCollapsedChanged() {
            if (this.itemCollapsed != null) {
                this.i.s("itemCollapsed", (a) => this.itemCollapsed(this, TreeItemComponentEventArgs.b(a)));
            }
            else {
                this.i.v("itemCollapsed");
            }
        }
        activeItemChanged() {
            if (this.activeItem != null) {
                this.i.s("activeItem", (a) => this.activeItem(this, TreeItemComponentEventArgs.b(a)));
            }
            else {
                this.i.v("activeItem");
            }
        }
        o() {
            this.nativeElement.connectedCallback();
        }
        p(a) {
            this.nativeElement.expandToItem(this.i.i(a));
        }
    }
    Tree.$t = /*@__PURE__*/ markType(Tree, 'Tree', BaseElement.$);
    return Tree;
})();

/**
 * The tree allows users to represent hierarchical data in a tree-view structure,
 * maintaining parent-child relationships, as well as to define static tree-view structure without a corresponding data model.
*/
class IgrTree extends Component {
    createImplementation() {
        return new Tree();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._selectionChanged = null;
        this._selectionChanged_wrapped = null;
        this._itemExpanding = null;
        this._itemExpanding_wrapped = null;
        this._itemExpanded = null;
        this._itemExpanded_wrapped = null;
        this._itemCollapsing = null;
        this._itemCollapsing_wrapped = null;
        this._itemCollapsed = null;
        this._itemCollapsed_wrapped = null;
        this._activeItem = null;
        this._activeItem_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcTreeComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-tree", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Whether a single or multiple of a parent's child items can be expanded.
    */
    get singleBranchExpand() {
        return this.i.j;
    }
    set singleBranchExpand(v) {
        this.i.j = ensureBool(v);
    }
    /**
     * Whether clicking over nodes will change their expanded state or not.
    */
    get toggleNodeOnClick() {
        return this.i.k;
    }
    set toggleNodeOnClick(v) {
        this.i.k = ensureBool(v);
    }
    /**
     * The selection state of the tree.
    */
    get selection() {
        return this.i.f;
    }
    set selection(v) {
        this.i.f = ensureEnum(TreeSelection_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Tree");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.o();
    }
    /**
     * @private
    
    */
    expandToItem(item) {
        this.i.p((item == null ? null : item.i));
    }
    get selectionChanged() {
        return this._selectionChanged;
    }
    set selectionChanged(ev) {
        if (this._selectionChanged_wrapped !== null) {
            this.i.selectionChanged = delegateRemove(this.i.selectionChanged, this._selectionChanged_wrapped);
            this._selectionChanged_wrapped = null;
            this._selectionChanged = null;
        }
        this._selectionChanged = ev;
        this._selectionChanged_wrapped = (o, e) => {
            let outerArgs = new IgrTreeSelectionChangeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectionChanged) {
                this.beforeSelectionChanged(this, outerArgs);
            }
            if (this._selectionChanged) {
                this._selectionChanged(this, outerArgs);
            }
        };
        this.i.selectionChanged = delegateCombine(this.i.selectionChanged, this._selectionChanged_wrapped);
        if (this.i.selectionChangedChanged) {
            this.i.selectionChangedChanged();
        }
        ;
    }
    get itemExpanding() {
        return this._itemExpanding;
    }
    set itemExpanding(ev) {
        if (this._itemExpanding_wrapped !== null) {
            this.i.itemExpanding = delegateRemove(this.i.itemExpanding, this._itemExpanding_wrapped);
            this._itemExpanding_wrapped = null;
            this._itemExpanding = null;
        }
        this._itemExpanding = ev;
        this._itemExpanding_wrapped = (o, e) => {
            let outerArgs = new IgrTreeItemComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeItemExpanding) {
                this.beforeItemExpanding(this, outerArgs);
            }
            if (this._itemExpanding) {
                this._itemExpanding(this, outerArgs);
            }
        };
        this.i.itemExpanding = delegateCombine(this.i.itemExpanding, this._itemExpanding_wrapped);
        if (this.i.itemExpandingChanged) {
            this.i.itemExpandingChanged();
        }
        ;
    }
    get itemExpanded() {
        return this._itemExpanded;
    }
    set itemExpanded(ev) {
        if (this._itemExpanded_wrapped !== null) {
            this.i.itemExpanded = delegateRemove(this.i.itemExpanded, this._itemExpanded_wrapped);
            this._itemExpanded_wrapped = null;
            this._itemExpanded = null;
        }
        this._itemExpanded = ev;
        this._itemExpanded_wrapped = (o, e) => {
            let outerArgs = new IgrTreeItemComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeItemExpanded) {
                this.beforeItemExpanded(this, outerArgs);
            }
            if (this._itemExpanded) {
                this._itemExpanded(this, outerArgs);
            }
        };
        this.i.itemExpanded = delegateCombine(this.i.itemExpanded, this._itemExpanded_wrapped);
        if (this.i.itemExpandedChanged) {
            this.i.itemExpandedChanged();
        }
        ;
    }
    get itemCollapsing() {
        return this._itemCollapsing;
    }
    set itemCollapsing(ev) {
        if (this._itemCollapsing_wrapped !== null) {
            this.i.itemCollapsing = delegateRemove(this.i.itemCollapsing, this._itemCollapsing_wrapped);
            this._itemCollapsing_wrapped = null;
            this._itemCollapsing = null;
        }
        this._itemCollapsing = ev;
        this._itemCollapsing_wrapped = (o, e) => {
            let outerArgs = new IgrTreeItemComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeItemCollapsing) {
                this.beforeItemCollapsing(this, outerArgs);
            }
            if (this._itemCollapsing) {
                this._itemCollapsing(this, outerArgs);
            }
        };
        this.i.itemCollapsing = delegateCombine(this.i.itemCollapsing, this._itemCollapsing_wrapped);
        if (this.i.itemCollapsingChanged) {
            this.i.itemCollapsingChanged();
        }
        ;
    }
    get itemCollapsed() {
        return this._itemCollapsed;
    }
    set itemCollapsed(ev) {
        if (this._itemCollapsed_wrapped !== null) {
            this.i.itemCollapsed = delegateRemove(this.i.itemCollapsed, this._itemCollapsed_wrapped);
            this._itemCollapsed_wrapped = null;
            this._itemCollapsed = null;
        }
        this._itemCollapsed = ev;
        this._itemCollapsed_wrapped = (o, e) => {
            let outerArgs = new IgrTreeItemComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeItemCollapsed) {
                this.beforeItemCollapsed(this, outerArgs);
            }
            if (this._itemCollapsed) {
                this._itemCollapsed(this, outerArgs);
            }
        };
        this.i.itemCollapsed = delegateCombine(this.i.itemCollapsed, this._itemCollapsed_wrapped);
        if (this.i.itemCollapsedChanged) {
            this.i.itemCollapsedChanged();
        }
        ;
    }
    get activeItem() {
        return this._activeItem;
    }
    set activeItem(ev) {
        if (this._activeItem_wrapped !== null) {
            this.i.activeItem = delegateRemove(this.i.activeItem, this._activeItem_wrapped);
            this._activeItem_wrapped = null;
            this._activeItem = null;
        }
        this._activeItem = ev;
        this._activeItem_wrapped = (o, e) => {
            let outerArgs = new IgrTreeItemComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeActiveItem) {
                this.beforeActiveItem(this, outerArgs);
            }
            if (this._activeItem) {
                this._activeItem(this, outerArgs);
            }
        };
        this.i.activeItem = delegateCombine(this.i.activeItem, this._activeItem_wrapped);
        if (this.i.activeItemChanged) {
            this.i.activeItemChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTreeModule {
    static register() {
        IgrTreeItemModule.register();
        TypeRegistrar.registerCons('IgrTreeSelectionChangeEventArgs', IgrTreeSelectionChangeEventArgs);
        TypeRegistrar.registerCons('IgrTreeItemComponentEventArgs', IgrTreeItemComponentEventArgs);
        TypeRegistrar.registerCons('IgrTree', IgrTree);
        TypeRegistrar.registerCons('IgrTree', IgrTree);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Tab = /*@__PURE__*/ (() => {
    class Tab extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.e = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.a.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get g() {
            let ret_ = this.b.n("panel");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.b.w("panel", value_);
        }
        get d() {
            let ret_ = this.b.n("selected");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("selected", value_);
        }
        get c() {
            let ret_ = this.b.n("disabled");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("disabled", value_);
        }
        i() {
            this.nativeElement.connectedCallback();
        }
        j(a) {
            this.nativeElement.focus(this.b.i(a));
        }
        h() {
            this.nativeElement.blur();
        }
    }
    Tab.$t = /*@__PURE__*/ markType(Tab, 'Tab', BaseElement.$);
    return Tab;
})();

/**
 * Represents the tab header.
*/
class IgrTab extends Component {
    createImplementation() {
        return new Tab();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcTabComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-tab", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The id of the tab panel which will be controlled by the tab.
    */
    get panel() {
        return this.i.g;
    }
    set panel(v) {
        this.i.g = v;
    }
    /**
     * Determines whether the tab is selected.
    */
    get selected() {
        return this.i.d;
    }
    set selected(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Determines whether the tab is disabled.
    */
    get disabled() {
        return this.i.c;
    }
    set disabled(v) {
        this.i.c = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Tab");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.i();
    }
    /**
     * Sets focus to the tab.
    
    */
    focus(options) {
        this.i.j((options == null ? null : options.i));
    }
    /**
     * Removes focus from the tab.
    
    */
    blur() {
        this.i.h();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTabModule {
    static register() {
        TypeRegistrar.registerCons('IgrTab', IgrTab);
        TypeRegistrar.registerCons('IgrTab', IgrTab);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TabPanel = /*@__PURE__*/ (() => {
    class TabPanel extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        e() {
            this.nativeElement.connectedCallback();
        }
    }
    TabPanel.$t = /*@__PURE__*/ markType(TabPanel, 'TabPanel', BaseElement.$);
    return TabPanel;
})();

/**
 * Represents the content of a tab
*/
class IgrTabPanel extends Component {
    createImplementation() {
        return new TabPanel();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcTabPanelComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-tab-panel", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("TabPanel");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.e();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTabPanelModule {
    static register() {
        TypeRegistrar.registerCons('IgrTabPanel', IgrTabPanel);
        TypeRegistrar.registerCons('IgrTabPanel', IgrTabPanel);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TabComponentEventArgs = /*@__PURE__*/ (() => {
    class TabComponentEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new TabComponentEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    TabComponentEventArgs.$t = /*@__PURE__*/ markType(TabComponentEventArgs, 'TabComponentEventArgs');
    return TabComponentEventArgs;
})();

class IgrTabComponentEventArgs {
    createImplementation() {
        return new TabComponentEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrTab({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TabsAlignment = /*@__PURE__*/ (function (TabsAlignment) {
    TabsAlignment[TabsAlignment["Start"] = 0] = "Start";
    TabsAlignment[TabsAlignment["End"] = 1] = "End";
    TabsAlignment[TabsAlignment["Center"] = 2] = "Center";
    TabsAlignment[TabsAlignment["Justify"] = 3] = "Justify";
    return TabsAlignment;
})({});
/**
 * @hidden
 */
let TabsAlignment_$type = /*@__PURE__*/ markEnum('TabsAlignment', 'Start,0|End,1|Center,2|Justify,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var TabsActivation = /*@__PURE__*/ (function (TabsActivation) {
    TabsActivation[TabsActivation["Manual"] = 0] = "Manual";
    TabsActivation[TabsActivation["Auto"] = 1] = "Auto";
    return TabsActivation;
})({});
/**
 * @hidden
 */
let TabsActivation_$type = /*@__PURE__*/ markEnum('TabsActivation', 'Manual,0|Auto,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Tabs = /*@__PURE__*/ (() => {
    class Tabs extends BaseElement {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.f = null;
            this.change = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.d.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get h() {
            let ret_ = this.e.n("selected");
            return ret_;
        }
        get c() {
            let ret_ = this.e.n("alignment");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TabsAlignment_$type, EnumUtil.getEnumValue(TabsAlignment_$type, this.e.f(TabsAlignment_$type, ret_)));
            return EnumUtil.getEnumValue(TabsAlignment_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(TabsAlignment_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("alignment", value_);
        }
        get b() {
            let ret_ = this.e.n("activation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(TabsActivation_$type, EnumUtil.getEnumValue(TabsActivation_$type, this.e.f(TabsActivation_$type, ret_)));
            return EnumUtil.getEnumValue(TabsActivation_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(TabsActivation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("activation", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.e.s("change", (a) => this.change(this, TabComponentEventArgs.b(a)));
            }
            else {
                this.e.v("change");
            }
        }
        j() {
            this.nativeElement.disconnectedCallback();
        }
        k(a) {
            this.nativeElement.select(this.e.i(a));
        }
    }
    Tabs.$t = /*@__PURE__*/ markType(Tabs, 'Tabs', BaseElement.$);
    return Tabs;
})();

/**
 * Represents tabs component
*/
class IgrTabs extends Component {
    createImplementation() {
        return new Tabs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._change = null;
        this._change_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcTabsComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-tabs", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Returns the currently selected tab.
    */
    get selected() {
        return this.i.h;
    }
    /**
     * Sets the alignment for the tab headers
    */
    get alignment() {
        return this.i.c;
    }
    set alignment(v) {
        this.i.c = ensureEnum(TabsAlignment_$type, v);
    }
    /**
     * Determines the tab activation. When set to auto,
     * the tab is instantly selected while navigating with the Left/Right Arrows, Home or End keys
     * and the corresponding panel is displayed.
     * When set to manual, the tab is only focused. The selection happens after pressing Space or Enter.
    */
    get activation() {
        return this.i.b;
    }
    set activation(v) {
        this.i.b = ensureEnum(TabsActivation_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Tabs");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    disconnectedCallback() {
        this.i.j();
    }
    /**
     * Selects the specified tab and displays the corresponding panel.
    
    */
    select(name) {
        this.i.k(name);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrTabComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTabsModule {
    static register() {
        IgrTabModule.register();
        IgrTabPanelModule.register();
        TypeRegistrar.registerCons('IgrTabComponentEventArgs', IgrTabComponentEventArgs);
        TypeRegistrar.registerCons('IgrTabs', IgrTabs);
        TypeRegistrar.registerCons('IgrTabs', IgrTabs);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Accordion = /*@__PURE__*/ (() => {
    class Accordion extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.d = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.a.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.b.n("singleExpand");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("singleExpand", value_);
        }
        f() {
            this.nativeElement.hideAll();
        }
        h() {
            this.nativeElement.showAll();
        }
    }
    Accordion.$t = /*@__PURE__*/ markType(Accordion, 'Accordion', BaseElement.$);
    return Accordion;
})();

/**
 * The Accordion is a container-based component that can house multiple expansion panels
 * and offers keyboard navigation.
*/
class IgrAccordion extends Component {
    createImplementation() {
        return new Accordion();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcAccordionComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-accordion", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Allows only one panel to be expanded at a time.
    */
    get singleExpand() {
        return this.i.c;
    }
    set singleExpand(v) {
        this.i.c = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Accordion");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    /**
     * Hides all of the child expansion panels' contents.
    
    */
    hideAll() {
        this.i.f();
    }
    /**
     * Shows all of the child expansion panels' contents.
    
    */
    showAll() {
        this.i.h();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrAccordionModule {
    static register() {
        TypeRegistrar.registerCons('IgrAccordion', IgrAccordion);
        TypeRegistrar.registerCons('IgrAccordion', IgrAccordion);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ComboChangeType = /*@__PURE__*/ (function (ComboChangeType) {
    ComboChangeType[ComboChangeType["Selection"] = 0] = "Selection";
    ComboChangeType[ComboChangeType["Deselection"] = 1] = "Deselection";
    ComboChangeType[ComboChangeType["Addition"] = 2] = "Addition";
    return ComboChangeType;
})({});
/**
 * @hidden
 */
let ComboChangeType_$type = /*@__PURE__*/ markEnum('ComboChangeType', 'Selection,0|Deselection,1|Addition,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ComboChangeEventArgsDetail = /*@__PURE__*/ (() => {
    class ComboChangeEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.f = null;
        }
        get b() {
            let ret_ = this.e.n("newValue");
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.e.w("newValue", value_);
        }
        get a() {
            let ret_ = this.e.n("items");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.e.w("items", value_);
        }
        get c() {
            let ret_ = this.e.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ComboChangeType_$type, EnumUtil.getEnumValue(ComboChangeType_$type, this.e.f(ComboChangeType_$type, ret_)));
            return EnumUtil.getEnumValue(ComboChangeType_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(ComboChangeType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("type", value_);
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.d.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    ComboChangeEventArgsDetail.$t = /*@__PURE__*/ markType(ComboChangeEventArgsDetail, 'ComboChangeEventArgsDetail');
    return ComboChangeEventArgsDetail;
})();

class IgrComboChangeEventArgsDetail {
    createImplementation() {
        return new ComboChangeEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get newValue() {
        return this.i.b;
    }
    set newValue(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.b = v;
    }
    get items() {
        return this.i.a;
    }
    set items(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.a = v;
    }
    get type() {
        return this.i.c;
    }
    set type(v) {
        this.i.c = ensureEnum(ComboChangeType_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ComboChangeEventArgs = /*@__PURE__*/ (() => {
    class ComboChangeEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new ComboChangeEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    ComboChangeEventArgs.$t = /*@__PURE__*/ markType(ComboChangeEventArgs, 'ComboChangeEventArgs');
    return ComboChangeEventArgs;
})();

class IgrComboChangeEventArgs {
    createImplementation() {
        return new ComboChangeEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrComboChangeEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var GroupingDirection = /*@__PURE__*/ (function (GroupingDirection) {
    GroupingDirection[GroupingDirection["Asc"] = 0] = "Asc";
    GroupingDirection[GroupingDirection["Desc"] = 1] = "Desc";
    GroupingDirection[GroupingDirection["None"] = 2] = "None";
    return GroupingDirection;
})({});
/**
 * @hidden
 */
let GroupingDirection_$type = /*@__PURE__*/ markEnum('GroupingDirection', 'Asc,0|Desc,1|None,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FilteringOptions = /*@__PURE__*/ (() => {
    class FilteringOptions extends Base {
    }
    FilteringOptions.$t = /*@__PURE__*/ markType(FilteringOptions, 'FilteringOptions');
    return FilteringOptions;
})();

class IgrFilteringOptions {
    createImplementation() {
        return new FilteringOptions();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Combo = /*@__PURE__*/ (() => {
    class Combo extends BaseElement {
        constructor() {
            super(...arguments);
            this.m = new WCNativeHelper();
            this.ab = null;
            this.change = null;
            this.focus = null;
            this.blur = null;
            this.opening = null;
            this.opened = null;
            this.closing = null;
            this.closed = null;
            this.ae = null;
            this.ad = null;
        }
        get n() {
            return this.m;
        }
        get nativeElement() {
            return this.ab;
        }
        set nativeElement(a) {
            this.ab = a;
            this.m.o = this.ab;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.n.n("data");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.n.w("data", value_);
        }
        get w() {
            let ret_ = this.n.n("outlined");
            return ret_;
        }
        set w(a) {
            let value_ = a;
            this.n.w("outlined", value_);
        }
        get z() {
            let ret_ = this.n.n("singleSelect");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.n.w("singleSelect", value_);
        }
        get o() {
            let ret_ = this.n.n("autofocus");
            return ret_;
        }
        set o(a) {
            let value_ = a;
            this.n.w("autofocus", value_);
        }
        get p() {
            let ret_ = this.n.n("autofocusList");
            return ret_;
        }
        set p(a) {
            let value_ = a;
            this.n.w("autofocusList", value_);
        }
        get ah() {
            let ret_ = this.n.n("label");
            return ret_;
        }
        set ah(a) {
            let value_ = a;
            this.n.w("label", value_);
        }
        get aj() {
            let ret_ = this.n.n("placeholder");
            return ret_;
        }
        set aj(a) {
            let value_ = a;
            this.n.w("placeholder", value_);
        }
        get ak() {
            let ret_ = this.n.n("placeholderSearch");
            return ret_;
        }
        set ak(a) {
            let value_ = a;
            this.n.w("placeholderSearch", value_);
        }
        get v() {
            let ret_ = this.n.n("open");
            return ret_;
        }
        set v(a) {
            let value_ = a;
            this.n.w("open", value_);
        }
        get al() {
            let ret_ = this.n.n("valueKey");
            return ret_;
        }
        set al(a) {
            let value_ = a;
            this.n.w("valueKey", value_);
        }
        get af() {
            let ret_ = this.n.n("displayKey");
            return ret_;
        }
        set af(a) {
            let value_ = a;
            this.n.w("displayKey", value_);
        }
        get ag() {
            let ret_ = this.n.n("groupKey");
            return ret_;
        }
        set ag(a) {
            let value_ = a;
            this.n.w("groupKey", value_);
        }
        get f() {
            let ret_ = this.n.n("groupSorting");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(GroupingDirection_$type, EnumUtil.getEnumValue(GroupingDirection_$type, this.n.f(GroupingDirection_$type, ret_)));
            return EnumUtil.getEnumValue(GroupingDirection_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(GroupingDirection_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.n.w("groupSorting", value_);
        }
        get e() {
            let ret_ = this.n.m("filteringOptions", (a) => new FilteringOptions());
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.n.w("filteringOptions", value_);
        }
        get q() {
            let ret_ = this.n.n("caseSensitiveIcon");
            return ret_;
        }
        set q(a) {
            let value_ = a;
            this.n.w("caseSensitiveIcon", value_);
        }
        get s() {
            let ret_ = this.n.n("disableFiltering");
            return ret_;
        }
        set s(a) {
            let value_ = a;
            this.n.w("disableFiltering", value_);
        }
        get c() {
            let ret_ = this.n.n("value");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.n.w("value", value_);
        }
        get b() {
            let ret_ = this.n.n("selection");
            return ret_;
        }
        get r() {
            let ret_ = this.n.n("disabled");
            return ret_;
        }
        set r(a) {
            let value_ = a;
            this.n.w("disabled", value_);
        }
        get x() {
            let ret_ = this.n.n("required");
            return ret_;
        }
        set x(a) {
            let value_ = a;
            this.n.w("required", value_);
        }
        get ai() {
            let ret_ = this.n.n("name");
            return ret_;
        }
        set ai(a) {
            let value_ = a;
            this.n.w("name", value_);
        }
        get u() {
            let ret_ = this.n.n("invalid");
            return ret_;
        }
        set u(a) {
            let value_ = a;
            this.n.w("invalid", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.n.s("change", (a) => this.change(this, ComboChangeEventArgs.a(a)));
            }
            else {
                this.n.v("change");
            }
        }
        focusChanged() {
            if (this.focus != null) {
                this.n.s("focus", (a) => this.focus(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.n.v("focus");
            }
        }
        blurChanged() {
            if (this.blur != null) {
                this.n.s("blur", (a) => this.blur(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.n.v("blur");
            }
        }
        openingChanged() {
            if (this.opening != null) {
                this.n.s("opening", (a) => this.opening(this, VoidEventArgs.b(a)));
            }
            else {
                this.n.v("opening");
            }
        }
        openedChanged() {
            if (this.opened != null) {
                this.n.s("opened", (a) => this.opened(this, VoidEventArgs.b(a)));
            }
            else {
                this.n.v("opened");
            }
        }
        closingChanged() {
            if (this.closing != null) {
                this.n.s("closing", (a) => this.closing(this, VoidEventArgs.b(a)));
            }
            else {
                this.n.v("closing");
            }
        }
        closedChanged() {
            if (this.closed != null) {
                this.n.s("closed", (a) => this.closed(this, VoidEventArgs.b(a)));
            }
            else {
                this.n.v("closed");
            }
        }
        as() {
            this.nativeElement.connectedCallback();
        }
        av(a) {
            this.nativeElement.focus(this.n.i(a));
        }
        an() {
            this.nativeElement.blur();
        }
        az(a) {
            this.nativeElement.select(this.n.i(a));
        }
        at(a) {
            this.nativeElement.deselect(this.n.i(a));
        }
        y() {
            return (this.nativeElement.show());
        }
        t() {
            return (this.nativeElement.hide());
        }
        aa() {
            return (this.nativeElement.toggle());
        }
        ay() {
            this.nativeElement.reportValidity();
        }
        ap() {
            this.nativeElement.checkValidity();
        }
        a0(a) {
            this.nativeElement.setCustomValidity(this.n.i(a));
        }
    }
    Combo.$t = /*@__PURE__*/ markType(Combo, 'Combo', BaseElement.$);
    return Combo;
})();

/**
 * The Combo component is similar to the Select component in that it provides a list of options from which the user can make a selection.
 * In contrast to the Select component, the Combo component displays all options in a virtualized list of items,
 * meaning the combo box can simultaneously show thousands of options, where one or more options can be selected.
 * Additionally, users can create custom item templates, allowing for robust data visualization.
 * The Combo component features case-sensitive filtering, grouping, complex data binding, dynamic addition of values and more.
*/
class IgrCombo extends Component {
    createImplementation() {
        return new Combo();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._change = null;
        this._change_wrapped = null;
        this._focus = null;
        this._focus_wrapped = null;
        this._blur = null;
        this._blur_wrapped = null;
        this._opening = null;
        this._opening_wrapped = null;
        this._opened = null;
        this._opened_wrapped = null;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcComboComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-combo", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * The data source used to generate the list of options.
    */
    get data() {
        return this.i.a;
    }
    set data(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.a = v;
    }
    /**
     * The outlined attribute of the control.
    */
    get outlined() {
        return this.i.w;
    }
    set outlined(v) {
        this.i.w = ensureBool(v);
    }
    /**
     * Enables single selection mode and moves item filtering to the main input.
    */
    get singleSelect() {
        return this.i.z;
    }
    set singleSelect(v) {
        this.i.z = ensureBool(v);
    }
    /**
     * The autofocus attribute of the control.
    */
    get autofocus() {
        return this.i.o;
    }
    set autofocus(v) {
        this.i.o = ensureBool(v);
    }
    /**
     * Focuses the list of options when the menu opens.
    */
    get autofocusList() {
        return this.i.p;
    }
    set autofocusList(v) {
        this.i.p = ensureBool(v);
    }
    /**
     * The label attribute of the control.
    */
    get label() {
        return this.i.ah;
    }
    set label(v) {
        this.i.ah = v;
    }
    /**
     * The placeholder attribute of the control.
    */
    get placeholder() {
        return this.i.aj;
    }
    set placeholder(v) {
        this.i.aj = v;
    }
    /**
     * The placeholder attribute of the search input.
    */
    get placeholderSearch() {
        return this.i.ak;
    }
    set placeholderSearch(v) {
        this.i.ak = v;
    }
    /**
     * Sets the open state of the component.
    */
    get open() {
        return this.i.v;
    }
    set open(v) {
        this.i.v = ensureBool(v);
    }
    /**
     * The key in the data source used when selecting items.
    */
    get valueKey() {
        return this.i.al;
    }
    set valueKey(v) {
        this.i.al = v;
    }
    /**
     * The key in the data source used to display items in the list.
    */
    get displayKey() {
        return this.i.af;
    }
    set displayKey(v) {
        this.i.af = v;
    }
    /**
     * The key in the data source used to group items in the list.
    */
    get groupKey() {
        return this.i.ag;
    }
    set groupKey(v) {
        this.i.ag = v;
    }
    /**
     * Sorts the items in each group by ascending or descending order.
     * @type {"asc" | "desc" | "none"}
    */
    get groupSorting() {
        return this.i.f;
    }
    set groupSorting(v) {
        this.i.f = ensureEnum(GroupingDirection_$type, v);
    }
    get filteringOptions() {
        const r = this.i.e;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrFilteringOptions();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set filteringOptions(v) {
        v == null ? this.i.e = null : this.i.e = v.i;
    }
    /**
     * Enables the case sensitive search icon in the filtering input.
    */
    get caseSensitiveIcon() {
        return this.i.q;
    }
    set caseSensitiveIcon(v) {
        this.i.q = ensureBool(v);
    }
    /**
     * Disables the filtering of the list of options.
    */
    get disableFiltering() {
        return this.i.s;
    }
    set disableFiltering(v) {
        this.i.s = ensureBool(v);
    }
    get value() {
        return this.i.c;
    }
    set value(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.c = v;
    }
    /**
     * Returns the current selection as an array of objects as provided in the `data` source.
    */
    get selection() {
        return this.i.b;
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.r;
    }
    set disabled(v) {
        this.i.r = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.x;
    }
    set required(v) {
        this.i.x = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.ai;
    }
    set name(v) {
        this.i.ai = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.u;
    }
    set invalid(v) {
        this.i.u = ensureBool(v);
    }
    get itemTemplate() {
        return this._itemTemplate;
    }
    set itemTemplate(v) {
        this._itemTemplate = v;
        if (!this._itemTemplateAdapter) {
            this._itemTemplateAdapter = new ReactTemplateAdapter(this._renderer, this._portalManager, "ae", { html: html });
        }
        this._itemTemplateAdapter.setValue(this.i, this._itemTemplate);
    }
    get groupHeaderTemplate() {
        return this._groupHeaderTemplate;
    }
    set groupHeaderTemplate(v) {
        this._groupHeaderTemplate = v;
        if (!this._groupHeaderTemplateAdapter) {
            this._groupHeaderTemplateAdapter = new ReactTemplateAdapter(this._renderer, this._portalManager, "ad", { html: html });
        }
        this._groupHeaderTemplateAdapter.setValue(this.i, this._groupHeaderTemplate);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.filteringOptions && this.filteringOptions.name && this.filteringOptions.name == name) {
            return this.filteringOptions;
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Combo");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.as();
    }
    /**
     * Sets focus on the component.
    
    */
    focusComponent(options) {
        this.i.av((options == null ? null : options.i));
    }
    /**
     * Removes focus from the component.
    
    */
    blurComponent() {
        this.i.an();
    }
    select(items) {
        this.i.az(items);
    }
    deselect(items) {
        this.i.at(items);
    }
    /**
     * Shows the list of options.
    
    */
    show() {
        let iv = this.i.y();
        return (iv);
    }
    /**
     * Hides the list of options.
    
    */
    hide() {
        let iv = this.i.t();
        return (iv);
    }
    /**
     * Toggles the list of options.
    
    */
    toggle() {
        let iv = this.i.aa();
        return (iv);
    }
    /**
     * Checks for validity of the control and shows the browser message if it invalid.
    
    */
    reportValidity() {
        this.i.ay();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.ap();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.a0(message);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrComboChangeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get focus() {
        return this._focus;
    }
    set focus(ev) {
        if (this._focus_wrapped !== null) {
            this.i.focus = delegateRemove(this.i.focus, this._focus_wrapped);
            this._focus_wrapped = null;
            this._focus = null;
        }
        this._focus = ev;
        this._focus_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFocus) {
                this.beforeFocus(this, outerArgs);
            }
            if (this._focus) {
                this._focus(this, outerArgs);
            }
        };
        this.i.focus = delegateCombine(this.i.focus, this._focus_wrapped);
        if (this.i.focusChanged) {
            this.i.focusChanged();
        }
        ;
    }
    get blur() {
        return this._blur;
    }
    set blur(ev) {
        if (this._blur_wrapped !== null) {
            this.i.blur = delegateRemove(this.i.blur, this._blur_wrapped);
            this._blur_wrapped = null;
            this._blur = null;
        }
        this._blur = ev;
        this._blur_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeBlur) {
                this.beforeBlur(this, outerArgs);
            }
            if (this._blur) {
                this._blur(this, outerArgs);
            }
        };
        this.i.blur = delegateCombine(this.i.blur, this._blur_wrapped);
        if (this.i.blurChanged) {
            this.i.blurChanged();
        }
        ;
    }
    get opening() {
        return this._opening;
    }
    set opening(ev) {
        if (this._opening_wrapped !== null) {
            this.i.opening = delegateRemove(this.i.opening, this._opening_wrapped);
            this._opening_wrapped = null;
            this._opening = null;
        }
        this._opening = ev;
        this._opening_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpening) {
                this.beforeOpening(this, outerArgs);
            }
            if (this._opening) {
                this._opening(this, outerArgs);
            }
        };
        this.i.opening = delegateCombine(this.i.opening, this._opening_wrapped);
        if (this.i.openingChanged) {
            this.i.openingChanged();
        }
        ;
    }
    get opened() {
        return this._opened;
    }
    set opened(ev) {
        if (this._opened_wrapped !== null) {
            this.i.opened = delegateRemove(this.i.opened, this._opened_wrapped);
            this._opened_wrapped = null;
            this._opened = null;
        }
        this._opened = ev;
        this._opened_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpened) {
                this.beforeOpened(this, outerArgs);
            }
            if (this._opened) {
                this._opened(this, outerArgs);
            }
        };
        this.i.opened = delegateCombine(this.i.opened, this._opened_wrapped);
        if (this.i.openedChanged) {
            this.i.openedChanged();
        }
        ;
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrComboModule {
    static register() {
        IgrIconModule.register();
        IgrInputModule.register();
        TypeRegistrar.registerCons('IgrComboChangeEventArgs', IgrComboChangeEventArgs);
        TypeRegistrar.registerCons('IgrCombo', IgrCombo);
        TypeRegistrar.registerCons('IgrCombo', IgrCombo);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SelectItem = /*@__PURE__*/ (() => {
    class SelectItem extends BaseOptionLike {
    }
    SelectItem.$t = /*@__PURE__*/ markType(SelectItem, 'SelectItem', BaseOptionLike.$);
    return SelectItem;
})();

/**
 * Represents an item in a select list.
*/
class IgrSelectItem extends IgrBaseOptionLike {
    createImplementation() {
        return new SelectItem();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSelectItemComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-select-item", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSelectItemModule {
    static register() {
        IgrBaseOptionLikeModule.register();
        TypeRegistrar.registerCons('IgrSelectItem', IgrSelectItem);
        TypeRegistrar.registerCons('IgrSelectItem', IgrSelectItem);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SelectGroup = /*@__PURE__*/ (() => {
    class SelectGroup extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.e = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.b.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.m("items", (a) => new SelectItem());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.c.w("items", value_);
        }
        get d() {
            let ret_ = this.c.n("disabled");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.c.w("disabled", value_);
        }
    }
    SelectGroup.$t = /*@__PURE__*/ markType(SelectGroup, 'SelectGroup', BaseElement.$);
    return SelectGroup;
})();

/**

*/
class IgrSelectGroup extends Component {
    createImplementation() {
        return new SelectGroup();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSelectGroupComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-select-group", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * All child `igc-select-item`s.
    */
    get items() {
        if (!this.i.a) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.a.length; i++) {
            let impl = this.i.a[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrSelectItem) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrSelectItem._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    set items(v) {
        let arr = [];
        for (let i = 0; i < v.length; i++) {
            arr.push(v[i].i);
        }
        this.i.a = arr;
    }
    /**
     * Whether the group item and all its children are disabled.
    */
    get disabled() {
        return this.i.d;
    }
    set disabled(v) {
        this.i.d = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("SelectGroup");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSelectGroupModule {
    static register() {
        IgrSelectItemModule.register();
        TypeRegistrar.registerCons('IgrSelectGroup', IgrSelectGroup);
        TypeRegistrar.registerCons('IgrSelectGroup', IgrSelectGroup);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SelectHeader = /*@__PURE__*/ (() => {
    class SelectHeader extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.c = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.c;
        }
        set nativeElement(a) {
            this.c = a;
            this.a.o = this.c;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
    }
    SelectHeader.$t = /*@__PURE__*/ markType(SelectHeader, 'SelectHeader', BaseElement.$);
    return SelectHeader;
})();

/**
 * Represents a header item in an igc-select component.
*/
class IgrSelectHeader extends Component {
    createImplementation() {
        return new SelectHeader();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSelectHeaderComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-select-header", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("SelectHeader");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSelectHeaderModule {
    static register() {
        TypeRegistrar.registerCons('IgrSelectHeader', IgrSelectHeader);
        TypeRegistrar.registerCons('IgrSelectHeader', IgrSelectHeader);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SelectItemComponentEventArgs = /*@__PURE__*/ (() => {
    class SelectItemComponentEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new SelectItemComponentEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    SelectItemComponentEventArgs.$t = /*@__PURE__*/ markType(SelectItemComponentEventArgs, 'SelectItemComponentEventArgs');
    return SelectItemComponentEventArgs;
})();

class IgrSelectItemComponentEventArgs {
    createImplementation() {
        return new SelectItemComponentEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrSelectItem({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var SelectScrollStrategy = /*@__PURE__*/ (function (SelectScrollStrategy) {
    SelectScrollStrategy[SelectScrollStrategy["Scroll"] = 0] = "Scroll";
    SelectScrollStrategy[SelectScrollStrategy["Block"] = 1] = "Block";
    SelectScrollStrategy[SelectScrollStrategy["Close"] = 2] = "Close";
    return SelectScrollStrategy;
})({});
/**
 * @hidden
 */
let SelectScrollStrategy_$type = /*@__PURE__*/ markEnum('SelectScrollStrategy', 'Scroll,0|Block,1|Close,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Select = /*@__PURE__*/ (() => {
    class Select extends BaseComboBoxLike {
        constructor() {
            super(...arguments);
            this.change = null;
            this.focus = null;
            this.blur = null;
            this.opening = null;
            this.opened = null;
            this.closing = null;
            this.closed = null;
        }
        get ah() {
            let ret_ = this.b.n("value");
            return ret_;
        }
        set ah(a) {
            let value_ = a;
            this.b.w("value", value_);
        }
        get ab() {
            let ret_ = this.b.n("outlined");
            return ret_;
        }
        set ab(a) {
            let value_ = a;
            this.b.w("outlined", value_);
        }
        get y() {
            let ret_ = this.b.n("autofocus");
            return ret_;
        }
        set y(a) {
            let value_ = a;
            this.b.w("autofocus", value_);
        }
        get ad() {
            let ret_ = this.b.n("distance");
            return ret_;
        }
        set ad(a) {
            let value_ = a;
            this.b.w("distance", value_);
        }
        get ae() {
            let ret_ = this.b.n("label");
            return ret_;
        }
        set ae(a) {
            let value_ = a;
            this.b.w("label", value_);
        }
        get ag() {
            let ret_ = this.b.n("placeholder");
            return ret_;
        }
        set ag(a) {
            let value_ = a;
            this.b.w("placeholder", value_);
        }
        get o() {
            let ret_ = this.b.n("placement");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DropdownPlacement_$type, EnumUtil.getEnumValue(DropdownPlacement_$type, this.b.f(DropdownPlacement_$type, ret_)));
            return EnumUtil.getEnumValue(DropdownPlacement_$type, ret_);
        }
        set o(a) {
            let value_ = enumGetBox(DropdownPlacement_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("placement", value_);
        }
        get r() {
            let ret_ = this.b.n("scrollStrategy");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(SelectScrollStrategy_$type, EnumUtil.getEnumValue(SelectScrollStrategy_$type, this.b.f(SelectScrollStrategy_$type, ret_)));
            return EnumUtil.getEnumValue(SelectScrollStrategy_$type, ret_);
        }
        set r(a) {
            let value_ = enumGetBox(SelectScrollStrategy_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.b.w("scrollStrategy", value_);
        }
        get n() {
            let ret_ = this.b.m("items", (a) => new SelectItem());
            return ret_;
        }
        get m() {
            let ret_ = this.b.m("groups", (a) => new SelectGroup());
            return ret_;
        }
        get p() {
            let ret_ = this.b.m("selectedItem", (a) => new SelectItem());
            return ret_;
        }
        get z() {
            let ret_ = this.b.n("disabled");
            return ret_;
        }
        set z(a) {
            let value_ = a;
            this.b.w("disabled", value_);
        }
        get ac() {
            let ret_ = this.b.n("required");
            return ret_;
        }
        set ac(a) {
            let value_ = a;
            this.b.w("required", value_);
        }
        get af() {
            let ret_ = this.b.n("name");
            return ret_;
        }
        set af(a) {
            let value_ = a;
            this.b.w("name", value_);
        }
        get aa() {
            let ret_ = this.b.n("invalid");
            return ret_;
        }
        set aa(a) {
            let value_ = a;
            this.b.w("invalid", value_);
        }
        changeChanged() {
            if (this.change != null) {
                this.b.s("change", (a) => this.change(this, SelectItemComponentEventArgs.b(a)));
            }
            else {
                this.b.v("change");
            }
        }
        focusChanged() {
            if (this.focus != null) {
                this.b.s("focus", (a) => this.focus(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.b.v("focus");
            }
        }
        blurChanged() {
            if (this.blur != null) {
                this.b.s("blur", (a) => this.blur(this, VoidEventArgs.b(a)), false);
            }
            else {
                this.b.v("blur");
            }
        }
        openingChanged() {
            if (this.opening != null) {
                this.b.s("opening", (a) => this.opening(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("opening");
            }
        }
        openedChanged() {
            if (this.opened != null) {
                this.b.s("opened", (a) => this.opened(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("opened");
            }
        }
        closingChanged() {
            if (this.closing != null) {
                this.b.s("closing", (a) => this.closing(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("closing");
            }
        }
        closedChanged() {
            if (this.closed != null) {
                this.b.s("closed", (a) => this.closed(this, VoidEventArgs.b(a)));
            }
            else {
                this.b.v("closed");
            }
        }
        aq(a) {
            this.nativeElement.focus(this.b.i(a));
        }
        aj() {
            this.nativeElement.blur();
        }
        at() {
            this.nativeElement.reportValidity();
        }
        am() {
            this.nativeElement.clearSelection();
        }
        al() {
            this.nativeElement.checkValidity();
        }
        au(a) {
            this.nativeElement.setCustomValidity(this.b.i(a));
        }
    }
    Select.$t = /*@__PURE__*/ markType(Select, 'Select', BaseComboBoxLike.$);
    return Select;
})();

/**
 * Represents a control that provides a menu of options.
*/
class IgrSelect extends IgrBaseComboBoxLike {
    createImplementation() {
        return new Select();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._change = null;
        this._change_wrapped = null;
        this._focus = null;
        this._focus_wrapped = null;
        this._blur = null;
        this._blur_wrapped = null;
        this._opening = null;
        this._opening_wrapped = null;
        this._opened = null;
        this._opened_wrapped = null;
        this._closing = null;
        this._closing_wrapped = null;
        this._closed = null;
        this._closed_wrapped = null;
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcSelectComponent);
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        super.componentDidMount();
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-select", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    get value() {
        return this.i.ah;
    }
    set value(v) {
        this.i.ah = v;
    }
    /**
     * The outlined attribute of the control.
    */
    get outlined() {
        return this.i.ab;
    }
    set outlined(v) {
        this.i.ab = ensureBool(v);
    }
    /**
     * The autofocus attribute of the control.
    */
    get autofocus() {
        return this.i.y;
    }
    set autofocus(v) {
        this.i.y = ensureBool(v);
    }
    /**
     * The distance of the select dropdown from its input.
    */
    get distance() {
        return this.i.ad;
    }
    set distance(v) {
        this.i.ad = +v;
    }
    /**
     * The label attribute of the control.
    */
    get label() {
        return this.i.ae;
    }
    set label(v) {
        this.i.ae = v;
    }
    /**
     * The placeholder attribute of the control.
    */
    get placeholder() {
        return this.i.ag;
    }
    set placeholder(v) {
        this.i.ag = v;
    }
    /**
     * The preferred placement of the select dropdown around its input.
     * @type {'top' | 'top-start' | 'top-end' | 'bottom' | 'bottom-start' | 'bottom-end' | 'right' | 'right-start' | 'right-end' | 'left' | 'left-start' | 'left-end'}
    */
    get placement() {
        return this.i.o;
    }
    set placement(v) {
        this.i.o = ensureEnum(DropdownPlacement_$type, v);
    }
    /**
     * Determines the behavior of the component during scrolling of the parent container.
    */
    get scrollStrategy() {
        return this.i.r;
    }
    set scrollStrategy(v) {
        this.i.r = ensureEnum(SelectScrollStrategy_$type, v);
    }
    /**
     * Returns the items of the igc-select component.
    */
    get items() {
        if (!this.i.n) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.n.length; i++) {
            let impl = this.i.n[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrSelectItem) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrSelectItem._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    /**
     * Returns the groups of the igc-select component.
    */
    get groups() {
        if (!this.i.m) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.m.length; i++) {
            let impl = this.i.m[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrSelectGroup) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrSelectGroup._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    /**
     * Returns the selected item from the dropdown or null.
    */
    get selectedItem() {
        const r = this.i.p;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrSelectItem({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * The disabled state of the component
    */
    get disabled() {
        return this.i.z;
    }
    set disabled(v) {
        this.i.z = ensureBool(v);
    }
    /**
     * Makes the control a required field in a form context.
    */
    get required() {
        return this.i.ac;
    }
    set required(v) {
        this.i.ac = ensureBool(v);
    }
    /**
     * The name attribute of the control.
    */
    get name() {
        return this.i.af;
    }
    set name(v) {
        this.i.af = v;
    }
    /**
     * Control the validity of the control.
    */
    get invalid() {
        return this.i.aa;
    }
    set invalid(v) {
        this.i.aa = ensureBool(v);
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.selectedItem && this.selectedItem._styling) {
            this.selectedItem._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Sets focus on the component.
    
    */
    focusComponent(options) {
        this.i.aq((options == null ? null : options.i));
    }
    /**
     * Removes focus from the component.
    
    */
    blurComponent() {
        this.i.aj();
    }
    /**
     * Checks the validity of the control and moves the focus to it if it is not valid.
    
    */
    reportValidity() {
        this.i.at();
    }
    /**
     * Resets the current value and selection of the component.
    
    */
    clearSelection() {
        this.i.am();
    }
    /**
     * Checks for validity of the control and emits the invalid event if it invalid.
    
    */
    checkValidity() {
        this.i.al();
    }
    /**
     * Sets a custom validation message for the control.
     * As long as `message` is not empty, the control is considered invalid.
    
    */
    setCustomValidity(message) {
        this.i.au(message);
    }
    get change() {
        return this._change;
    }
    set change(ev) {
        if (this._change_wrapped !== null) {
            this.i.change = delegateRemove(this.i.change, this._change_wrapped);
            this._change_wrapped = null;
            this._change = null;
        }
        this._change = ev;
        this._change_wrapped = (o, e) => {
            let outerArgs = new IgrSelectItemComponentEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeChange) {
                this.beforeChange(this, outerArgs);
            }
            if (this._change) {
                this._change(this, outerArgs);
            }
        };
        this.i.change = delegateCombine(this.i.change, this._change_wrapped);
        if (this.i.changeChanged) {
            this.i.changeChanged();
        }
        ;
    }
    get focus() {
        return this._focus;
    }
    set focus(ev) {
        if (this._focus_wrapped !== null) {
            this.i.focus = delegateRemove(this.i.focus, this._focus_wrapped);
            this._focus_wrapped = null;
            this._focus = null;
        }
        this._focus = ev;
        this._focus_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeFocus) {
                this.beforeFocus(this, outerArgs);
            }
            if (this._focus) {
                this._focus(this, outerArgs);
            }
        };
        this.i.focus = delegateCombine(this.i.focus, this._focus_wrapped);
        if (this.i.focusChanged) {
            this.i.focusChanged();
        }
        ;
    }
    get blur() {
        return this._blur;
    }
    set blur(ev) {
        if (this._blur_wrapped !== null) {
            this.i.blur = delegateRemove(this.i.blur, this._blur_wrapped);
            this._blur_wrapped = null;
            this._blur = null;
        }
        this._blur = ev;
        this._blur_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeBlur) {
                this.beforeBlur(this, outerArgs);
            }
            if (this._blur) {
                this._blur(this, outerArgs);
            }
        };
        this.i.blur = delegateCombine(this.i.blur, this._blur_wrapped);
        if (this.i.blurChanged) {
            this.i.blurChanged();
        }
        ;
    }
    get opening() {
        return this._opening;
    }
    set opening(ev) {
        if (this._opening_wrapped !== null) {
            this.i.opening = delegateRemove(this.i.opening, this._opening_wrapped);
            this._opening_wrapped = null;
            this._opening = null;
        }
        this._opening = ev;
        this._opening_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpening) {
                this.beforeOpening(this, outerArgs);
            }
            if (this._opening) {
                this._opening(this, outerArgs);
            }
        };
        this.i.opening = delegateCombine(this.i.opening, this._opening_wrapped);
        if (this.i.openingChanged) {
            this.i.openingChanged();
        }
        ;
    }
    get opened() {
        return this._opened;
    }
    set opened(ev) {
        if (this._opened_wrapped !== null) {
            this.i.opened = delegateRemove(this.i.opened, this._opened_wrapped);
            this._opened_wrapped = null;
            this._opened = null;
        }
        this._opened = ev;
        this._opened_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeOpened) {
                this.beforeOpened(this, outerArgs);
            }
            if (this._opened) {
                this._opened(this, outerArgs);
            }
        };
        this.i.opened = delegateCombine(this.i.opened, this._opened_wrapped);
        if (this.i.openedChanged) {
            this.i.openedChanged();
        }
        ;
    }
    get closing() {
        return this._closing;
    }
    set closing(ev) {
        if (this._closing_wrapped !== null) {
            this.i.closing = delegateRemove(this.i.closing, this._closing_wrapped);
            this._closing_wrapped = null;
            this._closing = null;
        }
        this._closing = ev;
        this._closing_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosing) {
                this.beforeClosing(this, outerArgs);
            }
            if (this._closing) {
                this._closing(this, outerArgs);
            }
        };
        this.i.closing = delegateCombine(this.i.closing, this._closing_wrapped);
        if (this.i.closingChanged) {
            this.i.closingChanged();
        }
        ;
    }
    get closed() {
        return this._closed;
    }
    set closed(ev) {
        if (this._closed_wrapped !== null) {
            this.i.closed = delegateRemove(this.i.closed, this._closed_wrapped);
            this._closed_wrapped = null;
            this._closed = null;
        }
        this._closed = ev;
        this._closed_wrapped = (o, e) => {
            let outerArgs = new IgrVoidEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeClosed) {
                this.beforeClosed(this, outerArgs);
            }
            if (this._closed) {
                this._closed(this, outerArgs);
            }
        };
        this.i.closed = delegateCombine(this.i.closed, this._closed_wrapped);
        if (this.i.closedChanged) {
            this.i.closedChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrSelectModule {
    static register() {
        IgrBaseComboBoxLikeModule.register();
        IgrIconModule.register();
        IgrInputModule.register();
        IgrSelectGroupModule.register();
        IgrSelectHeaderModule.register();
        IgrSelectItemModule.register();
        TypeRegistrar.registerCons('IgrSelectItemComponentEventArgs', IgrSelectItemComponentEventArgs);
        TypeRegistrar.registerCons('IgrSelect', IgrSelect);
        TypeRegistrar.registerCons('IgrSelect', IgrSelect);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StepType = /*@__PURE__*/ (function (StepType) {
    StepType[StepType["In"] = 0] = "In";
    StepType[StepType["Out"] = 1] = "Out";
    return StepType;
})({});
/**
 * @hidden
 */
let StepType_$type = /*@__PURE__*/ markEnum('StepType', 'In,0|Out,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StepDirection = /*@__PURE__*/ (function (StepDirection) {
    StepDirection[StepDirection["Normal"] = 0] = "Normal";
    StepDirection[StepDirection["Reverse"] = 1] = "Reverse";
    return StepDirection;
})({});
/**
 * @hidden
 */
let StepDirection_$type = /*@__PURE__*/ markEnum('StepDirection', 'Normal,0|Reverse,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Step = /*@__PURE__*/ (() => {
    class Step extends BaseElement {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.h = null;
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.h;
        }
        set nativeElement(a) {
            this.h = a;
            this.a.o = this.h;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get f() {
            let ret_ = this.b.n("invalid");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.b.w("invalid", value_);
        }
        get c() {
            let ret_ = this.b.n("active");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("active", value_);
        }
        get g() {
            let ret_ = this.b.n("optional");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.b.w("optional", value_);
        }
        get e() {
            let ret_ = this.b.n("disabled");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.b.w("disabled", value_);
        }
        get d() {
            let ret_ = this.b.n("complete");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("complete", value_);
        }
        k(a, b) {
            this.nativeElement.toggleAnimation(this.b.i(enumGetBox(StepType_$type, a)), this.b.i(enumGetBox(StepDirection_$type, b)));
        }
    }
    Step.$t = /*@__PURE__*/ markType(Step, 'Step', BaseElement.$);
    return Step;
})();

/**
 * The step component is used within the `igc-stepper` element and it holds the content of each step.
 * It also supports custom indicators, title and subtitle.
*/
class IgrStep extends Component {
    createImplementation() {
        return new Step();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcStepComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-step", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Gets/sets whether the step is invalid.
    */
    get invalid() {
        return this.i.f;
    }
    set invalid(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * Gets/sets whether the step is activе.
    */
    get active() {
        return this.i.c;
    }
    set active(v) {
        this.i.c = ensureBool(v);
    }
    /**
     * Gets/sets whether the step is optional.
     * @remarks
     * Optional steps validity does not affect the default behavior when the stepper is in linear mode i.e.
     * if optional step is invalid the user could still move to the next step.
    */
    get optional() {
        return this.i.g;
    }
    set optional(v) {
        this.i.g = ensureBool(v);
    }
    /**
     * Gets/sets whether the step is interactable.
    */
    get disabled() {
        return this.i.e;
    }
    set disabled(v) {
        this.i.e = ensureBool(v);
    }
    /**
     * Gets/sets whether the step is completed.
     * @remarks
     * When set to `true` the following separator is styled `solid`.
    */
    get complete() {
        return this.i.d;
    }
    set complete(v) {
        this.i.d = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Step");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    toggleAnimation(type, direction) {
        this.i.k((type == null ? null : type), (direction == null ? null : direction));
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrStepModule {
    static register() {
        TypeRegistrar.registerCons('IgrStep', IgrStep);
        TypeRegistrar.registerCons('IgrStep', IgrStep);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ActiveStepChangingArgsDetail = /*@__PURE__*/ (() => {
    class ActiveStepChangingArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            let ret_ = this.b.n("oldIndex");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.b.w("oldIndex", value_);
        }
        get c() {
            let ret_ = this.b.n("newIndex");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("newIndex", value_);
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.a.o = this.e;
        }
    }
    ActiveStepChangingArgsDetail.$t = /*@__PURE__*/ markType(ActiveStepChangingArgsDetail, 'ActiveStepChangingArgsDetail');
    return ActiveStepChangingArgsDetail;
})();

class IgrActiveStepChangingArgsDetail {
    createImplementation() {
        return new ActiveStepChangingArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get oldIndex() {
        return this.i.d;
    }
    set oldIndex(v) {
        this.i.d = +v;
    }
    get newIndex() {
        return this.i.c;
    }
    set newIndex(v) {
        this.i.c = +v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ActiveStepChangingArgsEventArgs = /*@__PURE__*/ (() => {
    class ActiveStepChangingArgsEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new ActiveStepChangingArgsEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    ActiveStepChangingArgsEventArgs.$t = /*@__PURE__*/ markType(ActiveStepChangingArgsEventArgs, 'ActiveStepChangingArgsEventArgs');
    return ActiveStepChangingArgsEventArgs;
})();

class IgrActiveStepChangingArgsEventArgs {
    createImplementation() {
        return new ActiveStepChangingArgsEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrActiveStepChangingArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ActiveStepChangedArgsDetail = /*@__PURE__*/ (() => {
    class ActiveStepChangedArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.a = new WCNativeHelper();
            this.d = null;
        }
        get c() {
            let ret_ = this.b.n("index");
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.b.w("index", value_);
        }
        get b() {
            return this.a;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.a.o = this.d;
        }
    }
    ActiveStepChangedArgsDetail.$t = /*@__PURE__*/ markType(ActiveStepChangedArgsDetail, 'ActiveStepChangedArgsDetail');
    return ActiveStepChangedArgsDetail;
})();

class IgrActiveStepChangedArgsDetail {
    createImplementation() {
        return new ActiveStepChangedArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get index() {
        return this.i.c;
    }
    set index(v) {
        this.i.c = +v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ActiveStepChangedArgsEventArgs = /*@__PURE__*/ (() => {
    class ActiveStepChangedArgsEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new ActiveStepChangedArgsEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    ActiveStepChangedArgsEventArgs.$t = /*@__PURE__*/ markType(ActiveStepChangedArgsEventArgs, 'ActiveStepChangedArgsEventArgs');
    return ActiveStepChangedArgsEventArgs;
})();

class IgrActiveStepChangedArgsEventArgs {
    createImplementation() {
        return new ActiveStepChangedArgsEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrActiveStepChangedArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StepperOrientation = /*@__PURE__*/ (function (StepperOrientation) {
    StepperOrientation[StepperOrientation["Horizontal"] = 0] = "Horizontal";
    StepperOrientation[StepperOrientation["Vertical"] = 1] = "Vertical";
    return StepperOrientation;
})({});
/**
 * @hidden
 */
let StepperOrientation_$type = /*@__PURE__*/ markEnum('StepperOrientation', 'Horizontal,0|Vertical,1');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StepperStepType = /*@__PURE__*/ (function (StepperStepType) {
    StepperStepType[StepperStepType["Indicator"] = 0] = "Indicator";
    StepperStepType[StepperStepType["Title"] = 1] = "Title";
    StepperStepType[StepperStepType["Full"] = 2] = "Full";
    return StepperStepType;
})({});
/**
 * @hidden
 */
let StepperStepType_$type = /*@__PURE__*/ markEnum('StepperStepType', 'Indicator,0|Title,1|Full,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StepperVerticalAnimation = /*@__PURE__*/ (function (StepperVerticalAnimation) {
    StepperVerticalAnimation[StepperVerticalAnimation["None"] = 0] = "None";
    StepperVerticalAnimation[StepperVerticalAnimation["Grow"] = 1] = "Grow";
    StepperVerticalAnimation[StepperVerticalAnimation["Fade"] = 2] = "Fade";
    return StepperVerticalAnimation;
})({});
/**
 * @hidden
 */
let StepperVerticalAnimation_$type = /*@__PURE__*/ markEnum('StepperVerticalAnimation', 'None,0|Grow,1|Fade,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StepperHorizontalAnimation = /*@__PURE__*/ (function (StepperHorizontalAnimation) {
    StepperHorizontalAnimation[StepperHorizontalAnimation["None"] = 0] = "None";
    StepperHorizontalAnimation[StepperHorizontalAnimation["Fade"] = 1] = "Fade";
    StepperHorizontalAnimation[StepperHorizontalAnimation["Slide"] = 2] = "Slide";
    return StepperHorizontalAnimation;
})({});
/**
 * @hidden
 */
let StepperHorizontalAnimation_$type = /*@__PURE__*/ markEnum('StepperHorizontalAnimation', 'None,0|Fade,1|Slide,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var StepperTitlePosition = /*@__PURE__*/ (function (StepperTitlePosition) {
    StepperTitlePosition[StepperTitlePosition["Bottom"] = 0] = "Bottom";
    StepperTitlePosition[StepperTitlePosition["Top"] = 1] = "Top";
    StepperTitlePosition[StepperTitlePosition["Start"] = 2] = "Start";
    StepperTitlePosition[StepperTitlePosition["End"] = 3] = "End";
    return StepperTitlePosition;
})({});
/**
 * @hidden
 */
let StepperTitlePosition_$type = /*@__PURE__*/ markEnum('StepperTitlePosition', 'Bottom,0|Top,1|Start,2|End,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let Stepper = /*@__PURE__*/ (() => {
    class Stepper extends BaseElement {
        constructor() {
            super(...arguments);
            this.i = new WCNativeHelper();
            this.n = null;
            this.activeStepChanging = null;
            this.activeStepChanged = null;
        }
        get j() {
            return this.i;
        }
        get nativeElement() {
            return this.n;
        }
        set nativeElement(a) {
            this.n = a;
            this.i.o = this.n;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.j.m("steps", (a) => new Step());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.j.w("steps", value_);
        }
        get e() {
            let ret_ = this.j.n("orientation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StepperOrientation_$type, EnumUtil.getEnumValue(StepperOrientation_$type, this.j.f(StepperOrientation_$type, ret_)));
            return EnumUtil.getEnumValue(StepperOrientation_$type, ret_);
        }
        set e(a) {
            let value_ = enumGetBox(StepperOrientation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("orientation", value_);
        }
        get f() {
            let ret_ = this.j.n("stepType");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StepperStepType_$type, EnumUtil.getEnumValue(StepperStepType_$type, this.j.f(StepperStepType_$type, ret_)));
            return EnumUtil.getEnumValue(StepperStepType_$type, ret_);
        }
        set f(a) {
            let value_ = enumGetBox(StepperStepType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("stepType", value_);
        }
        get l() {
            let ret_ = this.j.n("linear");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.j.w("linear", value_);
        }
        get k() {
            let ret_ = this.j.n("contentTop");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.j.w("contentTop", value_);
        }
        get h() {
            let ret_ = this.j.n("verticalAnimation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StepperVerticalAnimation_$type, EnumUtil.getEnumValue(StepperVerticalAnimation_$type, this.j.f(StepperVerticalAnimation_$type, ret_)));
            return EnumUtil.getEnumValue(StepperVerticalAnimation_$type, ret_);
        }
        set h(a) {
            let value_ = enumGetBox(StepperVerticalAnimation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("verticalAnimation", value_);
        }
        get d() {
            let ret_ = this.j.n("horizontalAnimation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StepperHorizontalAnimation_$type, EnumUtil.getEnumValue(StepperHorizontalAnimation_$type, this.j.f(StepperHorizontalAnimation_$type, ret_)));
            return EnumUtil.getEnumValue(StepperHorizontalAnimation_$type, ret_);
        }
        set d(a) {
            let value_ = enumGetBox(StepperHorizontalAnimation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("horizontalAnimation", value_);
        }
        get m() {
            let ret_ = this.j.n("animationDuration");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.j.w("animationDuration", value_);
        }
        get g() {
            let ret_ = this.j.n("titlePosition");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(StepperTitlePosition_$type, EnumUtil.getEnumValue(StepperTitlePosition_$type, this.j.f(StepperTitlePosition_$type, ret_)));
            return EnumUtil.getEnumValue(StepperTitlePosition_$type, ret_);
        }
        set g(a) {
            let value_ = enumGetBox(StepperTitlePosition_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.j.w("titlePosition", value_);
        }
        activeStepChangingChanged() {
            if (this.activeStepChanging != null) {
                this.j.s("activeStepChanging", (a) => this.activeStepChanging(this, ActiveStepChangingArgsEventArgs.b(a)));
            }
            else {
                this.j.v("activeStepChanging");
            }
        }
        activeStepChangedChanged() {
            if (this.activeStepChanged != null) {
                this.j.s("activeStepChanged", (a) => this.activeStepChanged(this, ActiveStepChangedArgsEventArgs.b(a)));
            }
            else {
                this.j.v("activeStepChanged");
            }
        }
        r() {
            this.nativeElement.connectedCallback();
        }
        s(a) {
            this.nativeElement.navigateTo(this.j.i(a));
        }
        t() {
            this.nativeElement.next();
        }
        u() {
            this.nativeElement.prev();
        }
        v() {
            this.nativeElement.reset();
        }
    }
    Stepper.$t = /*@__PURE__*/ markType(Stepper, 'Stepper', BaseElement.$);
    return Stepper;
})();

/**
 * IgxStepper provides a wizard-like workflow by dividing content into logical steps.
 * @remarks
 * The stepper component allows the user to navigate between multiple steps.
 * It supports horizontal and vertical orientation as well as keyboard navigation and provides API methods to control the active step.
*/
class IgrStepper extends Component {
    createImplementation() {
        return new Stepper();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._activeStepChanging = null;
        this._activeStepChanging_wrapped = null;
        this._activeStepChanged = null;
        this._activeStepChanged_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        defineComponents(IgcStepperComponent);
        this._implementation = this.createImplementation();
        this._portalManager = new PortalManager("templates", () => {
            if (this.mounted) {
                this.setState({});
            }
        });
        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
            this._renderer = new ReactRenderer(this._implementation.nativeElement, document, false, null, this._portalManager);
        }
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.i.nativeElement = this._elRef;
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        const nativePropsName = Object.keys(this.props).filter(prop => !isValidProp(this, prop) && prop !== "originalRef");
        const nativeProps = {};
        nativePropsName.forEach(propName => {
            nativeProps[propName] = this.props[propName];
        });
        let propChildren = this.props.children;
        let children = [];
        Children.forEach(propChildren, (ch) => {
            children.push(cloneElement(ch));
        });
        this._portalManager.onRender(children);
        let style = {};
        if (this.props.style) {
            style = this.props.style;
        }
        let div = createElement("igc-stepper", Object.assign(Object.assign({}, nativeProps), { ref: this._getMainRef, id: this.props.id, class: this.props.className, style: style, children: children }));
        return div;
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    /**
     * Returns all of the stepper's steps.
    */
    get steps() {
        if (!this.i.a) {
            return undefined;
        }
        let ret = [];
        for (let i = 0; i < this.i.a.length; i++) {
            let impl = this.i.a[i];
            if (!impl.externalObject) {
                if (impl instanceof IgrStep) {
                    ret.push(impl);
                    continue;
                }
                let e = IgrStep._createFromInternal(impl);
                e._implementation = impl;
                impl.externalObject = e;
            }
            ret.push(impl.externalObject);
        }
        return ret;
    }
    set steps(v) {
        let arr = [];
        for (let i = 0; i < v.length; i++) {
            arr.push(v[i].i);
        }
        this.i.a = arr;
    }
    /**
     * Gets/Sets the orientation of the stepper.
     * @remarks
     * Default value is `horizontal`.
    */
    get orientation() {
        return this.i.e;
    }
    set orientation(v) {
        this.i.e = ensureEnum(StepperOrientation_$type, v);
    }
    /**
     * Get/Set the type of the steps.
     * @remarks
     * Default value is `full`.
    */
    get stepType() {
        return this.i.f;
    }
    set stepType(v) {
        this.i.f = ensureEnum(StepperStepType_$type, v);
    }
    /**
     * Get/Set whether the stepper is linear.
     * @remarks
     * If the stepper is in linear mode and if the active step is valid only then the user is able to move forward.
    */
    get linear() {
        return this.i.l;
    }
    set linear(v) {
        this.i.l = ensureBool(v);
    }
    /**
     * Get/Set whether the content is displayed above the steps.
     * @remarks
     * Default value is `false` and the content is below the steps.
    */
    get contentTop() {
        return this.i.k;
    }
    set contentTop(v) {
        this.i.k = ensureBool(v);
    }
    /**
     * The animation type when in vertical mode.
    */
    get verticalAnimation() {
        return this.i.h;
    }
    set verticalAnimation(v) {
        this.i.h = ensureEnum(StepperVerticalAnimation_$type, v);
    }
    /**
     * The animation type when in horizontal mode.
    */
    get horizontalAnimation() {
        return this.i.d;
    }
    set horizontalAnimation(v) {
        this.i.d = ensureEnum(StepperHorizontalAnimation_$type, v);
    }
    /**
     * The animation duration in either vertical or horizontal mode.
    */
    get animationDuration() {
        return this.i.m;
    }
    set animationDuration(v) {
        this.i.m = +v;
    }
    /**
     * Get/Set the position of the steps title.
     * @remarks
     * The default value is undefined.
     * When the stepper is horizontally orientated the title is positioned below the indicator.
     * When the stepper is horizontally orientated the title is positioned on the right side of the indicator.
    */
    get titlePosition() {
        return this.i.g;
    }
    set titlePosition(v) {
        this.i.g = ensureEnum(StepperTitlePosition_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Stepper");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
    connectedCallback() {
        this.i.r();
    }
    /**
     * Activates the step at a given index.
    
    */
    navigateTo(index) {
        this.i.s(index);
    }
    /**
     * Activates the next enabled step.
    
    */
    next() {
        this.i.t();
    }
    /**
     * Activates the previous enabled step.
    
    */
    prev() {
        this.i.u();
    }
    /**
     * Resets the stepper to its initial state i.e. activates the first step.
     * @remarks
     * The steps' content will not be automatically reset.
    
    */
    reset() {
        this.i.v();
    }
    get activeStepChanging() {
        return this._activeStepChanging;
    }
    set activeStepChanging(ev) {
        if (this._activeStepChanging_wrapped !== null) {
            this.i.activeStepChanging = delegateRemove(this.i.activeStepChanging, this._activeStepChanging_wrapped);
            this._activeStepChanging_wrapped = null;
            this._activeStepChanging = null;
        }
        this._activeStepChanging = ev;
        this._activeStepChanging_wrapped = (o, e) => {
            let outerArgs = new IgrActiveStepChangingArgsEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeActiveStepChanging) {
                this.beforeActiveStepChanging(this, outerArgs);
            }
            if (this._activeStepChanging) {
                this._activeStepChanging(this, outerArgs);
            }
        };
        this.i.activeStepChanging = delegateCombine(this.i.activeStepChanging, this._activeStepChanging_wrapped);
        if (this.i.activeStepChangingChanged) {
            this.i.activeStepChangingChanged();
        }
        ;
    }
    get activeStepChanged() {
        return this._activeStepChanged;
    }
    set activeStepChanged(ev) {
        if (this._activeStepChanged_wrapped !== null) {
            this.i.activeStepChanged = delegateRemove(this.i.activeStepChanged, this._activeStepChanged_wrapped);
            this._activeStepChanged_wrapped = null;
            this._activeStepChanged = null;
        }
        this._activeStepChanged = ev;
        this._activeStepChanged_wrapped = (o, e) => {
            let outerArgs = new IgrActiveStepChangedArgsEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeActiveStepChanged) {
                this.beforeActiveStepChanged(this, outerArgs);
            }
            if (this._activeStepChanged) {
                this._activeStepChanged(this, outerArgs);
            }
        };
        this.i.activeStepChanged = delegateCombine(this.i.activeStepChanged, this._activeStepChanged_wrapped);
        if (this.i.activeStepChangedChanged) {
            this.i.activeStepChangedChanged();
        }
        ;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrStepperModule {
    static register() {
        TypeRegistrar.registerCons('IgrActiveStepChangingArgsEventArgs', IgrActiveStepChangingArgsEventArgs);
        TypeRegistrar.registerCons('IgrActiveStepChangedArgsEventArgs', IgrActiveStepChangedArgsEventArgs);
        IgrStepModule.register();
        TypeRegistrar.registerCons('IgrStepper', IgrStepper);
        TypeRegistrar.registerCons('IgrStepper', IgrStepper);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneScrollEventArgs = /*@__PURE__*/ (() => {
    class PaneScrollEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new PaneScrollEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    PaneScrollEventArgs.$t = /*@__PURE__*/ markType(PaneScrollEventArgs, 'PaneScrollEventArgs');
    return PaneScrollEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneScrollEventArgsDetail = /*@__PURE__*/ (() => {
    class PaneScrollEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.d = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.b.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.m("pane", (a) => new ContentPane());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.c.w("pane", value_);
        }
    }
    PaneScrollEventArgsDetail.$t = /*@__PURE__*/ markType(PaneScrollEventArgsDetail, 'PaneScrollEventArgsDetail');
    return PaneScrollEventArgsDetail;
})();

class IgrPaneScrollEventArgsDetail {
    createImplementation() {
        return new PaneScrollEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the content pane that is scrolled.
    */
    get pane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrContentPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set pane(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.pane && this.pane.name && this.pane.name == name) {
            return this.pane;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

class IgrPaneScrollEventArgs {
    createImplementation() {
        return new PaneScrollEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneScrollEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SplitterResizeEventArgs = /*@__PURE__*/ (() => {
    class SplitterResizeEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
            this.b = 0;
            this.d = 0;
            this.c = 0;
        }
    }
    SplitterResizeEventArgs.$t = /*@__PURE__*/ markType(SplitterResizeEventArgs, 'SplitterResizeEventArgs');
    return SplitterResizeEventArgs;
})();

class IgrSplitterResizeEventArgs {
    createImplementation() {
        return new SplitterResizeEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the pane being resized with the splitter.
    */
    get pane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set pane(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    /**
     * Gets the pane's orientation.
    */
    get orientation() {
        return this.i.b;
    }
    set orientation(v) {
        this.i.b = ensureEnum(SplitPaneOrientation_$type, v);
    }
    /**
     * Gets the pane's width.
    */
    get paneWidth() {
        return this.i.d;
    }
    set paneWidth(v) {
        this.i.d = +v;
    }
    /**
     * Gets the pane's height.
    */
    get paneHeight() {
        return this.i.c;
    }
    set paneHeight(v) {
        this.i.c = +v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ActivePaneEventArgsDetail = /*@__PURE__*/ (() => {
    class ActivePaneEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.d.m("newPane", (a) => new ContentPane());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("newPane", value_);
        }
        get b() {
            let ret_ = this.d.m("oldPane", (a) => new ContentPane());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("oldPane", value_);
        }
    }
    ActivePaneEventArgsDetail.$t = /*@__PURE__*/ markType(ActivePaneEventArgsDetail, 'ActivePaneEventArgsDetail');
    return ActivePaneEventArgsDetail;
})();

class IgrActivePaneEventArgsDetail {
    createImplementation() {
        return new ActivePaneEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the new active pane.
    */
    get newPane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrContentPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set newPane(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    /**
     * Gets the old active pane.
    */
    get oldPane() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrContentPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set oldPane(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.newPane && this.newPane.name && this.newPane.name == name) {
            return this.newPane;
        }
        if (this.oldPane && this.oldPane.name && this.oldPane.name == name) {
            return this.oldPane;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var ResizerLocation = /*@__PURE__*/ (function (ResizerLocation) {
    ResizerLocation[ResizerLocation["Top"] = 0] = "Top";
    ResizerLocation[ResizerLocation["Bottom"] = 1] = "Bottom";
    ResizerLocation[ResizerLocation["Left"] = 2] = "Left";
    ResizerLocation[ResizerLocation["Right"] = 3] = "Right";
    ResizerLocation[ResizerLocation["TopLeft"] = 4] = "TopLeft";
    ResizerLocation[ResizerLocation["TopRight"] = 5] = "TopRight";
    ResizerLocation[ResizerLocation["BottomLeft"] = 6] = "BottomLeft";
    ResizerLocation[ResizerLocation["BottomRight"] = 7] = "BottomRight";
    return ResizerLocation;
})({});
/**
 * @hidden
 */
let ResizerLocation_$type = /*@__PURE__*/ markEnum('ResizerLocation', 'Top:top,0|Bottom:bottom,1|Left:left,2|Right:right,3|TopLeft:topLeft,4|TopRight:topRight,5|BottomLeft:bottomLeft,6|BottomRight:bottomRight,7');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FloatingPaneResizeEventArgsDetail = /*@__PURE__*/ (() => {
    class FloatingPaneResizeEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.m("sourcePane", (a) => new SplitPane());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("sourcePane", value_);
        }
        get a() {
            let ret_ = this.d.n("resizerLocation");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(ResizerLocation_$type, EnumUtil.getEnumValue(ResizerLocation_$type, this.d.f(ResizerLocation_$type, ret_)));
            return EnumUtil.getEnumValue(ResizerLocation_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(ResizerLocation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.d.w("resizerLocation", value_);
        }
    }
    FloatingPaneResizeEventArgsDetail.$t = /*@__PURE__*/ markType(FloatingPaneResizeEventArgsDetail, 'FloatingPaneResizeEventArgsDetail');
    return FloatingPaneResizeEventArgsDetail;
})();

class IgrFloatingPaneResizeEventArgsDetail {
    createImplementation() {
        return new FloatingPaneResizeEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the source pane that triggers the resize operation.
    */
    get sourcePane() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrSplitPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set sourcePane(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    /**
     * Gets the edge/corner that is being dragged.
    */
    get resizerLocation() {
        return this.i.a;
    }
    set resizerLocation(v) {
        this.i.a = ensureEnum(ResizerLocation_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.sourcePane && this.sourcePane.name && this.sourcePane.name == name) {
            return this.sourcePane;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FloatingPaneResizeMoveEventArgsDetail = /*@__PURE__*/ (() => {
    class FloatingPaneResizeMoveEventArgsDetail extends FloatingPaneResizeEventArgsDetail {
        get m() {
            let ret_ = this.d.n("oldWidth");
            return ret_;
        }
        set m(a) {
            let value_ = a;
            this.d.w("oldWidth", value_);
        }
        get k() {
            let ret_ = this.d.n("newWidth");
            return ret_;
        }
        set k(a) {
            let value_ = a;
            this.d.w("newWidth", value_);
        }
        get l() {
            let ret_ = this.d.n("oldHeight");
            return ret_;
        }
        set l(a) {
            let value_ = a;
            this.d.w("oldHeight", value_);
        }
        get j() {
            let ret_ = this.d.n("newHeight");
            return ret_;
        }
        set j(a) {
            let value_ = a;
            this.d.w("newHeight", value_);
        }
        get i() {
            let ret_ = this.d.m("oldLocation", (a) => new DockManagerPoint());
            return ret_;
        }
        set i(a) {
            let value_ = a;
            this.d.w("oldLocation", value_);
        }
        get h() {
            let ret_ = this.d.m("newLocation", (a) => new DockManagerPoint());
            return ret_;
        }
        set h(a) {
            let value_ = a;
            this.d.w("newLocation", value_);
        }
    }
    FloatingPaneResizeMoveEventArgsDetail.$t = /*@__PURE__*/ markType(FloatingPaneResizeMoveEventArgsDetail, 'FloatingPaneResizeMoveEventArgsDetail', FloatingPaneResizeEventArgsDetail.$);
    return FloatingPaneResizeMoveEventArgsDetail;
})();

class IgrFloatingPaneResizeMoveEventArgsDetail extends IgrFloatingPaneResizeEventArgsDetail {
    createImplementation() {
        return new FloatingPaneResizeMoveEventArgsDetail();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    /**
     * Gets the pane's width before the resizing operation.
    */
    get oldWidth() {
        return this.i.m;
    }
    set oldWidth(v) {
        this.i.m = +v;
    }
    /**
     * Gets the pane's width after the resizing operation.
    */
    get newWidth() {
        return this.i.k;
    }
    set newWidth(v) {
        this.i.k = +v;
    }
    /**
     * Gets the pane's height before the resizing operation.
    */
    get oldHeight() {
        return this.i.l;
    }
    set oldHeight(v) {
        this.i.l = +v;
    }
    /**
     * Gets the pane's height after the resizing operation.
    */
    get newHeight() {
        return this.i.j;
    }
    set newHeight(v) {
        this.i.j = +v;
    }
    /**
     * Gets the pane's floating location before the resizing operation.
    */
    get oldLocation() {
        const r = this.i.i;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerPoint();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set oldLocation(v) {
        v == null ? this.i.i = null : this.i.i = v.i;
    }
    /**
     * Gets the pane's floating location after the resizing operation.
    */
    get newLocation() {
        const r = this.i.h;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerPoint();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set newLocation(v) {
        v == null ? this.i.h = null : this.i.h = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.oldLocation && this.oldLocation.name && this.oldLocation.name == name) {
            return this.oldLocation;
        }
        if (this.newLocation && this.newLocation.name && this.newLocation.name == name) {
            return this.newLocation;
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let KeyBindingHandler = /*@__PURE__*/ (() => {
    class KeyBindingHandler extends Base {
    }
    KeyBindingHandler.$t = /*@__PURE__*/ markType(KeyBindingHandler, 'KeyBindingHandler');
    return KeyBindingHandler;
})();

class IgrKeyBindingHandler {
    createImplementation() {
        return new KeyBindingHandler();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let KeyBindingOptions = /*@__PURE__*/ (() => {
    class KeyBindingOptions extends Base {
    }
    KeyBindingOptions.$t = /*@__PURE__*/ markType(KeyBindingOptions, 'KeyBindingOptions');
    return KeyBindingOptions;
})();

class IgrKeyBindingOptions {
    createImplementation() {
        return new KeyBindingOptions();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var KeyBindingTrigger = /*@__PURE__*/ (function (KeyBindingTrigger) {
    KeyBindingTrigger[KeyBindingTrigger["Keydown"] = 0] = "Keydown";
    KeyBindingTrigger[KeyBindingTrigger["Keyup"] = 1] = "Keyup";
    KeyBindingTrigger[KeyBindingTrigger["KeydownRepeat"] = 2] = "KeydownRepeat";
    return KeyBindingTrigger;
})({});
/**
 * @hidden
 */
let KeyBindingTrigger_$type = /*@__PURE__*/ markEnum('KeyBindingTrigger', 'Keydown,0|Keyup,1|KeydownRepeat,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneCloseEventArgsDetail = /*@__PURE__*/ (() => {
    class PaneCloseEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.m("sourcePane", (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("sourcePane", value_);
        }
        get a() {
            let ret_ = this.d.n("panes");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("panes", value_);
        }
    }
    PaneCloseEventArgsDetail.$t = /*@__PURE__*/ markType(PaneCloseEventArgsDetail, 'PaneCloseEventArgsDetail');
    return PaneCloseEventArgsDetail;
})();

class IgrPaneCloseEventArgsDetail {
    createImplementation() {
        return new PaneCloseEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._panes = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Get the source pane that triggers the close.
    */
    get sourcePane() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set sourcePane(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    /**
     * Gets/sets the panes that are about to close.
    */
    get panes() {
        if (this._panes === null) {
            let coll = new IgrContentPaneCollection();
            let innerColl = this.i.a;
            if (!innerColl) {
                innerColl = new ContentPaneCollection();
            }
            this._panes = coll._fromInner(innerColl);
            this.i.a = innerColl;
        }
        return this._panes;
    }
    set panes(v) {
        if (this._panes !== null) {
            this._panes._setSyncTarget(null);
            this._panes = null;
        }
        let coll = new IgrContentPaneCollection();
        this._panes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ContentPane.$type);
        let innerColl = this.i.a;
        if (!innerColl) {
            innerColl = new ContentPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._panes._setSyncTarget(syncColl);
        this.i.a = innerColl;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.sourcePane && this.sourcePane.name && this.sourcePane.name == name) {
            return this.sourcePane;
        }
        if (this.panes != null && this.panes.findByName && this.panes.findByName(name)) {
            return this.panes.findByName(name);
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneDragEndEventArgsDetail = /*@__PURE__*/ (() => {
    class PaneDragEndEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.m("sourcePane", (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("sourcePane", value_);
        }
        get a() {
            let ret_ = this.d.n("panes");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("panes", value_);
        }
    }
    PaneDragEndEventArgsDetail.$t = /*@__PURE__*/ markType(PaneDragEndEventArgsDetail, 'PaneDragEndEventArgsDetail');
    return PaneDragEndEventArgsDetail;
})();

class IgrPaneDragEndEventArgsDetail {
    createImplementation() {
        return new PaneDragEndEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._panes = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the source pane that ends dragging.
    */
    get sourcePane() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set sourcePane(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    /**
     * Gets the panes that end dragging.
    */
    get panes() {
        if (this._panes === null) {
            let coll = new IgrContentPaneCollection();
            let innerColl = this.i.a;
            if (!innerColl) {
                innerColl = new ContentPaneCollection();
            }
            this._panes = coll._fromInner(innerColl);
            this.i.a = innerColl;
        }
        return this._panes;
    }
    set panes(v) {
        if (this._panes !== null) {
            this._panes._setSyncTarget(null);
            this._panes = null;
        }
        let coll = new IgrContentPaneCollection();
        this._panes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ContentPane.$type);
        let innerColl = this.i.a;
        if (!innerColl) {
            innerColl = new ContentPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._panes._setSyncTarget(syncColl);
        this.i.a = innerColl;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.sourcePane && this.sourcePane.name && this.sourcePane.name == name) {
            return this.sourcePane;
        }
        if (this.panes != null && this.panes.findByName && this.panes.findByName(name)) {
            return this.panes.findByName(name);
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneDragAction = /*@__PURE__*/ (() => {
    class PaneDragAction extends Base {
    }
    PaneDragAction.$t = /*@__PURE__*/ markType(PaneDragAction, 'PaneDragAction');
    return PaneDragAction;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneDragOverEventArgsDetail = /*@__PURE__*/ (() => {
    class PaneDragOverEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.g = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.g;
        }
        set nativeElement(a) {
            this.g = a;
            this.d.o = this.g;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.e.m("sourcePane", (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.e.w("sourcePane", value_);
        }
        get a() {
            let ret_ = this.e.n("panes");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.e.w("panes", value_);
        }
        get c() {
            let ret_ = this.e.m("action", (a) => new PaneDragAction());
            return ret_;
        }
        set c(a) {
            let value_ = a;
            this.e.w("action", value_);
        }
        get f() {
            let ret_ = this.e.n("isValid");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.e.w("isValid", value_);
        }
    }
    PaneDragOverEventArgsDetail.$t = /*@__PURE__*/ markType(PaneDragOverEventArgsDetail, 'PaneDragOverEventArgsDetail');
    return PaneDragOverEventArgsDetail;
})();

class IgrPaneDragAction extends Component {
    createImplementation() {
        return new PaneDragAction();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("PaneDragAction");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
}

class IgrPaneDragOverEventArgsDetail {
    createImplementation() {
        return new PaneDragOverEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._panes = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the source pane that triggers the drag over.
    */
    get sourcePane() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set sourcePane(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    /**
     * Gets the panes that are dragged over.
    */
    get panes() {
        if (this._panes === null) {
            let coll = new IgrContentPaneCollection();
            let innerColl = this.i.a;
            if (!innerColl) {
                innerColl = new ContentPaneCollection();
            }
            this._panes = coll._fromInner(innerColl);
            this.i.a = innerColl;
        }
        return this._panes;
    }
    set panes(v) {
        if (this._panes !== null) {
            this._panes._setSyncTarget(null);
            this._panes = null;
        }
        let coll = new IgrContentPaneCollection();
        this._panes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ContentPane.$type);
        let innerColl = this.i.a;
        if (!innerColl) {
            innerColl = new ContentPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._panes._setSyncTarget(syncColl);
        this.i.a = innerColl;
    }
    /**
     * Gets information about the action being performed.
    */
    get action() {
        const r = this.i.c;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneDragAction({});
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set action(v) {
        v == null ? this.i.c = null : this.i.c = v.i;
    }
    /**
     * Gets/sets whether the action is valid.
    */
    get isValid() {
        return this.i.f;
    }
    set isValid(v) {
        this.i.f = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.sourcePane && this.sourcePane.name && this.sourcePane.name == name) {
            return this.sourcePane;
        }
        if (this.panes != null && this.panes.findByName && this.panes.findByName(name)) {
            return this.panes.findByName(name);
        }
        if (this.action && this.action.name && this.action.name == name) {
            return this.action;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneDragStartEventArgsDetail = /*@__PURE__*/ (() => {
    class PaneDragStartEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.m("sourcePane", (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("sourcePane", value_);
        }
        get a() {
            let ret_ = this.d.n("panes");
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("panes", value_);
        }
    }
    PaneDragStartEventArgsDetail.$t = /*@__PURE__*/ markType(PaneDragStartEventArgsDetail, 'PaneDragStartEventArgsDetail');
    return PaneDragStartEventArgsDetail;
})();

class IgrPaneDragStartEventArgsDetail {
    createImplementation() {
        return new PaneDragStartEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._panes = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the source pane that triggers the drag start.
    */
    get sourcePane() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set sourcePane(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    /**
     * Gets the panes that are about to get dragged.
    */
    get panes() {
        if (this._panes === null) {
            let coll = new IgrContentPaneCollection();
            let innerColl = this.i.a;
            if (!innerColl) {
                innerColl = new ContentPaneCollection();
            }
            this._panes = coll._fromInner(innerColl);
            this.i.a = innerColl;
        }
        return this._panes;
    }
    set panes(v) {
        if (this._panes !== null) {
            this._panes._setSyncTarget(null);
            this._panes = null;
        }
        let coll = new IgrContentPaneCollection();
        this._panes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ContentPane.$type);
        let innerColl = this.i.a;
        if (!innerColl) {
            innerColl = new ContentPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._panes._setSyncTarget(syncColl);
        this.i.a = innerColl;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.sourcePane && this.sourcePane.name && this.sourcePane.name == name) {
            return this.sourcePane;
        }
        if (this.panes != null && this.panes.findByName && this.panes.findByName(name)) {
            return this.panes.findByName(name);
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneHeaderElement = /*@__PURE__*/ (() => {
    class PaneHeaderElement extends BaseElement {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.d = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.d;
        }
        set nativeElement(a) {
            this.d = a;
            this.b.o = this.d;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.m("dragService", (a) => new DragService());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.c.w("dragService", value_);
        }
    }
    PaneHeaderElement.$t = /*@__PURE__*/ markType(PaneHeaderElement, 'PaneHeaderElement', BaseElement.$);
    return PaneHeaderElement;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneHeaderConnectionEventArgsDetail = /*@__PURE__*/ (() => {
    class PaneHeaderConnectionEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.d.m("pane", (a) => new ContentPane());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("pane", value_);
        }
        get b() {
            let ret_ = this.d.m("element", (a) => new PaneHeaderElement());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("element", value_);
        }
    }
    PaneHeaderConnectionEventArgsDetail.$t = /*@__PURE__*/ markType(PaneHeaderConnectionEventArgsDetail, 'PaneHeaderConnectionEventArgsDetail');
    return PaneHeaderConnectionEventArgsDetail;
})();

/**
 * Describes a pane header element.
*/
class IgrPaneHeaderElement {
    createImplementation() {
        return new PaneHeaderElement();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets/sets the drag service.
    */
    get dragService() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDragService();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set dragService(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.dragService && this.dragService.name && this.dragService.name == name) {
            return this.dragService;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

class IgrPaneHeaderConnectionEventArgsDetail {
    createImplementation() {
        return new PaneHeaderConnectionEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * The pane whose header is being connected/disconnected.
    */
    get pane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrContentPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set pane(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    /**
     * The header element that is being connected/disconnected.
    */
    get element() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneHeaderElement();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set element(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.pane && this.pane.name && this.pane.name == name) {
            return this.pane;
        }
        if (this.element && this.element.name && this.element.name == name) {
            return this.element;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PanePinnedEventArgsDetail = /*@__PURE__*/ (() => {
    class PanePinnedEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.g = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.g;
        }
        set nativeElement(a) {
            this.g = a;
            this.d.o = this.g;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.e.m("sourcePane", (a) => new ContentPane());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.e.w("sourcePane", value_);
        }
        get b() {
            let ret_ = this.e.n("panes");
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.e.w("panes", value_);
        }
        get f() {
            let ret_ = this.e.n("newValue");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.e.w("newValue", value_);
        }
        get c() {
            let ret_ = this.e.n("location");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(UnpinnedLocation_$type, EnumUtil.getEnumValue(UnpinnedLocation_$type, this.e.f(UnpinnedLocation_$type, ret_)));
            return EnumUtil.getEnumValue(UnpinnedLocation_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(UnpinnedLocation_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("location", value_);
        }
    }
    PanePinnedEventArgsDetail.$t = /*@__PURE__*/ markType(PanePinnedEventArgsDetail, 'PanePinnedEventArgsDetail');
    return PanePinnedEventArgsDetail;
})();

class IgrPanePinnedEventArgsDetail {
    createImplementation() {
        return new PanePinnedEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._panes = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the source pane that triggers the pinned state change.
    */
    get sourcePane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrContentPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set sourcePane(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    /**
     * Gets/sets the panes that are about to get pinned/unpinned.
    */
    get panes() {
        if (this._panes === null) {
            let coll = new IgrContentPaneCollection();
            let innerColl = this.i.b;
            if (!innerColl) {
                innerColl = new ContentPaneCollection();
            }
            this._panes = coll._fromInner(innerColl);
            this.i.b = innerColl;
        }
        return this._panes;
    }
    set panes(v) {
        if (this._panes !== null) {
            this._panes._setSyncTarget(null);
            this._panes = null;
        }
        let coll = new IgrContentPaneCollection();
        this._panes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ContentPane.$type);
        let innerColl = this.i.b;
        if (!innerColl) {
            innerColl = new ContentPaneCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._panes._setSyncTarget(syncColl);
        this.i.b = innerColl;
    }
    /**
     * Gets the new pinned value.
    */
    get newValue() {
        return this.i.f;
    }
    set newValue(v) {
        this.i.f = ensureBool(v);
    }
    /**
     * Gets the unpinned location.
    */
    get location() {
        return this.i.c;
    }
    set location(v) {
        this.i.c = ensureEnum(UnpinnedLocation_$type, v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.sourcePane && this.sourcePane.name && this.sourcePane.name == name) {
            return this.sourcePane;
        }
        if (this.panes != null && this.panes.findByName && this.panes.findByName(name)) {
            return this.panes.findByName(name);
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TabHeaderConnectionEventArgsDetail = /*@__PURE__*/ (() => {
    class TabHeaderConnectionEventArgsDetail extends Base {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.e = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.c.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.d.m("pane", (a) => new ContentPane());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("pane", value_);
        }
        get b() {
            let ret_ = this.d.m("element", (a) => new TabHeaderElement());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.d.w("element", value_);
        }
    }
    TabHeaderConnectionEventArgsDetail.$t = /*@__PURE__*/ markType(TabHeaderConnectionEventArgsDetail, 'TabHeaderConnectionEventArgsDetail');
    return TabHeaderConnectionEventArgsDetail;
})();

class IgrTabHeaderConnectionEventArgsDetail {
    createImplementation() {
        return new TabHeaderConnectionEventArgsDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * The pane whose tab header is being connected/disconnected.
    */
    get pane() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrContentPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set pane(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    /**
     * The tab header element that is being connected/disconnected.
    */
    get element() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrTabHeaderElement();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set element(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.pane && this.pane.name && this.pane.name == name) {
            return this.pane;
        }
        if (this.element && this.element.name && this.element.name == name) {
            return this.element;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeSelectionChange = /*@__PURE__*/ (() => {
    class TreeSelectionChange extends Base {
    }
    TreeSelectionChange.$t = /*@__PURE__*/ markType(TreeSelectionChange, 'TreeSelectionChange');
    return TreeSelectionChange;
})();

class IgrTreeSelectionChange {
    createImplementation() {
        return new TreeSelectionChange();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ValidatorHandler = /*@__PURE__*/ (() => {
    class ValidatorHandler extends Base {
    }
    ValidatorHandler.$t = /*@__PURE__*/ markType(ValidatorHandler, 'ValidatorHandler');
    return ValidatorHandler;
})();

class IgrValidatorHandler {
    createImplementation() {
        return new ValidatorHandler();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

class IgrTreeItemCollection extends IgCollection {
    constructor(list) {
        super();
        if (!IgrTreeItem.$type) {
            IgrTreeItem.$type = markType(IgrTreeItem, "IgrTreeItem");
        }
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        if (!IgrTreeItem.$type) {
            IgrTreeItem.$type = markType(IgrTreeItem, "IgrTreeItem");
        }
        let coll = new SyncableObservableCollection$2(IgrTreeItem.$type, TreeItem.$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext._implementation;
        };
        coll.createFrom = (int) => {
            let ext = int.externalObject;
            if (!ext) {
                ext = IgrTreeItem._createFromInternal(int);
                if (ext) {
                    if (!int.$type && ext._implementation.setNativeElement) {
                        ext._implementation.setNativeElement(int);
                    }
                    else {
                        ext._implementation = int;
                    }
                }
            }
            return ext;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeItemCollection = /*@__PURE__*/ (() => {
    class TreeItemCollection extends ObservableCollection$1 {
        constructor() {
            super(TreeItem.$, 0);
        }
    }
    TreeItemCollection.$t = /*@__PURE__*/ markType(TreeItemCollection, 'TreeItemCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(TreeItem.$));
    return TreeItemCollection;
})();

class IgrDropdownItemCollection extends IgCollection {
    constructor(list) {
        super();
        if (!IgrDropdownItem.$type) {
            IgrDropdownItem.$type = markType(IgrDropdownItem, "IgrDropdownItem");
        }
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        if (!IgrDropdownItem.$type) {
            IgrDropdownItem.$type = markType(IgrDropdownItem, "IgrDropdownItem");
        }
        let coll = new SyncableObservableCollection$2(IgrDropdownItem.$type, DropdownItem.$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp._implementation) {
                comp = comp._implementation;
            }
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext._implementation;
        };
        coll.createFrom = (int) => {
            let ext = int.externalObject;
            if (!ext) {
                ext = IgrDropdownItem._createFromInternal(int);
                if (ext) {
                    if (!int.$type && ext._implementation.setNativeElement) {
                        ext._implementation.setNativeElement(int);
                    }
                    else {
                        ext._implementation = int;
                    }
                }
            }
            return ext;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DropdownItemCollection = /*@__PURE__*/ (() => {
    class DropdownItemCollection extends ObservableCollection$1 {
        constructor() {
            super(DropdownItem.$, 0);
        }
    }
    DropdownItemCollection.$t = /*@__PURE__*/ markType(DropdownItemCollection, 'DropdownItemCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(DropdownItem.$));
    return DropdownItemCollection;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeSelectionOptionsEventDetail = /*@__PURE__*/ (() => {
    class TreeSelectionOptionsEventDetail extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
    }
    TreeSelectionOptionsEventDetail.$t = /*@__PURE__*/ markType(TreeSelectionOptionsEventDetail, 'TreeSelectionOptionsEventDetail');
    return TreeSelectionOptionsEventDetail;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TreeSelectionOptionsEventArgs = /*@__PURE__*/ (() => {
    class TreeSelectionOptionsEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            let b = (a.newSelection);
            let c = new TreeItemCollection();
            for (let e = 0; e < b.length; e++) {
                let d = b[e];
                let f = new TreeItem();
                f.setNativeElement(d);
                c.add(f);
            }
            let g = ((() => {
                let $ret = new TreeSelectionOptionsEventArgs();
                $ret.b = new TreeSelectionOptionsEventDetail();
                return $ret;
            })());
            g.b.a = c;
            return g;
        }
    }
    TreeSelectionOptionsEventArgs.$t = /*@__PURE__*/ markType(TreeSelectionOptionsEventArgs, 'TreeSelectionOptionsEventArgs');
    return TreeSelectionOptionsEventArgs;
})();

class IgrTreeSelectionOptionsEventDetail {
    createImplementation() {
        return new TreeSelectionOptionsEventDetail();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._newSelection = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get newSelection() {
        if (this._newSelection === null) {
            let coll = new IgrTreeItemCollection();
            let innerColl = this.i.a;
            if (!innerColl) {
                innerColl = new TreeItemCollection();
            }
            this._newSelection = coll._fromInner(innerColl);
            this.i.a = innerColl;
        }
        return this._newSelection;
    }
    set newSelection(v) {
        if (this._newSelection !== null) {
            this._newSelection._setSyncTarget(null);
            this._newSelection = null;
        }
        let coll = new IgrTreeItemCollection();
        this._newSelection = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(TreeItem.$type);
        let innerColl = this.i.a;
        if (!innerColl) {
            innerColl = new TreeItemCollection();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._newSelection._setSyncTarget(syncColl);
        this.i.a = innerColl;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.newSelection != null && this.newSelection.findByName && this.newSelection.findByName(name)) {
            return this.newSelection.findByName(name);
        }
        return null;
    }
}

class IgrTreeSelectionOptionsEventArgs {
    createImplementation() {
        return new TreeSelectionOptionsEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrTreeSelectionOptionsEventDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var PaneDragActionType = /*@__PURE__*/ (function (PaneDragActionType) {
    PaneDragActionType[PaneDragActionType["FloatPane"] = 0] = "FloatPane";
    PaneDragActionType[PaneDragActionType["MoveFloatingPane"] = 1] = "MoveFloatingPane";
    PaneDragActionType[PaneDragActionType["DockPane"] = 2] = "DockPane";
    PaneDragActionType[PaneDragActionType["MoveTab"] = 3] = "MoveTab";
    return PaneDragActionType;
})({});
/**
 * @hidden
 */
let PaneDragActionType_$type = /*@__PURE__*/ markEnum('PaneDragActionType', 'FloatPane,0|MoveFloatingPane,1|DockPane,2|MoveTab,3');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DockingIndicatorPosition = /*@__PURE__*/ (function (DockingIndicatorPosition) {
    DockingIndicatorPosition[DockingIndicatorPosition["Left"] = 0] = "Left";
    DockingIndicatorPosition[DockingIndicatorPosition["OuterLeft"] = 1] = "OuterLeft";
    DockingIndicatorPosition[DockingIndicatorPosition["Right"] = 2] = "Right";
    DockingIndicatorPosition[DockingIndicatorPosition["OuterRight"] = 3] = "OuterRight";
    DockingIndicatorPosition[DockingIndicatorPosition["Top"] = 4] = "Top";
    DockingIndicatorPosition[DockingIndicatorPosition["OuterTop"] = 5] = "OuterTop";
    DockingIndicatorPosition[DockingIndicatorPosition["Bottom"] = 6] = "Bottom";
    DockingIndicatorPosition[DockingIndicatorPosition["OuterBottom"] = 7] = "OuterBottom";
    DockingIndicatorPosition[DockingIndicatorPosition["Center"] = 8] = "Center";
    return DockingIndicatorPosition;
})({});
/**
 * @hidden
 */
let DockingIndicatorPosition_$type = /*@__PURE__*/ markEnum('DockingIndicatorPosition', 'Left:left,0|OuterLeft:outerLeft,1|Right:right,2|OuterRight:outerRight,3|Top:top,4|OuterTop:outerTop,5|Bottom:bottom,6|OuterBottom:outerBottom,7|Center:center,8');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DockingIndicator = /*@__PURE__*/ (() => {
    class DockingIndicator extends Base {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.e = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.e;
        }
        set nativeElement(a) {
            this.e = a;
            this.b.o = this.e;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.n("position");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(DockingIndicatorPosition_$type, EnumUtil.getEnumValue(DockingIndicatorPosition_$type, this.c.f(DockingIndicatorPosition_$type, ret_)));
            return EnumUtil.getEnumValue(DockingIndicatorPosition_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(DockingIndicatorPosition_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("position", value_);
        }
        get d() {
            let ret_ = this.c.n("isRoot");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.c.w("isRoot", value_);
        }
        get g() {
            let ret_ = this.c.n("direction");
            return ret_;
        }
        set g(a) {
            let value_ = a;
            this.c.w("direction", value_);
        }
    }
    DockingIndicator.$t = /*@__PURE__*/ markType(DockingIndicator, 'DockingIndicator');
    return DockingIndicator;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let DockPaneAction = /*@__PURE__*/ (() => {
    class DockPaneAction extends PaneDragAction {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.f = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.d.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.e.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(PaneDragActionType_$type, EnumUtil.getEnumValue(PaneDragActionType_$type, this.e.f(PaneDragActionType_$type, ret_)));
            return EnumUtil.getEnumValue(PaneDragActionType_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(PaneDragActionType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("type", value_);
        }
        get a() {
            let ret_ = this.e.m("dockingIndicator", (a) => new DockingIndicator());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.e.w("dockingIndicator", value_);
        }
        get b() {
            let ret_ = this.e.m("targetPane", (a) => DockManagerPane.createFromNative(a));
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.e.w("targetPane", value_);
        }
    }
    DockPaneAction.$t = /*@__PURE__*/ markType(DockPaneAction, 'DockPaneAction', PaneDragAction.$);
    return DockPaneAction;
})();

class IgrDockingIndicator {
    createImplementation() {
        return new DockingIndicator();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    /**
     * Gets the position of the docking indicator.
    */
    get position() {
        return this.i.a;
    }
    set position(v) {
        this.i.a = ensureEnum(DockingIndicatorPosition_$type, v);
    }
    /**
     * Gets a value indicating whether the docking indicator is a root one.
    */
    get isRoot() {
        return this.i.d;
    }
    set isRoot(v) {
        this.i.d = ensureBool(v);
    }
    /**
     * Gets a value indicating the direction of the docking indicator.
    */
    get direction() {
        return this.i.g;
    }
    set direction(v) {
        this.i.g = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

class IgrDockPaneAction extends IgrPaneDragAction {
    createImplementation() {
        return new DockPaneAction();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    get type() {
        return this.i.c;
    }
    set type(v) {
        this.i.c = ensureEnum(PaneDragActionType_$type, v);
    }
    get dockingIndicator() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockingIndicator();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set dockingIndicator(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    get targetPane() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrDockManagerPane._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set targetPane(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.dockingIndicator && this.dockingIndicator.name && this.dockingIndicator.name == name) {
            return this.dockingIndicator;
        }
        if (this.targetPane && this.targetPane.name && this.targetPane.name == name) {
            return this.targetPane;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.targetPane && this.targetPane._styling) {
            this.targetPane._styling(container, component, this);
        }
        this._inStyling = false;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FloatPaneAction = /*@__PURE__*/ (() => {
    class FloatPaneAction extends PaneDragAction {
        constructor() {
            super(...arguments);
            this.c = new WCNativeHelper();
            this.g = null;
        }
        get d() {
            return this.c;
        }
        get nativeElement() {
            return this.g;
        }
        set nativeElement(a) {
            this.g = a;
            this.c.o = this.g;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get b() {
            let ret_ = this.d.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(PaneDragActionType_$type, EnumUtil.getEnumValue(PaneDragActionType_$type, this.d.f(PaneDragActionType_$type, ret_)));
            return EnumUtil.getEnumValue(PaneDragActionType_$type, ret_);
        }
        set b(a) {
            let value_ = enumGetBox(PaneDragActionType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.d.w("type", value_);
        }
        get a() {
            let ret_ = this.d.m("location", (a) => new DockManagerPoint());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.d.w("location", value_);
        }
        get f() {
            let ret_ = this.d.n("width");
            return ret_;
        }
        set f(a) {
            let value_ = a;
            this.d.w("width", value_);
        }
        get e() {
            let ret_ = this.d.n("height");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.d.w("height", value_);
        }
    }
    FloatPaneAction.$t = /*@__PURE__*/ markType(FloatPaneAction, 'FloatPaneAction', PaneDragAction.$);
    return FloatPaneAction;
})();

class IgrFloatPaneAction extends IgrPaneDragAction {
    createImplementation() {
        return new FloatPaneAction();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    get type() {
        return this.i.b;
    }
    set type(v) {
        this.i.b = ensureEnum(PaneDragActionType_$type, v);
    }
    get location() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerPoint();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set location(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    get width() {
        return this.i.f;
    }
    set width(v) {
        this.i.f = +v;
    }
    get height() {
        return this.i.e;
    }
    set height(v) {
        this.i.e = +v;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.location && this.location.name && this.location.name == name) {
            return this.location;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let MoveFloatingPaneAction = /*@__PURE__*/ (() => {
    class MoveFloatingPaneAction extends PaneDragAction {
        constructor() {
            super(...arguments);
            this.d = new WCNativeHelper();
            this.f = null;
        }
        get e() {
            return this.d;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.d.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get c() {
            let ret_ = this.e.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(PaneDragActionType_$type, EnumUtil.getEnumValue(PaneDragActionType_$type, this.e.f(PaneDragActionType_$type, ret_)));
            return EnumUtil.getEnumValue(PaneDragActionType_$type, ret_);
        }
        set c(a) {
            let value_ = enumGetBox(PaneDragActionType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.e.w("type", value_);
        }
        get b() {
            let ret_ = this.e.m("oldLocation", (a) => new DockManagerPoint());
            return ret_;
        }
        set b(a) {
            let value_ = a;
            this.e.w("oldLocation", value_);
        }
        get a() {
            let ret_ = this.e.m("newLocation", (a) => new DockManagerPoint());
            return ret_;
        }
        set a(a) {
            let value_ = a;
            this.e.w("newLocation", value_);
        }
    }
    MoveFloatingPaneAction.$t = /*@__PURE__*/ markType(MoveFloatingPaneAction, 'MoveFloatingPaneAction', PaneDragAction.$);
    return MoveFloatingPaneAction;
})();

class IgrMoveFloatingPaneAction extends IgrPaneDragAction {
    createImplementation() {
        return new MoveFloatingPaneAction();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    get type() {
        return this.i.c;
    }
    set type(v) {
        this.i.c = ensureEnum(PaneDragActionType_$type, v);
    }
    get oldLocation() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerPoint();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set oldLocation(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
    get newLocation() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrDockManagerPoint();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set newLocation(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.oldLocation && this.oldLocation.name && this.oldLocation.name == name) {
            return this.oldLocation;
        }
        if (this.newLocation && this.newLocation.name && this.newLocation.name == name) {
            return this.newLocation;
        }
        return null;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let MoveTabAction = /*@__PURE__*/ (() => {
    class MoveTabAction extends PaneDragAction {
        constructor() {
            super(...arguments);
            this.b = new WCNativeHelper();
            this.f = null;
        }
        get c() {
            return this.b;
        }
        get nativeElement() {
            return this.f;
        }
        set nativeElement(a) {
            this.f = a;
            this.b.o = this.f;
        }
        setNativeElement(a) {
            this.nativeElement = a;
        }
        get a() {
            let ret_ = this.c.n("type");
            if ((ret_ === undefined && this.___rawMode)) {
                return undefined;
            }
            ret_ = enumGetBox(PaneDragActionType_$type, EnumUtil.getEnumValue(PaneDragActionType_$type, this.c.f(PaneDragActionType_$type, ret_)));
            return EnumUtil.getEnumValue(PaneDragActionType_$type, ret_);
        }
        set a(a) {
            let value_ = enumGetBox(PaneDragActionType_$type, a);
            value_ = WCNativeHelper.camel(value_.toString());
            this.c.w("type", value_);
        }
        get e() {
            let ret_ = this.c.n("oldIndex");
            return ret_;
        }
        set e(a) {
            let value_ = a;
            this.c.w("oldIndex", value_);
        }
        get d() {
            let ret_ = this.c.n("newIndex");
            return ret_;
        }
        set d(a) {
            let value_ = a;
            this.c.w("newIndex", value_);
        }
    }
    MoveTabAction.$t = /*@__PURE__*/ markType(MoveTabAction, 'MoveTabAction', PaneDragAction.$);
    return MoveTabAction;
})();

class IgrMoveTabAction extends IgrPaneDragAction {
    createImplementation() {
        return new MoveTabAction();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    get type() {
        return this.i.a;
    }
    set type(v) {
        this.i.a = ensureEnum(PaneDragActionType_$type, v);
    }
    get oldIndex() {
        return this.i.e;
    }
    set oldIndex(v) {
        this.i.e = +v;
    }
    get newIndex() {
        return this.i.d;
    }
    set newIndex(v) {
        this.i.d = +v;
    }
    setNativeElement(element) {
        this.i.setNativeElement(element);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDockManagerPointModule {
    static register() {
        TypeRegistrar.registerCons("IgrDockManagerPoint", IgrDockManagerPoint);
        TypeRegistrar.register("DockManagerPoint", DockManagerPoint.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrPaneHeaderElementModule {
    static register() {
        TypeRegistrar.registerCons("IgrPaneHeaderElement", IgrPaneHeaderElement);
        TypeRegistrar.register("PaneHeaderElement", PaneHeaderElement.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrDragServiceModule {
    static register() {
        TypeRegistrar.registerCons("IgrDragService", IgrDragService);
        TypeRegistrar.register("DragService", DragService.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ActivePaneEventArgs = /*@__PURE__*/ (() => {
    class ActivePaneEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new ActivePaneEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    ActivePaneEventArgs.$t = /*@__PURE__*/ markType(ActivePaneEventArgs, 'ActivePaneEventArgs');
    return ActivePaneEventArgs;
})();

class IgrActivePaneEventArgs {
    createImplementation() {
        return new ActivePaneEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrActivePaneEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FloatingPaneResizeEventArgs = /*@__PURE__*/ (() => {
    class FloatingPaneResizeEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new FloatingPaneResizeEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    FloatingPaneResizeEventArgs.$t = /*@__PURE__*/ markType(FloatingPaneResizeEventArgs, 'FloatingPaneResizeEventArgs');
    return FloatingPaneResizeEventArgs;
})();

class IgrFloatingPaneResizeEventArgs {
    createImplementation() {
        return new FloatingPaneResizeEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrFloatingPaneResizeEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FloatingPaneResizeMoveEventArgs = /*@__PURE__*/ (() => {
    class FloatingPaneResizeMoveEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new FloatingPaneResizeMoveEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    FloatingPaneResizeMoveEventArgs.$t = /*@__PURE__*/ markType(FloatingPaneResizeMoveEventArgs, 'FloatingPaneResizeMoveEventArgs');
    return FloatingPaneResizeMoveEventArgs;
})();

class IgrFloatingPaneResizeMoveEventArgs {
    createImplementation() {
        return new FloatingPaneResizeMoveEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrFloatingPaneResizeMoveEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneCloseEventArgs = /*@__PURE__*/ (() => {
    class PaneCloseEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new PaneCloseEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    PaneCloseEventArgs.$t = /*@__PURE__*/ markType(PaneCloseEventArgs, 'PaneCloseEventArgs');
    return PaneCloseEventArgs;
})();

class IgrPaneCloseEventArgs {
    createImplementation() {
        return new PaneCloseEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneCloseEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneDragEndEventArgs = /*@__PURE__*/ (() => {
    class PaneDragEndEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new PaneDragEndEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    PaneDragEndEventArgs.$t = /*@__PURE__*/ markType(PaneDragEndEventArgs, 'PaneDragEndEventArgs');
    return PaneDragEndEventArgs;
})();

class IgrPaneDragEndEventArgs {
    createImplementation() {
        return new PaneDragEndEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneDragEndEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneDragOverEventArgs = /*@__PURE__*/ (() => {
    class PaneDragOverEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new PaneDragOverEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    PaneDragOverEventArgs.$t = /*@__PURE__*/ markType(PaneDragOverEventArgs, 'PaneDragOverEventArgs');
    return PaneDragOverEventArgs;
})();

class IgrPaneDragOverEventArgs {
    createImplementation() {
        return new PaneDragOverEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneDragOverEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneDragStartEventArgs = /*@__PURE__*/ (() => {
    class PaneDragStartEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new PaneDragStartEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    PaneDragStartEventArgs.$t = /*@__PURE__*/ markType(PaneDragStartEventArgs, 'PaneDragStartEventArgs');
    return PaneDragStartEventArgs;
})();

class IgrPaneDragStartEventArgs {
    createImplementation() {
        return new PaneDragStartEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneDragStartEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PaneHeaderConnectionEventArgs = /*@__PURE__*/ (() => {
    class PaneHeaderConnectionEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new PaneHeaderConnectionEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    PaneHeaderConnectionEventArgs.$t = /*@__PURE__*/ markType(PaneHeaderConnectionEventArgs, 'PaneHeaderConnectionEventArgs');
    return PaneHeaderConnectionEventArgs;
})();

class IgrPaneHeaderConnectionEventArgs {
    createImplementation() {
        return new PaneHeaderConnectionEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPaneHeaderConnectionEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let PanePinnedEventArgs = /*@__PURE__*/ (() => {
    class PanePinnedEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new PanePinnedEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    PanePinnedEventArgs.$t = /*@__PURE__*/ markType(PanePinnedEventArgs, 'PanePinnedEventArgs');
    return PanePinnedEventArgs;
})();

class IgrPanePinnedEventArgs {
    createImplementation() {
        return new PanePinnedEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrPanePinnedEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TabHeaderConnectionEventArgs = /*@__PURE__*/ (() => {
    class TabHeaderConnectionEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
        }
        static a(a) {
            return ((() => {
                let $ret = new TabHeaderConnectionEventArgs();
                $ret.b = a;
                return $ret;
            })());
        }
    }
    TabHeaderConnectionEventArgs.$t = /*@__PURE__*/ markType(TabHeaderConnectionEventArgs, 'TabHeaderConnectionEventArgs');
    return TabHeaderConnectionEventArgs;
})();

class IgrTabHeaderConnectionEventArgs {
    createImplementation() {
        return new TabHeaderConnectionEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.b;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrTabHeaderConnectionEventArgsDetail();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.b = null : this.i.b = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let NumberFormatOptions_$type = /*@__PURE__*/ new Type(null, 'NumberFormatOptions', null, []);

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FormData = /*@__PURE__*/ (() => {
    class FormData extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
            this.b = null;
        }
    }
    FormData.$t = /*@__PURE__*/ markType(FormData, 'FormData');
    return FormData;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var DateRangeType = /*@__PURE__*/ (function (DateRangeType) {
    DateRangeType[DateRangeType["After"] = 0] = "After";
    DateRangeType[DateRangeType["Before"] = 1] = "Before";
    DateRangeType[DateRangeType["Between"] = 2] = "Between";
    DateRangeType[DateRangeType["Specific"] = 3] = "Specific";
    DateRangeType[DateRangeType["Weekdays"] = 4] = "Weekdays";
    DateRangeType[DateRangeType["Weekends"] = 5] = "Weekends";
    return DateRangeType;
})({});
/**
 * @hidden
 */
let DateRangeType_$type = /*@__PURE__*/ markEnum('DateRangeType', 'After,0|Before,1|Between,2|Specific,3|Weekdays,4|Weekends,5');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CalendarDate = /*@__PURE__*/ (() => {
    class CalendarDate extends Base {
        constructor() {
            super(...arguments);
            this.d = new Date();
            this.a = false;
            this.c = false;
            this.b = false;
        }
    }
    CalendarDate.$t = /*@__PURE__*/ markType(CalendarDate, 'CalendarDate');
    return CalendarDate;
})();

class IgrCalendarDate {
    createImplementation() {
        return new CalendarDate();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get date() {
        return this.i.d;
    }
    set date(v) {
        this.i.d = v;
    }
    get isCurrentMonth() {
        return this.i.a;
    }
    set isCurrentMonth(v) {
        this.i.a = ensureBool(v);
    }
    get isPrevMonth() {
        return this.i.c;
    }
    set isPrevMonth(v) {
        this.i.c = ensureBool(v);
    }
    get isNextMonth() {
        return this.i.b;
    }
    set isNextMonth(v) {
        this.i.b = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CalendarDateEventArgs = /*@__PURE__*/ (() => {
    class CalendarDateEventArgs extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
        }
        static b(a) {
            return ((() => {
                let $ret = new CalendarDateEventArgs();
                $ret.a = a;
                return $ret;
            })());
        }
    }
    CalendarDateEventArgs.$t = /*@__PURE__*/ markType(CalendarDateEventArgs, 'CalendarDateEventArgs');
    return CalendarDateEventArgs;
})();

class IgrCalendarDateEventArgs {
    createImplementation() {
        return new CalendarDateEventArgs();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get detail() {
        const r = this.i.a;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrCalendarDate();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set detail(v) {
        v == null ? this.i.a = null : this.i.a = v.i;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
var SizableComponentSize = /*@__PURE__*/ (function (SizableComponentSize) {
    SizableComponentSize[SizableComponentSize["Large"] = 0] = "Large";
    SizableComponentSize[SizableComponentSize["Small"] = 1] = "Small";
    SizableComponentSize[SizableComponentSize["Medium"] = 2] = "Medium";
    return SizableComponentSize;
})({});
/**
 * @hidden
 */
let SizableComponentSize_$type = /*@__PURE__*/ markEnum('SizableComponentSize', 'Large,0|Small,1|Medium,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let FocusOptions = /*@__PURE__*/ (() => {
    class FocusOptions extends Base {
        constructor() {
            super(...arguments);
            this.a = false;
        }
    }
    FocusOptions.$t = /*@__PURE__*/ markType(FocusOptions, 'FocusOptions');
    return FocusOptions;
})();

class IgrFocusOptions {
    createImplementation() {
        return new FocusOptions();
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this.mounted = false;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    get preventScroll() {
        return this.i.a;
    }
    set preventScroll(v) {
        this.i.a = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
}

export { Accordion, ActivePaneEventArgs, ActivePaneEventArgsDetail, ActiveStepChangedArgsDetail, ActiveStepChangedArgsEventArgs, ActiveStepChangingArgsDetail, ActiveStepChangingArgsEventArgs, Avatar, AvatarShape, AvatarShape_$type, Badge, BadgeShape, BadgeShape_$type, Banner, BaseAlertLike, BaseAlertLikePosition, BaseAlertLikePosition_$type, BaseComboBoxLike, BaseElement, BaseOptionLike, Button, ButtonBase, ButtonBaseTarget, ButtonBaseTarget_$type, ButtonBaseType, ButtonBaseType_$type, ButtonGroup, ButtonGroupAlignment, ButtonGroupAlignment_$type, ButtonGroupSelection, ButtonGroupSelection_$type, ButtonVariant, ButtonVariant_$type, Calendar, CalendarActiveView, CalendarActiveView_$type, CalendarBase, CalendarBaseSelection, CalendarBaseSelection_$type, CalendarDate, CalendarDateEventArgs, CalendarFormatOptions, CalendarHeaderOrientation, CalendarHeaderOrientation_$type, CalendarOrientation, CalendarOrientation_$type, CalendarResourceStrings, Card, CardActions, CardActionsOrientation, CardActionsOrientation_$type, CardContent, CardHeader, CardMedia, Checkbox, CheckboxBase, CheckboxBaseLabelPosition, CheckboxBaseLabelPosition_$type, CheckboxChangeEventArgs, CheckboxChangeEventArgsDetail, Chip, CircularGradient, CircularProgress, Combo, ComboChangeEventArgs, ComboChangeEventArgsDetail, ComboChangeType, ComboChangeType_$type, ComponentBoolValueChangedEventArgs, ComponentDataValueChangedEventArgs, ComponentDateValueChangedEventArgs, ComponentValueChangedEventArgs, ContentPane, ContentPaneCollection, DatePart, DatePartDeltas, DatePart_$type, DatePicker, DatePickerHeaderOrientation, DatePickerHeaderOrientation_$type, DatePickerMode, DatePickerMode_$type, DatePickerOrientation, DatePickerOrientation_$type, DateRangeDescriptor, DateRangeType, DateRangeType_$type, DateTimeInput, Dialog, Divider, DividerType, DividerType_$type, DockManager, DockManagerLayout, DockManagerPane, DockManagerPaneCollection, DockManagerPaneType, DockManagerPaneType_$type, DockManagerPoint, DockManagerResourceStrings, DockManagerShowHeaderIconOnHover, DockManagerShowHeaderIconOnHover_$type, DockManagerShowPaneHeaders, DockManagerShowPaneHeaders_$type, DockPaneAction, DockingIndicator, DockingIndicatorPosition, DockingIndicatorPosition_$type, DocumentHost, DragService, Dropdown, DropdownGroup, DropdownHeader, DropdownItem, DropdownItemCollection, DropdownItemComponentEventArgs, DropdownPlacement, DropdownPlacement_$type, DropdownScrollStrategy, DropdownScrollStrategy_$type, ExpansionPanel, ExpansionPanelComponentEventArgs, ExpansionPanelIndicatorPosition, ExpansionPanelIndicatorPosition_$type, FilteringOptions, FloatPaneAction, FloatingPaneResizeEventArgs, FloatingPaneResizeEventArgsDetail, FloatingPaneResizeMoveEventArgs, FloatingPaneResizeMoveEventArgsDetail, FocusOptions, FormData, GroupingDirection, GroupingDirection_$type, HtmlMarkupHelperCollection, IDateRangeDescriptor_$type, Icon, IconButton, IconButtonVariant, IconButtonVariant_$type, IconMeta, IgrAccordion, IgrAccordionModule, IgrActivePaneEventArgs, IgrActivePaneEventArgsDetail, IgrActiveStepChangedArgsDetail, IgrActiveStepChangedArgsEventArgs, IgrActiveStepChangingArgsDetail, IgrActiveStepChangingArgsEventArgs, IgrAvatar, IgrAvatarModule, IgrBadge, IgrBadgeModule, IgrBanner, IgrBannerModule, IgrBaseAlertLike, IgrBaseAlertLikeModule, IgrBaseComboBoxLike, IgrBaseComboBoxLikeModule, IgrBaseOptionLike, IgrBaseOptionLikeModule, IgrButton, IgrButtonBase, IgrButtonBaseModule, IgrButtonGroup, IgrButtonGroupModule, IgrButtonModule, IgrCalendar, IgrCalendarBase, IgrCalendarBaseModule, IgrCalendarDate, IgrCalendarDateEventArgs, IgrCalendarFormatOptions, IgrCalendarModule, IgrCalendarResourceStrings, IgrCard, IgrCardActions, IgrCardActionsModule, IgrCardContent, IgrCardContentModule, IgrCardHeader, IgrCardHeaderModule, IgrCardMedia, IgrCardMediaModule, IgrCardModule, IgrCheckbox, IgrCheckboxBase, IgrCheckboxBaseModule, IgrCheckboxChangeEventArgs, IgrCheckboxChangeEventArgsDetail, IgrCheckboxModule, IgrChip, IgrChipModule, IgrCircularGradient, IgrCircularGradientModule, IgrCircularProgress, IgrCircularProgressModule, IgrCombo, IgrComboChangeEventArgs, IgrComboChangeEventArgsDetail, IgrComboModule, IgrComponentBoolValueChangedEventArgs, IgrComponentDataValueChangedEventArgs, IgrComponentDateValueChangedEventArgs, IgrComponentValueChangedEventArgs, IgrContentPane, IgrContentPaneCollection, IgrContentPaneModule, IgrDatePartDeltas, IgrDatePicker, IgrDatePickerModule, IgrDateTimeInput, IgrDateTimeInputModule, IgrDialog, IgrDialogModule, IgrDivider, IgrDividerModule, IgrDockManager, IgrDockManagerLayout, IgrDockManagerLayoutModule, IgrDockManagerModule, IgrDockManagerPane, IgrDockManagerPaneCollection, IgrDockManagerPoint, IgrDockManagerPointModule, IgrDockManagerResourceStrings, IgrDockPaneAction, IgrDockingIndicator, IgrDocumentHost, IgrDocumentHostModule, IgrDragService, IgrDragServiceModule, IgrDropdown, IgrDropdownGroup, IgrDropdownGroupModule, IgrDropdownHeader, IgrDropdownHeaderModule, IgrDropdownItem, IgrDropdownItemCollection, IgrDropdownItemComponentEventArgs, IgrDropdownItemModule, IgrDropdownModule, IgrExpansionPanel, IgrExpansionPanelComponentEventArgs, IgrExpansionPanelModule, IgrFilteringOptions, IgrFloatPaneAction, IgrFloatingPaneResizeEventArgs, IgrFloatingPaneResizeEventArgsDetail, IgrFloatingPaneResizeMoveEventArgs, IgrFloatingPaneResizeMoveEventArgsDetail, IgrFocusOptions, IgrIcon, IgrIconButton, IgrIconButtonModule, IgrIconModule, IgrInput, IgrInputBase, IgrInputBaseModule, IgrInputModule, IgrKeyBindingHandler, IgrKeyBindingOptions, IgrLayoutChangeEventArgs, IgrLinearProgress, IgrLinearProgressModule, IgrList, IgrListHeader, IgrListHeaderModule, IgrListItem, IgrListItemModule, IgrListModule, IgrMaskInput, IgrMaskInputBase, IgrMaskInputBaseModule, IgrMaskInputModule, IgrMoveFloatingPaneAction, IgrMoveTabAction, IgrNavDrawer, IgrNavDrawerHeaderItem, IgrNavDrawerHeaderItemModule, IgrNavDrawerItem, IgrNavDrawerItemModule, IgrNavDrawerModule, IgrNavbar, IgrNavbarModule, IgrNumberEventArgs, IgrPaneCloseEventArgs, IgrPaneCloseEventArgsDetail, IgrPaneDragAction, IgrPaneDragEndEventArgs, IgrPaneDragEndEventArgsDetail, IgrPaneDragOverEventArgs, IgrPaneDragOverEventArgsDetail, IgrPaneDragStartEventArgs, IgrPaneDragStartEventArgsDetail, IgrPaneHeaderConnectionEventArgs, IgrPaneHeaderConnectionEventArgsDetail, IgrPaneHeaderElement, IgrPaneHeaderElementModule, IgrPanePinnedEventArgs, IgrPanePinnedEventArgsDetail, IgrPaneScrollEventArgs, IgrPaneScrollEventArgsDetail, IgrProgressBase, IgrProgressBaseModule, IgrRadio, IgrRadioChangeEventArgs, IgrRadioChangeEventArgsDetail, IgrRadioGroup, IgrRadioGroupModule, IgrRadioModule, IgrRangeSlider, IgrRangeSliderModule, IgrRangeSliderValue, IgrRangeSliderValueEventArgs, IgrRating, IgrRatingModule, IgrRatingSymbol, IgrRatingSymbolModule, IgrRipple, IgrRippleModule, IgrSelect, IgrSelectGroup, IgrSelectGroupModule, IgrSelectHeader, IgrSelectHeaderModule, IgrSelectItem, IgrSelectItemComponentEventArgs, IgrSelectItemModule, IgrSelectModule, IgrSlider, IgrSliderBase, IgrSliderBaseModule, IgrSliderLabel, IgrSliderLabelModule, IgrSliderModule, IgrSnackbar, IgrSnackbarModule, IgrSplitPane, IgrSplitPaneCollection, IgrSplitPaneModule, IgrSplitterResizeEventArgs, IgrStep, IgrStepModule, IgrStepper, IgrStepperModule, IgrSwitch, IgrSwitchModule, IgrTab, IgrTabComponentEventArgs, IgrTabGroupPane, IgrTabGroupPaneModule, IgrTabHeaderConnectionEventArgs, IgrTabHeaderConnectionEventArgsDetail, IgrTabHeaderElement, IgrTabHeaderElementModule, IgrTabModule, IgrTabPanel, IgrTabPanelModule, IgrTabs, IgrTabsModule, IgrTextarea, IgrTextareaModule, IgrToast, IgrToastModule, IgrToggleButton, IgrToggleButtonModule, IgrTree, IgrTreeItem, IgrTreeItemCollection, IgrTreeItemComponentEventArgs, IgrTreeItemModule, IgrTreeModule, IgrTreeSelectionChange, IgrTreeSelectionChangeDetail, IgrTreeSelectionChangeEventArgs, IgrTreeSelectionOptionsEventArgs, IgrTreeSelectionOptionsEventDetail, IgrValidatorHandler, IgrVoidEventArgs, Input, InputBase, InputType, InputType_$type, KeyBindingHandler, KeyBindingOptions, KeyBindingTrigger, KeyBindingTrigger_$type, LayoutChangeEventArgs, LinearProgress, LinearProgressLabelAlign, LinearProgressLabelAlign_$type, List, ListHeader, ListItem, MaskInput, MaskInputBase, MaskInputValueMode, MaskInputValueMode_$type, MoveFloatingPaneAction, MoveTabAction, NavDrawer, NavDrawerHeaderItem, NavDrawerItem, NavDrawerPosition, NavDrawerPosition_$type, Navbar, NumberEventArgs, NumberFormatOptions_$type, PaneCloseEventArgs, PaneCloseEventArgsDetail, PaneDragAction, PaneDragActionType, PaneDragActionType_$type, PaneDragEndEventArgs, PaneDragEndEventArgsDetail, PaneDragOverEventArgs, PaneDragOverEventArgsDetail, PaneDragStartEventArgs, PaneDragStartEventArgsDetail, PaneHeaderConnectionEventArgs, PaneHeaderConnectionEventArgsDetail, PaneHeaderElement, PanePinnedEventArgs, PanePinnedEventArgsDetail, PaneScrollEventArgs, PaneScrollEventArgsDetail, ProgressBase, Radio, RadioChangeEventArgs, RadioChangeEventArgsDetail, RadioGroup, RadioGroupAlignment, RadioGroupAlignment_$type, RadioLabelPosition, RadioLabelPosition_$type, RangeSlider, RangeSliderValue, RangeSliderValueEventArgs, RangeTextSelectMode, RangeTextSelectMode_$type, Rating, RatingSymbol, ResizerLocation, ResizerLocation_$type, Ripple, Select, SelectGroup, SelectHeader, SelectItem, SelectItemComponentEventArgs, SelectScrollStrategy, SelectScrollStrategy_$type, SelectionRangeDirection, SelectionRangeDirection_$type, SizableComponentSize, SizableComponentSize_$type, Slider, SliderBase, SliderBaseTickOrientation, SliderBaseTickOrientation_$type, SliderLabel, Snackbar, SplitPane, SplitPaneCollection, SplitPaneOrientation, SplitPaneOrientation_$type, SplitterResizeEventArgs, Step, StepDirection, StepDirection_$type, StepType, StepType_$type, Stepper, StepperHorizontalAnimation, StepperHorizontalAnimation_$type, StepperOrientation, StepperOrientation_$type, StepperStepType, StepperStepType_$type, StepperTitlePosition, StepperTitlePosition_$type, StepperVerticalAnimation, StepperVerticalAnimation_$type, StyleVariant, StyleVariant_$type, Switch, Tab, TabComponentEventArgs, TabGroupPane, TabHeaderConnectionEventArgs, TabHeaderConnectionEventArgsDetail, TabHeaderElement, TabPanel, Tabs, TabsActivation, TabsActivation_$type, TabsAlignment, TabsAlignment_$type, Textarea, TextareaAutocapitalize, TextareaAutocapitalize_$type, TextareaInputMode, TextareaInputMode_$type, TextareaResize, TextareaResize_$type, TextareaWrap, TextareaWrap_$type, TickLabelRotation, TickLabelRotation_$type, Toast, ToggleButton, Tree, TreeItem, TreeItemCollection, TreeItemComponentEventArgs, TreeSelection, TreeSelectionChange, TreeSelectionChangeDetail, TreeSelectionChangeEventArgs, TreeSelectionOptionsEventArgs, TreeSelectionOptionsEventDetail, TreeSelection_$type, UnpinnedLocation, UnpinnedLocation_$type, ValidatorHandler, VoidEventArgs, WCNativeHelper, WeekDays, WeekDays_$type };
